{"ast":null,"code":"import { pbkdf2, sha256 } from \"../crypto/index.js\";\nimport { defineProperties, getBytes, hexlify, assertNormalize, assertPrivate, assertArgument, toUtf8Bytes } from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\"; // Returns a byte with the MSB bits set\n\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits & 0xff;\n} // Returns a byte with the LSB bits set\n\n\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1 & 0xff;\n}\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  assertNormalize(\"NFKD\");\n\n  if (wordlist == null) {\n    wordlist = LangEn.wordlist();\n  }\n\n  const words = wordlist.split(mnemonic);\n  assertArgument(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n  const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n  let offset = 0;\n\n  for (let i = 0; i < words.length; i++) {\n    let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, \"mnemonic\", \"[ REDACTED ]\");\n\n    for (let bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n\n      offset++;\n    }\n  }\n\n  const entropyBits = 32 * words.length / 3;\n  const checksumBits = words.length / 3;\n  const checksumMask = getUpperMask(checksumBits);\n  const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n  assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask), \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n  return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n\n  if (wordlist == null) {\n    wordlist = LangEn.wordlist();\n  }\n\n  const indices = [0];\n  let remainingBits = 11;\n\n  for (let i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8; // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits; // Start the next word\n\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  } // Compute the checksum bits\n\n\n  const checksumBits = entropy.length / 4;\n  const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits); // Shift the checksum into the word indices\n\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(index => wordlist.getWord(index)));\n}\n\nconst _guard = {};\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip39]]\n *  seeds and convert between phrases and entropy.\n */\n\nexport class Mnemonic {\n  /**\n   *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n   *\n   *  Use the [[wordlist]] ``split`` method to get the individual words.\n   */\n  phrase;\n  /**\n   *  The password used for this mnemonic. If no password is used this\n   *  is the empty string (i.e. ``\"\"``) as per the specification.\n   */\n\n  password;\n  /**\n   *  The wordlist for this mnemonic.\n   */\n\n  wordlist;\n  /**\n   *  The underlying entropy which the mnemonic encodes.\n   */\n\n  entropy;\n  /**\n   *  @private\n   */\n\n  constructor(guard, entropy, phrase, password, wordlist) {\n    if (password == null) {\n      password = \"\";\n    }\n\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n\n    assertPrivate(guard, _guard, \"Mnemonic\");\n    defineProperties(this, {\n      phrase,\n      password,\n      wordlist,\n      entropy\n    });\n  }\n  /**\n   *  Returns the seed for the mnemonic.\n   */\n\n\n  computeSeed() {\n    const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\");\n    return pbkdf2(toUtf8Bytes(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n  }\n  /**\n   *  Creates a new Mnemonic for the %%phrase%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n\n\n  static fromPhrase(phrase, password, wordlist) {\n    // Normalize the case and space; throws if invalid\n    const entropy = mnemonicToEntropy(phrase, wordlist);\n    phrase = entropyToMnemonic(getBytes(entropy), wordlist);\n    return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n  }\n  /**\n   *  Create a new **Mnemonic** from the %%entropy%%.\n   *\n   *  The default %%password%% is the empty string and the default\n   *  wordlist is the [English wordlists](LangEn).\n   */\n\n\n  static fromEntropy(_entropy, password, wordlist) {\n    const entropy = getBytes(_entropy, \"entropy\");\n    const phrase = entropyToMnemonic(entropy, wordlist);\n    return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\n  }\n  /**\n   *  Returns the phrase for %%mnemonic%%.\n   */\n\n\n  static entropyToPhrase(_entropy, wordlist) {\n    const entropy = getBytes(_entropy, \"entropy\");\n    return entropyToMnemonic(entropy, wordlist);\n  }\n  /**\n   *  Returns the entropy for %%phrase%%.\n   */\n\n\n  static phraseToEntropy(phrase, wordlist) {\n    return mnemonicToEntropy(phrase, wordlist);\n  }\n  /**\n   *  Returns true if %%phrase%% is a valid [[link-bip39]] phrase.\n   *\n   *  This checks all the provided words belong to the %%wordlist%%,\n   *  that the length is valid and the checksum is correct.\n   */\n\n\n  static isValidMnemonic(phrase, wordlist) {\n    try {\n      mnemonicToEntropy(phrase, wordlist);\n      return true;\n    } catch (error) {}\n\n    return false;\n  }\n\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,MAAjB,QAA+B,oBAA/B;AACA,SACIC,gBADJ,EACsBC,QADtB,EACgCC,OADhC,EACyCC,eADzC,EAC0DC,aAD1D,EACyEC,cADzE,EACyFC,WADzF,QAEO,mBAFP;AAGA,SAASC,MAAT,QAAuB,yBAAvB,C,CAMA;;AACA,SAASC,YAAT,CAAsBC,IAAtB,EAAkC;AAC/B,SAAQ,CAAC,KAAKA,IAAN,IAAc,CAAf,IAAsB,IAAIA,IAA1B,GAAkC,IAAzC;AACF,C,CAED;;;AACA,SAASC,YAAT,CAAsBD,IAAtB,EAAkC;AAC/B,SAAQ,CAAC,KAAKA,IAAN,IAAc,CAAf,GAAoB,IAA3B;AACF;;AAGD,SAASE,iBAAT,CAA2BC,QAA3B,EAA6CC,QAA7C,EAAuE;AACnEV,iBAAe,CAAC,MAAD,CAAf;;AAEA,MAAIU,QAAQ,IAAI,IAAhB,EAAsB;AAAEA,YAAQ,GAAGN,MAAM,CAACM,QAAP,EAAX;AAA+B;;AAEvD,QAAMC,KAAK,GAAGD,QAAQ,CAACE,KAAT,CAAeH,QAAf,CAAd;AACAP,gBAAc,CAAES,KAAK,CAACE,MAAN,GAAe,CAAhB,KAAuB,CAAvB,IAA4BF,KAAK,CAACE,MAAN,IAAgB,EAA5C,IAAkDF,KAAK,CAACE,MAAN,IAAgB,EAAnE,EACV,yBADU,EACiB,UADjB,EAC6B,cAD7B,CAAd;AAGA,QAAMC,OAAO,GAAG,IAAIC,UAAJ,CAAeC,IAAI,CAACC,IAAL,CAAU,KAAKN,KAAK,CAACE,MAAX,GAAoB,CAA9B,CAAf,CAAhB;AAEA,MAAIK,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,KAAK,CAACE,MAA1B,EAAkCM,CAAC,EAAnC,EAAuC;AACnC,QAAIC,KAAK,GAAGV,QAAQ,CAACW,YAAT,CAAsBV,KAAK,CAACQ,CAAD,CAAL,CAASG,SAAT,CAAmB,MAAnB,CAAtB,CAAZ;AACApB,kBAAc,CAACkB,KAAK,IAAI,CAAV,EAAa,kCAAmCD,CAAE,EAAlD,EAAsD,UAAtD,EAAkE,cAAlE,CAAd;;AAEA,SAAK,IAAII,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAG,EAAxB,EAA4BA,GAAG,EAA/B,EAAmC;AAC/B,UAAIH,KAAK,GAAI,KAAM,KAAKG,GAAxB,EAA+B;AAC3BT,eAAO,CAACI,MAAM,IAAI,CAAX,CAAP,IAAyB,KAAM,IAAKA,MAAM,GAAG,CAA7C;AACH;;AACDA,YAAM;AACT;AACJ;;AAED,QAAMM,WAAW,GAAG,KAAKb,KAAK,CAACE,MAAX,GAAoB,CAAxC;AAGA,QAAMY,YAAY,GAAGd,KAAK,CAACE,MAAN,GAAe,CAApC;AACA,QAAMa,YAAY,GAAGrB,YAAY,CAACoB,YAAD,CAAjC;AAEA,QAAME,QAAQ,GAAG7B,QAAQ,CAACF,MAAM,CAACkB,OAAO,CAACc,KAAR,CAAc,CAAd,EAAiBJ,WAAW,GAAG,CAA/B,CAAD,CAAP,CAAR,CAAoD,CAApD,IAAyDE,YAA1E;AAEAxB,gBAAc,CAACyB,QAAQ,MAAMb,OAAO,CAACA,OAAO,CAACD,MAAR,GAAiB,CAAlB,CAAP,GAA8Ba,YAApC,CAAT,EACV,2BADU,EACmB,UADnB,EAC+B,cAD/B,CAAd;AAGA,SAAO3B,OAAO,CAACe,OAAO,CAACc,KAAR,CAAc,CAAd,EAAiBJ,WAAW,GAAG,CAA/B,CAAD,CAAd;AACH;;AAED,SAASK,iBAAT,CAA2Bf,OAA3B,EAAgDJ,QAAhD,EAA0E;AAEtER,gBAAc,CAAEY,OAAO,CAACD,MAAR,GAAiB,CAAlB,KAAyB,CAAzB,IAA8BC,OAAO,CAACD,MAAR,IAAkB,EAAhD,IAAsDC,OAAO,CAACD,MAAR,IAAkB,EAAzE,EACV,sBADU,EACc,SADd,EACyB,cADzB,CAAd;;AAGA,MAAIH,QAAQ,IAAI,IAAhB,EAAsB;AAAEA,YAAQ,GAAGN,MAAM,CAACM,QAAP,EAAX;AAA+B;;AAEvD,QAAMoB,OAAO,GAAkB,CAAE,CAAF,CAA/B;AAEA,MAAIC,aAAa,GAAG,EAApB;;AACA,OAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACD,MAA5B,EAAoCM,CAAC,EAArC,EAAyC;AAErC;AACA,QAAIY,aAAa,GAAG,CAApB,EAAuB;AACnBD,aAAO,CAACA,OAAO,CAACjB,MAAR,GAAiB,CAAlB,CAAP,KAAgC,CAAhC;AACAiB,aAAO,CAACA,OAAO,CAACjB,MAAR,GAAiB,CAAlB,CAAP,IAA+BC,OAAO,CAACK,CAAD,CAAtC;AAEAY,mBAAa,IAAI,CAAjB,CAJmB,CAMvB;AACC,KAPD,MAOO;AACHD,aAAO,CAACA,OAAO,CAACjB,MAAR,GAAiB,CAAlB,CAAP,KAAgCkB,aAAhC;AACAD,aAAO,CAACA,OAAO,CAACjB,MAAR,GAAiB,CAAlB,CAAP,IAA+BC,OAAO,CAACK,CAAD,CAAP,IAAe,IAAIY,aAAlD,CAFG,CAIH;;AACAD,aAAO,CAACE,IAAR,CAAalB,OAAO,CAACK,CAAD,CAAP,GAAaZ,YAAY,CAAC,IAAIwB,aAAL,CAAtC;AAEAA,mBAAa,IAAI,CAAjB;AACH;AACJ,GA7BqE,CA+BtE;;;AACA,QAAMN,YAAY,GAAGX,OAAO,CAACD,MAAR,GAAiB,CAAtC;AACA,QAAMc,QAAQ,GAAGM,QAAQ,CAACrC,MAAM,CAACkB,OAAD,CAAN,CAAgBoB,SAAhB,CAA0B,CAA1B,EAA6B,CAA7B,CAAD,EAAkC,EAAlC,CAAR,GAAgD7B,YAAY,CAACoB,YAAD,CAA7E,CAjCsE,CAmCtE;;AACAK,SAAO,CAACA,OAAO,CAACjB,MAAR,GAAiB,CAAlB,CAAP,KAAgCY,YAAhC;AACAK,SAAO,CAACA,OAAO,CAACjB,MAAR,GAAiB,CAAlB,CAAP,IAAgCc,QAAQ,IAAK,IAAIF,YAAjD;AAEA,SAAOf,QAAQ,CAACyB,IAAT,CAAcL,OAAO,CAACM,GAAR,CAAahB,KAAD,IAAsBV,QAAS,CAAC2B,OAAV,CAAkBjB,KAAlB,CAAlC,CAAd,CAAP;AACH;;AAED,MAAMkB,MAAM,GAAG,EAAf;AAEA;;;;;AAIA,OAAM,MAAOC,QAAP,CAAe;AACjB;;;;;AAKSC,QAAM;AAEf;;;;;AAISC,UAAQ;AAEjB;;;;AAGS/B,UAAQ;AAEjB;;;;AAGSI,SAAO;AAEhB;;;;AAGA4B,cAAYC,KAAZ,EAAwB7B,OAAxB,EAAyC0B,MAAzC,EAAyDC,QAAzD,EAAmF/B,QAAnF,EAA6G;AACzG,QAAI+B,QAAQ,IAAI,IAAhB,EAAsB;AAAEA,cAAQ,GAAG,EAAX;AAAgB;;AACxC,QAAI/B,QAAQ,IAAI,IAAhB,EAAsB;AAAEA,cAAQ,GAAGN,MAAM,CAACM,QAAP,EAAX;AAA+B;;AACvDT,iBAAa,CAAC0C,KAAD,EAAQL,MAAR,EAAgB,UAAhB,CAAb;AACAzC,oBAAgB,CAAW,IAAX,EAAiB;AAAE2C,YAAF;AAAUC,cAAV;AAAoB/B,cAApB;AAA8BI;AAA9B,KAAjB,CAAhB;AACH;AAED;;;;;AAGA8B,aAAW;AACP,UAAMC,IAAI,GAAG1C,WAAW,CAAC,aAAa,KAAKsC,QAAnB,EAA6B,MAA7B,CAAxB;AACA,WAAO9C,MAAM,CAACQ,WAAW,CAAC,KAAKqC,MAAN,EAAc,MAAd,CAAZ,EAAmCK,IAAnC,EAAyC,IAAzC,EAA+C,EAA/C,EAAmD,QAAnD,CAAb;AACH;AAED;;;;;;;;AAMiB,SAAVC,UAAU,CAACN,MAAD,EAAiBC,QAAjB,EAA2C/B,QAA3C,EAAqE;AAClF;AACA,UAAMI,OAAO,GAAGN,iBAAiB,CAACgC,MAAD,EAAS9B,QAAT,CAAjC;AACA8B,UAAM,GAAGX,iBAAiB,CAAC/B,QAAQ,CAACgB,OAAD,CAAT,EAAoBJ,QAApB,CAA1B;AACA,WAAO,IAAI6B,QAAJ,CAAaD,MAAb,EAAqBxB,OAArB,EAA8B0B,MAA9B,EAAsCC,QAAtC,EAAgD/B,QAAhD,CAAP;AACH;AAED;;;;;;;;AAMkB,SAAXqC,WAAW,CAACC,QAAD,EAAsBP,QAAtB,EAAgD/B,QAAhD,EAA0E;AACxF,UAAMI,OAAO,GAAGhB,QAAQ,CAACkD,QAAD,EAAW,SAAX,CAAxB;AACA,UAAMR,MAAM,GAAGX,iBAAiB,CAACf,OAAD,EAAUJ,QAAV,CAAhC;AACA,WAAO,IAAI6B,QAAJ,CAAaD,MAAb,EAAqBvC,OAAO,CAACe,OAAD,CAA5B,EAAuC0B,MAAvC,EAA+CC,QAA/C,EAAyD/B,QAAzD,CAAP;AACH;AAED;;;;;AAGsB,SAAfuC,eAAe,CAACD,QAAD,EAAsBtC,QAAtB,EAAgD;AAClE,UAAMI,OAAO,GAAGhB,QAAQ,CAACkD,QAAD,EAAW,SAAX,CAAxB;AACA,WAAOnB,iBAAiB,CAACf,OAAD,EAAUJ,QAAV,CAAxB;AACH;AAED;;;;;AAGsB,SAAfwC,eAAe,CAACV,MAAD,EAAiB9B,QAAjB,EAA2C;AAC7D,WAAOF,iBAAiB,CAACgC,MAAD,EAAS9B,QAAT,CAAxB;AACH;AAED;;;;;;;;AAMsB,SAAfyC,eAAe,CAACX,MAAD,EAAiB9B,QAAjB,EAA2C;AAC7D,QAAI;AACAF,uBAAiB,CAACgC,MAAD,EAAS9B,QAAT,CAAjB;AACA,aAAO,IAAP;AACH,KAHD,CAGE,OAAO0C,KAAP,EAAc,CAAG;;AACnB,WAAO,KAAP;AACH;;AA9FgB","names":["pbkdf2","sha256","defineProperties","getBytes","hexlify","assertNormalize","assertPrivate","assertArgument","toUtf8Bytes","LangEn","getUpperMask","bits","getLowerMask","mnemonicToEntropy","mnemonic","wordlist","words","split","length","entropy","Uint8Array","Math","ceil","offset","i","index","getWordIndex","normalize","bit","entropyBits","checksumBits","checksumMask","checksum","slice","entropyToMnemonic","indices","remainingBits","push","parseInt","substring","join","map","getWord","_guard","Mnemonic","phrase","password","constructor","guard","computeSeed","salt","fromPhrase","fromEntropy","_entropy","entropyToPhrase","phraseToEntropy","isValidMnemonic","error"],"sourceRoot":"","sources":["../../src.ts/wallet/mnemonic.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}