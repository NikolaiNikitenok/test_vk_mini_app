{"ast":null,"code":"/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\n\nfunction _getBytes(value, name, copy) {\n  if (value instanceof Uint8Array) {\n    if (copy) {\n      return new Uint8Array(value);\n    }\n\n    return value;\n  }\n\n  if (typeof value === \"string\" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {\n    const result = new Uint8Array((value.length - 2) / 2);\n    let offset = 2;\n\n    for (let i = 0; i < result.length; i++) {\n      result[i] = parseInt(value.substring(offset, offset + 2), 16);\n      offset += 2;\n    }\n\n    return result;\n  }\n\n  assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\n\n\nexport function getBytes(value, name) {\n  return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\n\nexport function getBytesCopy(value, name) {\n  return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\n\nexport function isHexString(value, length) {\n  if (typeof value !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n    return false;\n  }\n\n  if (typeof length === \"number\" && value.length !== 2 + 2 * length) {\n    return false;\n  }\n\n  if (length === true && value.length % 2 !== 0) {\n    return false;\n  }\n\n  return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\n\nexport function isBytesLike(value) {\n  return isHexString(value, true) || value instanceof Uint8Array;\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\n\nexport function hexlify(data) {\n  const bytes = getBytes(data);\n  let result = \"0x\";\n\n  for (let i = 0; i < bytes.length; i++) {\n    const v = bytes[i];\n    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n  }\n\n  return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\n\nexport function concat(datas) {\n  return \"0x\" + datas.map(d => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\n\nexport function dataLength(data) {\n  if (isHexString(data, true)) {\n    return (data.length - 2) / 2;\n  }\n\n  return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\n\nexport function dataSlice(data, start, end) {\n  const bytes = getBytes(data);\n\n  if (end != null && end > bytes.length) {\n    assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n      buffer: bytes,\n      length: bytes.length,\n      offset: end\n    });\n  }\n\n  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\n\nexport function stripZerosLeft(data) {\n  let bytes = hexlify(data).substring(2);\n\n  while (bytes.substring(0, 2) == \"00\") {\n    bytes = bytes.substring(2);\n  }\n\n  return \"0x\" + bytes;\n}\n\nfunction zeroPad(data, length, left) {\n  const bytes = getBytes(data);\n  assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n    buffer: new Uint8Array(bytes),\n    length: length,\n    offset: length + 1\n  });\n  const result = new Uint8Array(length);\n  result.fill(0);\n\n  if (left) {\n    result.set(bytes, length - bytes.length);\n  } else {\n    result.set(bytes, 0);\n  }\n\n  return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrun]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\n\n\nexport function zeroPadValue(data, length) {\n  return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrun]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\n\nexport function zeroPadBytes(data, length) {\n  return zeroPad(data, length, false);\n}","map":{"version":3,"mappings":"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","names":["assert","assertArgument","_getBytes","value","name","copy","Uint8Array","match","result","length","offset","i","parseInt","substring","getBytes","getBytesCopy","isHexString","isBytesLike","HexCharacters","hexlify","data","bytes","v","concat","datas","map","d","join","dataLength","dataSlice","start","end","buffer","slice","stripZerosLeft","zeroPad","left","fill","set","zeroPadValue","zeroPadBytes"],"sourceRoot":"","sources":["../../src.ts/utils/data.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}