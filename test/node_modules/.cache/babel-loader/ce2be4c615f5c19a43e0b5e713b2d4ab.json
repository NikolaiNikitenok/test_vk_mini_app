{"ast":null,"code":"/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1); //const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\n\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\n\nexport function fromTwos(_value, _width) {\n  const value = getUint(_value, \"value\");\n  const width = BigInt(getNumber(_width, \"width\"));\n  assert(value >> width === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n    operation: \"fromTwos\",\n    fault: \"overflow\",\n    value: _value\n  }); // Top bit set; treat as a negative value\n\n  if (value >> width - BN_1) {\n    const mask = (BN_1 << width) - BN_1;\n    return -((~value & mask) + BN_1);\n  }\n\n  return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\n\nexport function toTwos(_value, _width) {\n  let value = getBigInt(_value, \"value\");\n  const width = BigInt(getNumber(_width, \"width\"));\n  const limit = BN_1 << width - BN_1;\n\n  if (value < BN_0) {\n    value = -value;\n    assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n    const mask = (BN_1 << width) - BN_1;\n    return (~value & mask) + BN_1;\n  } else {\n    assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n      operation: \"toTwos\",\n      fault: \"overflow\",\n      value: _value\n    });\n  }\n\n  return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\n\nexport function mask(_value, _bits) {\n  const value = getUint(_value, \"value\");\n  const bits = BigInt(getNumber(_bits, \"bits\"));\n  return value & (BN_1 << bits) - BN_1;\n}\n/**\n *  Gets a [[BigInt]] from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\n\nexport function getBigInt(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      return value;\n\n    case \"number\":\n      assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return BigInt(value);\n\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n\n        if (value[0] === \"-\" && value[1] !== \"-\") {\n          return -BigInt(value.substring(1));\n        }\n\n        return BigInt(value);\n      } catch (e) {\n        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n      }\n\n  }\n\n  assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\nexport function getUint(value, name) {\n  const result = getBigInt(value, name);\n  assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n    fault: \"overflow\",\n    operation: \"getUint\",\n    value\n  });\n  return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\n\nexport function toBigInt(value) {\n  if (value instanceof Uint8Array) {\n    let result = \"0x0\";\n\n    for (const v of value) {\n      result += Nibbles[v >> 4];\n      result += Nibbles[v & 0x0f];\n    }\n\n    return BigInt(result);\n  }\n\n  return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\n\nexport function getNumber(value, name) {\n  switch (typeof value) {\n    case \"bigint\":\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return Number(value);\n\n    case \"number\":\n      assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n      assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n      return value;\n\n    case \"string\":\n      try {\n        if (value === \"\") {\n          throw new Error(\"empty string\");\n        }\n\n        return getNumber(BigInt(value), name);\n      } catch (e) {\n        assertArgument(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n      }\n\n  }\n\n  assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\n\nexport function toNumber(value) {\n  return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\n\nexport function toBeHex(_value, _width) {\n  const value = getUint(_value, \"value\");\n  let result = value.toString(16);\n\n  if (_width == null) {\n    // Ensure the value is of even length\n    if (result.length % 2) {\n      result = \"0\" + result;\n    }\n  } else {\n    const width = getNumber(_width, \"width\");\n    assert(width * 2 >= result.length, `value exceeds width (${width} bits)`, \"NUMERIC_FAULT\", {\n      operation: \"toBeHex\",\n      fault: \"overflow\",\n      value: _value\n    }); // Pad the value to the required width\n\n    while (result.length < width * 2) {\n      result = \"0\" + result;\n    }\n  }\n\n  return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\n\nexport function toBeArray(_value) {\n  const value = getUint(_value, \"value\");\n\n  if (value === BN_0) {\n    return new Uint8Array([]);\n  }\n\n  let hex = value.toString(16);\n\n  if (hex.length % 2) {\n    hex = \"0\" + hex;\n  }\n\n  const result = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < result.length; i++) {\n    const offset = i * 2;\n    result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n  }\n\n  return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\n\nexport function toQuantity(value) {\n  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);\n\n  while (result.substring(0, 1) === \"0\") {\n    result = result.substring(1);\n  }\n\n  if (result === \"\") {\n    result = \"0\";\n  }\n\n  return \"0x\" + result;\n}","map":{"version":3,"mappings":"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","names":["hexlify","isBytesLike","assert","assertArgument","BN_0","BigInt","BN_1","maxValue","fromTwos","_value","_width","value","getUint","width","getNumber","operation","fault","mask","toTwos","getBigInt","limit","_bits","bits","name","Number","isInteger","Error","substring","e","message","result","Nibbles","toBigInt","Uint8Array","v","toNumber","toBeHex","toString","length","toBeArray","hex","i","offset","parseInt","toQuantity"],"sourceRoot":"","sources":["../../src.ts/utils/maths.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}