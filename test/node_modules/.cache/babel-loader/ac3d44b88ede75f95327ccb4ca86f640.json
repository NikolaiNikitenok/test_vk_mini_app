{"ast":null,"code":"/**\r\n *  About frgaments...\r\n *\r\n *  @_subsection api/abi/abi-coder:Fragments\r\n */\nimport { defineProperties, getBigInt, getNumber, assert, assertPrivate, assertArgument } from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n; // [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\n\nfunction setify(items) {\n  const result = new Set();\n  items.forEach(k => result.add(k));\n  return Object.freeze(result);\n} // Visibility Keywords\n\n\nconst _kwVisib = \"constant external internal payable private public pure view\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\"; // All Keywords\n\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\n\nconst Keywords = setify(_keywords.split(\" \")); // Single character tokens\n\nconst SimpleTokens = {\n  \"(\": \"OPEN_PAREN\",\n  \")\": \"CLOSE_PAREN\",\n  \"[\": \"OPEN_BRACKET\",\n  \"]\": \"CLOSE_BRACKET\",\n  \",\": \"COMMA\",\n  \"@\": \"AT\"\n}; // Parser regexes to consume the next token\n\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\"); // Parser regexs to check validity\n\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\n\nclass TokenString {\n  #offset;\n  #tokens;\n\n  get offset() {\n    return this.#offset;\n  }\n\n  get length() {\n    return this.#tokens.length - this.#offset;\n  }\n\n  constructor(tokens) {\n    this.#offset = 0;\n    this.#tokens = tokens.slice();\n  }\n\n  clone() {\n    return new TokenString(this.#tokens);\n  }\n\n  reset() {\n    this.#offset = 0;\n  }\n\n  #subTokenString() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return new TokenString(this.#tokens.slice(from, to).map(t => {\n      return Object.freeze(Object.assign({}, t, {\n        match: t.match - from,\n        linkBack: t.linkBack - from,\n        linkNext: t.linkNext - from\n      }));\n      return t;\n    }));\n  } // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n\n\n  popKeyword(allowed) {\n    const top = this.peek();\n\n    if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n      throw new Error(`expected keyword ${top.text}`);\n    }\n\n    return this.pop().text;\n  } // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n\n\n  popType(type) {\n    if (this.peek().type !== type) {\n      throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);\n    }\n\n    return this.pop().text;\n  } // Pops and returns a \"(\" TOKENS \")\"\n\n\n  popParen() {\n    const top = this.peek();\n\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n\n    const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n    this.#offset = top.match + 1;\n    return result;\n  } // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n\n\n  popParams() {\n    const top = this.peek();\n\n    if (top.type !== \"OPEN_PAREN\") {\n      throw new Error(\"bad start\");\n    }\n\n    const result = [];\n\n    while (this.#offset < top.match - 1) {\n      const link = this.peek().linkNext;\n      result.push(this.#subTokenString(this.#offset + 1, link));\n      this.#offset = link;\n    }\n\n    this.#offset = top.match + 1;\n    return result;\n  } // Returns the top Token, throwing if out of tokens\n\n\n  peek() {\n    if (this.#offset >= this.#tokens.length) {\n      throw new Error(\"out-of-bounds\");\n    }\n\n    return this.#tokens[this.#offset];\n  } // Returns the next value, if it is a keyword in `allowed`\n\n\n  peekKeyword(allowed) {\n    const top = this.peekType(\"KEYWORD\");\n    return top != null && allowed.has(top) ? top : null;\n  } // Returns the value of the next token if it is `type`\n\n\n  peekType(type) {\n    if (this.length === 0) {\n      return null;\n    }\n\n    const top = this.peek();\n    return top.type === type ? top.text : null;\n  } // Returns the next token; throws if out of tokens\n\n\n  pop() {\n    const result = this.peek();\n    this.#offset++;\n    return result;\n  }\n\n  toString() {\n    const tokens = [];\n\n    for (let i = this.#offset; i < this.#tokens.length; i++) {\n      const token = this.#tokens[i];\n      tokens.push(`${token.type}:${token.text}`);\n    }\n\n    return `<TokenString ${tokens.join(\" \")}>`;\n  }\n\n}\n\nfunction lex(text) {\n  const tokens = [];\n\n  const throwError = message => {\n    const token = offset < text.length ? JSON.stringify(text[offset]) : \"$EOI\";\n    throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n  };\n\n  let brackets = [];\n  let commas = [];\n  let offset = 0;\n\n  while (offset < text.length) {\n    // Strip off any leading whitespace\n    let cur = text.substring(offset);\n    let match = cur.match(regexWhitespacePrefix);\n\n    if (match) {\n      offset += match[1].length;\n      cur = text.substring(offset);\n    }\n\n    const token = {\n      depth: brackets.length,\n      linkBack: -1,\n      linkNext: -1,\n      match: -1,\n      type: \"\",\n      text: \"\",\n      offset,\n      value: -1\n    };\n    tokens.push(token);\n    let type = SimpleTokens[cur[0]] || \"\";\n\n    if (type) {\n      token.type = type;\n      token.text = cur[0];\n      offset++;\n\n      if (type === \"OPEN_PAREN\") {\n        brackets.push(tokens.length - 1);\n        commas.push(tokens.length - 1);\n      } else if (type == \"CLOSE_PAREN\") {\n        if (brackets.length === 0) {\n          throwError(\"no matching open bracket\");\n        }\n\n        token.match = brackets.pop();\n        tokens[token.match].match = tokens.length - 1;\n        token.depth--;\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n      } else if (type === \"COMMA\") {\n        token.linkBack = commas.pop();\n        tokens[token.linkBack].linkNext = tokens.length - 1;\n        commas.push(tokens.length - 1);\n      } else if (type === \"OPEN_BRACKET\") {\n        token.type = \"BRACKET\";\n      } else if (type === \"CLOSE_BRACKET\") {\n        // Remove the CLOSE_BRACKET\n        let suffix = tokens.pop().text;\n\n        if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n          const value = tokens.pop().text;\n          suffix = value + suffix;\n          tokens[tokens.length - 1].value = getNumber(value);\n        }\n\n        if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n          throw new Error(\"missing opening bracket\");\n        }\n\n        tokens[tokens.length - 1].text += suffix;\n      }\n\n      continue;\n    }\n\n    match = cur.match(regexIdPrefix);\n\n    if (match) {\n      token.text = match[1];\n      offset += token.text.length;\n\n      if (Keywords.has(token.text)) {\n        token.type = \"KEYWORD\";\n        continue;\n      }\n\n      if (token.text.match(regexType)) {\n        token.type = \"TYPE\";\n        continue;\n      }\n\n      token.type = \"ID\";\n      continue;\n    }\n\n    match = cur.match(regexNumberPrefix);\n\n    if (match) {\n      token.text = match[1];\n      token.type = \"NUMBER\";\n      offset += token.text.length;\n      continue;\n    }\n\n    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n  }\n\n  return new TokenString(tokens.map(t => Object.freeze(t)));\n} // Check only one of `allowed` is in `set`\n\n\nfunction allowSingle(set, allowed) {\n  let included = [];\n\n  for (const key in allowed.keys()) {\n    if (set.has(key)) {\n      included.push(key);\n    }\n  }\n\n  if (included.length > 1) {\n    throw new Error(`conflicting types: ${included.join(\", \")}`);\n  }\n} // Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\n\n\nfunction consumeName(type, tokens) {\n  if (tokens.peekKeyword(KwTypes)) {\n    const keyword = tokens.pop().text;\n\n    if (keyword !== type) {\n      throw new Error(`expected ${type}, got ${keyword}`);\n    }\n  }\n\n  return tokens.popType(\"ID\");\n} // ...all keywords matching allowed, returning the keywords\n\n\nfunction consumeKeywords(tokens, allowed) {\n  const keywords = new Set();\n\n  while (true) {\n    const keyword = tokens.peekType(\"KEYWORD\");\n\n    if (keyword == null || allowed && !allowed.has(keyword)) {\n      break;\n    }\n\n    tokens.pop();\n\n    if (keywords.has(keyword)) {\n      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n    }\n\n    keywords.add(keyword);\n  }\n\n  return Object.freeze(keywords);\n} // ...all visibility keywords, returning the coalesced mutability\n\n\nfunction consumeMutability(tokens) {\n  let modifiers = consumeKeywords(tokens, KwVisib); // Detect conflicting modifiers\n\n  allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n  allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \"))); // Process mutability states\n\n  if (modifiers.has(\"view\")) {\n    return \"view\";\n  }\n\n  if (modifiers.has(\"pure\")) {\n    return \"pure\";\n  }\n\n  if (modifiers.has(\"payable\")) {\n    return \"payable\";\n  }\n\n  if (modifiers.has(\"nonpayable\")) {\n    return \"nonpayable\";\n  } // Process legacy `constant` last\n\n\n  if (modifiers.has(\"constant\")) {\n    return \"view\";\n  }\n\n  return \"nonpayable\";\n} // ...a parameter list, returning the ParamType list\n\n\nfunction consumeParams(tokens, allowIndexed) {\n  return tokens.popParams().map(t => ParamType.from(t, allowIndexed));\n} // ...a gas limit, returning a BigNumber or null if none\n\n\nfunction consumeGas(tokens) {\n  if (tokens.peekType(\"AT\")) {\n    tokens.pop();\n\n    if (tokens.peekType(\"NUMBER\")) {\n      return getBigInt(tokens.pop().text);\n    }\n\n    throw new Error(\"invalid gas\");\n  }\n\n  return null;\n}\n\nfunction consumeEoi(tokens) {\n  if (tokens.length) {\n    throw new Error(`unexpected tokens: ${tokens.toString()}`);\n  }\n}\n\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nfunction verifyBasicType(type) {\n  const match = type.match(regexType);\n  assertArgument(match, \"invalid type\", \"type\", type);\n\n  if (type === \"uint\") {\n    return \"uint256\";\n  }\n\n  if (type === \"int\") {\n    return \"int256\";\n  }\n\n  if (match[2]) {\n    // bytesXX\n    const length = parseInt(match[2]);\n    assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n  } else if (match[3]) {\n    // intXX or uintXX\n    const size = parseInt(match[3]);\n    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, \"invalid numeric width\", \"type\", type);\n  }\n\n  return type;\n} // Make the Fragment constructors effectively private\n\n\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\r\n *  Each input and output of a [[Fragment]] is an Array of **PAramType**.\r\n */\n\nexport class ParamType {\n  /**\r\n   *  The local name of the parameter (or ``\"\"`` if unbound)\r\n   */\n  name;\n  /**\r\n   *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\r\n   *  ``\"uint256[3][]\"``)\r\n   */\n\n  type;\n  /**\r\n   *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\r\n   */\n\n  baseType;\n  /**\r\n   *  True if the parameters is indexed.\r\n   *\r\n   *  For non-indexable types (see [[ParamType_isIndexable]]) this\r\n   *  is ``null``.\r\n   */\n\n  indexed;\n  /**\r\n   *  The components for the tuple.\r\n   *\r\n   *  For non-tuple types (see [[ParamType_isTuple]]) this is ``null``.\r\n   */\n\n  components;\n  /**\r\n   *  The array length, or ``-1`` for dynamic-lengthed arrays.\r\n   *\r\n   *  For non-array types (see [[ParamType_isArray]]) this is ``null``.\r\n   */\n\n  arrayLength;\n  /**\r\n   *  The type of each child in the array.\r\n   *\r\n   *  For non-array types (see [[ParamType_isArray]]) this is ``null``.\r\n   */\n\n  arrayChildren;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n    assertPrivate(guard, _guard, \"ParamType\");\n    Object.defineProperty(this, internal, {\n      value: ParamTypeInternal\n    });\n\n    if (components) {\n      components = Object.freeze(components.slice());\n    }\n\n    if (baseType === \"array\") {\n      if (arrayLength == null || arrayChildren == null) {\n        throw new Error(\"\");\n      }\n    } else if (arrayLength != null || arrayChildren != null) {\n      throw new Error(\"\");\n    }\n\n    if (baseType === \"tuple\") {\n      if (components == null) {\n        throw new Error(\"\");\n      }\n    } else if (components != null) {\n      throw new Error(\"\");\n    }\n\n    defineProperties(this, {\n      name,\n      type,\n      baseType,\n      indexed,\n      components,\n      arrayLength,\n      arrayChildren\n    });\n  }\n  /**\r\n   *  Return a string representation of this type.\r\n   *\r\n   *  For example,\r\n   *\r\n   *  ``sighash\" => \"(uint256,address)\"``\r\n   *\r\n   *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\r\n   *\r\n   *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\r\n   */\n\n\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n\n    if (format === \"json\") {\n      let result = {\n        type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n        name: this.name || undefined\n      };\n\n      if (typeof this.indexed === \"boolean\") {\n        result.indexed = this.indexed;\n      }\n\n      if (this.isTuple()) {\n        result.components = this.components.map(c => JSON.parse(c.format(format)));\n      }\n\n      return JSON.stringify(result);\n    }\n\n    let result = \"\"; // Array\n\n    if (this.isArray()) {\n      result += this.arrayChildren.format(format);\n      result += `[${this.arrayLength < 0 ? \"\" : String(this.arrayLength)}]`;\n    } else {\n      if (this.isTuple()) {\n        if (format !== \"sighash\") {\n          result += this.type;\n        }\n\n        result += \"(\" + this.components.map(comp => comp.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n      } else {\n        result += this.type;\n      }\n    }\n\n    if (format !== \"sighash\") {\n      if (this.indexed === true) {\n        result += \" indexed\";\n      }\n\n      if (format === \"full\" && this.name) {\n        result += \" \" + this.name;\n      }\n    }\n\n    return result;\n  }\n  /*\r\n   *  Returns true if %%value%% is an Array type.\r\n   *\r\n   *  This provides a type gaurd ensuring that the\r\n   *  [[arrayChildren]] and [[arrayLength]] are non-null.\r\n   */\n  //static isArray(value: any): value is { arrayChildren: ParamType, arrayLength: number } {\n  //    return value && (value.baseType === \"array\")\n  //}\n\n  /**\r\n   *  Returns true if %%this%% is an Array type.\r\n   *\r\n   *  This provides a type gaurd ensuring that [[arrayChildren]]\r\n   *  and [[arrayLength]] are non-null.\r\n   */\n\n\n  isArray() {\n    return this.baseType === \"array\";\n  }\n  /**\r\n   *  Returns true if %%this%% is a Tuple type.\r\n   *\r\n   *  This provides a type gaurd ensuring that [[components]]\r\n   *  is non-null.\r\n   */\n\n\n  isTuple() {\n    return this.baseType === \"tuple\";\n  }\n  /**\r\n   *  Returns true if %%this%% is an Indexable type.\r\n   *\r\n   *  This provides a type gaurd ensuring that [[indexed]]\r\n   *  is non-null.\r\n   */\n\n\n  isIndexable() {\n    return this.indexed != null;\n  }\n  /**\r\n   *  Walks the **ParamType** with %%value%%, calling %%process%%\r\n   *  on each type, destructing the %%value%% recursively.\r\n   */\n\n\n  walk(value, process) {\n    if (this.isArray()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invlaid array value\");\n      }\n\n      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n        throw new Error(\"array is wrong length\");\n      }\n\n      const _this = this;\n\n      return value.map(v => _this.arrayChildren.walk(v, process));\n    }\n\n    if (this.isTuple()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invlaid tuple value\");\n      }\n\n      if (value.length !== this.components.length) {\n        throw new Error(\"array is wrong length\");\n      }\n\n      const _this = this;\n\n      return value.map((v, i) => _this.components[i].walk(v, process));\n    }\n\n    return process(this.type, value);\n  }\n\n  #walkAsync(promises, value, process, setValue) {\n    if (this.isArray()) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"invlaid array value\");\n      }\n\n      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n        throw new Error(\"array is wrong length\");\n      }\n\n      const childType = this.arrayChildren;\n      const result = value.slice();\n      result.forEach((value, index) => {\n        childType.#walkAsync(promises, value, process, value => {\n          result[index] = value;\n        });\n      });\n      setValue(result);\n      return;\n    }\n\n    if (this.isTuple()) {\n      const components = this.components; // Convert the object into an array\n\n      let result;\n\n      if (Array.isArray(value)) {\n        result = value.slice();\n      } else {\n        if (value == null || typeof value !== \"object\") {\n          throw new Error(\"invlaid tuple value\");\n        }\n\n        result = components.map(param => {\n          if (!param.name) {\n            throw new Error(\"cannot use object value with unnamed components\");\n          }\n\n          if (!(param.name in value)) {\n            throw new Error(`missing value for component ${param.name}`);\n          }\n\n          return value[param.name];\n        });\n      }\n\n      if (result.length !== this.components.length) {\n        throw new Error(\"array is wrong length\");\n      }\n\n      result.forEach((value, index) => {\n        components[index].#walkAsync(promises, value, process, value => {\n          result[index] = value;\n        });\n      });\n      setValue(result);\n      return;\n    }\n\n    const result = process(this.type, value);\n\n    if (result.then) {\n      promises.push(async function () {\n        setValue(await result);\n      }());\n    } else {\n      setValue(result);\n    }\n  }\n  /**\r\n   *  Walks the **ParamType** with %%value%%, asynchronously calling\r\n   *  %%process%% on each type, destructing the %%value%% recursively.\r\n   *\r\n   *  This can be used to resolve ENS naes by walking and resolving each\r\n   *  ``\"address\"`` type.\r\n   */\n\n\n  async walkAsync(value, process) {\n    const promises = [];\n    const result = [value];\n    this.#walkAsync(promises, value, process, value => {\n      result[0] = value;\n    });\n\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n\n    return result[0];\n  }\n  /**\r\n   *  Creates a new **ParamType** for %%obj%%.\r\n   *\r\n   *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\r\n   *  otherwise the ``indexed`` keyword will throw an error.\r\n   */\n\n\n  static from(obj, allowIndexed) {\n    if (ParamType.isParamType(obj)) {\n      return obj;\n    }\n\n    if (typeof obj === \"string\") {\n      return ParamType.from(lex(obj), allowIndexed);\n    } else if (obj instanceof TokenString) {\n      let type = \"\",\n          baseType = \"\";\n      let comps = null;\n\n      if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n        // Tuple\n        baseType = \"tuple\";\n        comps = obj.popParams().map(t => ParamType.from(t));\n        type = `tuple(${comps.map(c => c.format()).join(\",\")})`;\n      } else {\n        // Normal\n        type = verifyBasicType(obj.popType(\"TYPE\"));\n        baseType = type;\n      } // Check for Array\n\n\n      let arrayChildren = null;\n      let arrayLength = null;\n\n      while (obj.length && obj.peekType(\"BRACKET\")) {\n        const bracket = obj.pop(); //arrays[i];\n\n        arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n        arrayLength = bracket.value;\n        type += bracket.text;\n        baseType = \"array\";\n        comps = null;\n      }\n\n      let indexed = null;\n      const keywords = consumeKeywords(obj, KwModifiers);\n\n      if (keywords.has(\"indexed\")) {\n        if (!allowIndexed) {\n          throw new Error(\"\");\n        }\n\n        indexed = true;\n      }\n\n      const name = obj.peekType(\"ID\") ? obj.pop().text : \"\";\n\n      if (obj.length) {\n        throw new Error(\"leftover tokens\");\n      }\n\n      return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n    }\n\n    const name = obj.name;\n    assertArgument(!name || typeof name === \"string\" && name.match(regexId), \"invalid name\", \"obj.name\", name);\n    let indexed = obj.indexed;\n\n    if (indexed != null) {\n      assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n      indexed = !!indexed;\n    }\n\n    let type = obj.type;\n    let arrayMatch = type.match(regexArrayType);\n\n    if (arrayMatch) {\n      const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n      const arrayChildren = ParamType.from({\n        type: arrayMatch[1],\n        components: obj.components\n      });\n      return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n    }\n\n    if (type === \"tuple\" || type.substring(0, 5) === \"tuple(\" || type[0] === \"(\") {\n      const comps = obj.components != null ? obj.components.map(c => ParamType.from(c)) : null;\n      const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null); // @TODO: use lexer to validate and normalize type\n\n      return tuple;\n    }\n\n    type = verifyBasicType(obj.type);\n    return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n  }\n  /**\r\n   *  Returns true if %%value%% is a **ParamType**.\r\n   */\n\n\n  static isParamType(value) {\n    return value && value[internal] === ParamTypeInternal;\n  }\n\n}\n/**\r\n *  An abstract class to represent An individual fragment from a parse ABI.\r\n */\n\nexport class Fragment {\n  /**\r\n   *  The type of the fragment.\r\n   */\n  type;\n  /**\r\n   *  The inputs for the fragment.\r\n   */\n\n  inputs;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, type, inputs) {\n    assertPrivate(guard, _guard, \"Fragment\");\n    inputs = Object.freeze(inputs.slice());\n    defineProperties(this, {\n      type,\n      inputs\n    });\n  }\n  /**\r\n   *  Creates a new **Fragment** for %%obj%%, wich can be any supported\r\n   *  ABI frgament type.\r\n   */\n\n\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      // Try parsing JSON...\n      try {\n        Fragment.from(JSON.parse(obj));\n      } catch (e) {} // ...otherwise, use the human-readable lexer\n\n\n      return Fragment.from(lex(obj));\n    }\n\n    if (obj instanceof TokenString) {\n      // Human-readable ABI (already lexed)\n      const type = obj.peekKeyword(KwTypes);\n\n      switch (type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n\n        case \"error\":\n          return ErrorFragment.from(obj);\n\n        case \"event\":\n          return EventFragment.from(obj);\n\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n\n        case \"function\":\n          return FunctionFragment.from(obj);\n\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n    } else if (typeof obj === \"object\") {\n      // JSON ABI\n      switch (obj.type) {\n        case \"constructor\":\n          return ConstructorFragment.from(obj);\n\n        case \"error\":\n          return ErrorFragment.from(obj);\n\n        case \"event\":\n          return EventFragment.from(obj);\n\n        case \"fallback\":\n        case \"receive\":\n          return FallbackFragment.from(obj);\n\n        case \"function\":\n          return FunctionFragment.from(obj);\n\n        case \"struct\":\n          return StructFragment.from(obj);\n      }\n\n      assert(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n        operation: \"Fragment.from\"\n      });\n    }\n\n    assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n  }\n  /**\r\n   *  Returns true if %%value%% is a [[ConstructorFragment]].\r\n   */\n\n\n  static isConstructor(value) {\n    return ConstructorFragment.isFragment(value);\n  }\n  /**\r\n   *  Returns true if %%value%% is an [[ErrorFragment]].\r\n   */\n\n\n  static isError(value) {\n    return ErrorFragment.isFragment(value);\n  }\n  /**\r\n   *  Returns true if %%value%% is an [[EventFragment]].\r\n   */\n\n\n  static isEvent(value) {\n    return EventFragment.isFragment(value);\n  }\n  /**\r\n   *  Returns true if %%value%% is a [[FunctionFragment]].\r\n   */\n\n\n  static isFunction(value) {\n    return FunctionFragment.isFragment(value);\n  }\n  /**\r\n   *  Returns true if %%value%% is a [[StructFragment]].\r\n   */\n\n\n  static isStruct(value) {\n    return StructFragment.isFragment(value);\n  }\n\n}\n/**\r\n *  An abstract class to represent An individual fragment\r\n *  which has a name from a parse ABI.\r\n */\n\nexport class NamedFragment extends Fragment {\n  /**\r\n   *  The name of the fragment.\r\n   */\n  name;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, type, name, inputs) {\n    super(guard, type, inputs);\n    assertArgument(typeof name === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n    inputs = Object.freeze(inputs.slice());\n    defineProperties(this, {\n      name\n    });\n  }\n\n}\n\nfunction joinParams(format, params) {\n  return \"(\" + params.map(p => p.format(format)).join(format === \"full\" ? \", \" : \",\") + \")\";\n}\n/**\r\n *  A Fragment which represents a //Custom Error//.\r\n */\n\n\nexport class ErrorFragment extends NamedFragment {\n  /**\r\n   *  @private\r\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"error\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: ErrorFragmentInternal\n    });\n  }\n  /**\r\n   *  The Custom Error selector.\r\n   */\n\n\n  get selector() {\n    return id(this.format(\"sighash\")).substring(0, 10);\n  }\n\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"error\",\n        name: this.name,\n        inputs: this.inputs.map(input => JSON.parse(input.format(format)))\n      });\n    }\n\n    const result = [];\n\n    if (format !== \"sighash\") {\n      result.push(\"error\");\n    }\n\n    result.push(this.name + joinParams(format, this.inputs));\n    return result.join(\" \");\n  }\n\n  static from(obj) {\n    if (ErrorFragment.isFragment(obj)) {\n      return obj;\n    }\n\n    if (typeof obj === \"string\") {\n      return ErrorFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"error\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new ErrorFragment(_guard, name, inputs);\n    }\n\n    return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n\n  static isFragment(value) {\n    return value && value[internal] === ErrorFragmentInternal;\n  }\n\n}\n/**\r\n *  A Fragment which represents an Event.\r\n */\n\nexport class EventFragment extends NamedFragment {\n  anonymous;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, name, inputs, anonymous) {\n    super(guard, \"event\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: EventFragmentInternal\n    });\n    defineProperties(this, {\n      anonymous\n    });\n  }\n  /**\r\n   *  The Event topic hash.\r\n   */\n\n\n  get topicHash() {\n    return id(this.format(\"sighash\"));\n  }\n\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"event\",\n        anonymous: this.anonymous,\n        name: this.name,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n\n    const result = [];\n\n    if (format !== \"sighash\") {\n      result.push(\"event\");\n    }\n\n    result.push(this.name + joinParams(format, this.inputs));\n\n    if (format !== \"sighash\" && this.anonymous) {\n      result.push(\"anonymous\");\n    }\n\n    return result.join(\" \");\n  }\n\n  static getTopicHash(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new EventFragment(_guard, name, params, false);\n    return fragment.topicHash;\n  }\n\n  static from(obj) {\n    if (EventFragment.isFragment(obj)) {\n      return obj;\n    }\n\n    if (typeof obj === \"string\") {\n      return EventFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"event\", obj);\n      const inputs = consumeParams(obj, true);\n      const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n      consumeEoi(obj);\n      return new EventFragment(_guard, name, inputs, anonymous);\n    }\n\n    return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(p => ParamType.from(p, true)) : [], !!obj.anonymous);\n  }\n\n  static isFragment(value) {\n    return value && value[internal] === EventFragmentInternal;\n  }\n\n}\n/**\r\n *  A Fragment which represents a constructor.\r\n */\n\nexport class ConstructorFragment extends Fragment {\n  payable;\n  gas;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, type, inputs, payable, gas) {\n    super(guard, type, inputs);\n    Object.defineProperty(this, internal, {\n      value: ConstructorFragmentInternal\n    });\n    defineProperties(this, {\n      payable,\n      gas\n    });\n  }\n\n  format(format) {\n    assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"format(sighash)\"\n    });\n\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"constructor\",\n        stateMutability: this.payable ? \"payable\" : \"undefined\",\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format)))\n      });\n    }\n\n    const result = [`constructor${joinParams(format, this.inputs)}`];\n    result.push(this.payable ? \"payable\" : \"nonpayable\");\n\n    if (this.gas != null) {\n      result.push(`@${this.gas.toString()}`);\n    }\n\n    return result.join(\" \");\n  }\n\n  static from(obj) {\n    if (ConstructorFragment.isFragment(obj)) {\n      return obj;\n    }\n\n    if (typeof obj === \"string\") {\n      return ConstructorFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      consumeKeywords(obj, setify([\"constructor\"]));\n      const inputs = consumeParams(obj);\n      const payable = !!consumeKeywords(obj, setify([\"payable\"])).has(\"payable\");\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n    }\n\n    return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);\n  }\n\n  static isFragment(value) {\n    return value && value[internal] === ConstructorFragmentInternal;\n  }\n\n}\n/**\r\n *  A Fragment which represents a method.\r\n */\n\nexport class FallbackFragment extends Fragment {\n  /**\r\n   *  If the function can be sent value during invocation.\r\n   */\n  payable;\n\n  constructor(guard, inputs, payable) {\n    super(guard, \"fallback\", inputs);\n    Object.defineProperty(this, internal, {\n      value: FallbackFragmentInternal\n    });\n    defineProperties(this, {\n      payable\n    });\n  }\n\n  format(format) {\n    const type = this.inputs.length === 0 ? \"receive\" : \"fallback\";\n\n    if (format === \"json\") {\n      const stateMutability = this.payable ? \"payable\" : \"nonpayable\";\n      return JSON.stringify({\n        type,\n        stateMutability\n      });\n    }\n\n    return `${type}()${this.payable ? \" payable\" : \"\"}`;\n  }\n\n  static from(obj) {\n    if (FallbackFragment.isFragment(obj)) {\n      return obj;\n    }\n\n    if (typeof obj === \"string\") {\n      return FallbackFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const errorObj = obj.toString();\n      const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n      assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n      const type = obj.popKeyword(setify([\"fallback\", \"receive\"])); // receive()\n\n      if (type === \"receive\") {\n        const inputs = consumeParams(obj);\n        assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n        consumeKeywords(obj, setify([\"payable\"]));\n        consumeEoi(obj);\n        return new FallbackFragment(_guard, [], true);\n      } // fallback() [payable]\n      // fallback(bytes) [payable] returns (bytes)\n\n\n      let inputs = consumeParams(obj);\n\n      if (inputs.length) {\n        assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map(i => i.format(\"minimal\")).join(\", \"));\n      } else {\n        inputs = [ParamType.from(\"bytes\")];\n      }\n\n      const mutability = consumeMutability(obj);\n      assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        const outputs = consumeParams(obj);\n        assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map(i => i.format(\"minimal\")).join(\", \"));\n      }\n\n      consumeEoi(obj);\n      return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n    }\n\n    if (obj.type === \"receive\") {\n      return new FallbackFragment(_guard, [], true);\n    }\n\n    if (obj.type === \"fallback\") {\n      const inputs = [ParamType.from(\"bytes\")];\n      const payable = obj.stateMutability === \"payable\";\n      return new FallbackFragment(_guard, inputs, payable);\n    }\n\n    assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n  }\n\n  static isFragment(value) {\n    return value && value[internal] === FallbackFragmentInternal;\n  }\n\n}\n/**\r\n *  A Fragment which represents a method.\r\n */\n\nexport class FunctionFragment extends NamedFragment {\n  /**\r\n   *  If the function is constant (e.g. ``pure`` or ``view`` functions).\r\n   */\n  constant;\n  /**\r\n   *  The returned types for the result of calling this function.\r\n   */\n\n  outputs;\n  /**\r\n   *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\r\n   *  or ``pure``)\r\n   */\n\n  stateMutability;\n  /**\r\n   *  If the function can be sent value during invocation.\r\n   */\n\n  payable;\n  /**\r\n   *  The amount of gas to send when calling this function\r\n   */\n\n  gas;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, name, stateMutability, inputs, outputs, gas) {\n    super(guard, \"function\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: FunctionFragmentInternal\n    });\n    outputs = Object.freeze(outputs.slice());\n    const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n    const payable = stateMutability === \"payable\";\n    defineProperties(this, {\n      constant,\n      gas,\n      outputs,\n      payable,\n      stateMutability\n    });\n  }\n  /**\r\n   *  The Function selector.\r\n   */\n\n\n  get selector() {\n    return id(this.format(\"sighash\")).substring(0, 10);\n  }\n\n  format(format) {\n    if (format == null) {\n      format = \"sighash\";\n    }\n\n    if (format === \"json\") {\n      return JSON.stringify({\n        type: \"function\",\n        name: this.name,\n        constant: this.constant,\n        stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n        payable: this.payable,\n        gas: this.gas != null ? this.gas : undefined,\n        inputs: this.inputs.map(i => JSON.parse(i.format(format))),\n        outputs: this.outputs.map(o => JSON.parse(o.format(format)))\n      });\n    }\n\n    const result = [];\n\n    if (format !== \"sighash\") {\n      result.push(\"function\");\n    }\n\n    result.push(this.name + joinParams(format, this.inputs));\n\n    if (format !== \"sighash\") {\n      if (this.stateMutability !== \"nonpayable\") {\n        result.push(this.stateMutability);\n      }\n\n      if (this.outputs && this.outputs.length) {\n        result.push(\"returns\");\n        result.push(joinParams(format, this.outputs));\n      }\n\n      if (this.gas != null) {\n        result.push(`@${this.gas.toString()}`);\n      }\n    }\n\n    return result.join(\" \");\n  }\n\n  static getSelector(name, params) {\n    params = (params || []).map(p => ParamType.from(p));\n    const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n    return fragment.selector;\n  }\n\n  static from(obj) {\n    if (FunctionFragment.isFragment(obj)) {\n      return obj;\n    }\n\n    if (typeof obj === \"string\") {\n      return FunctionFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"function\", obj);\n      const inputs = consumeParams(obj);\n      const mutability = consumeMutability(obj);\n      let outputs = [];\n\n      if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n        outputs = consumeParams(obj);\n      }\n\n      const gas = consumeGas(obj);\n      consumeEoi(obj);\n      return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n    } // @TODO: verifyState for stateMutability\n\n\n    return new FunctionFragment(_guard, obj.name, obj.stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);\n  }\n\n  static isFragment(value) {\n    return value && value[internal] === FunctionFragmentInternal;\n  }\n\n}\n/**\r\n *  A Fragment which represents a structure.\r\n */\n\nexport class StructFragment extends NamedFragment {\n  /**\r\n   *  @private\r\n   */\n  constructor(guard, name, inputs) {\n    super(guard, \"struct\", name, inputs);\n    Object.defineProperty(this, internal, {\n      value: StructFragmentInternal\n    });\n  }\n\n  format() {\n    throw new Error(\"@TODO\");\n  }\n\n  static from(obj) {\n    if (typeof obj === \"string\") {\n      return StructFragment.from(lex(obj));\n    } else if (obj instanceof TokenString) {\n      const name = consumeName(\"struct\", obj);\n      const inputs = consumeParams(obj);\n      consumeEoi(obj);\n      return new StructFragment(_guard, name, inputs);\n    }\n\n    return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n  }\n\n  static isFragment(value) {\n    return value && value[internal] === StructFragmentInternal;\n  }\n\n}","map":{"version":3,"mappings":"AAAA;;;;;AAMA,SACIA,gBADJ,EACsBC,SADtB,EACiCC,SADjC,EAEIC,MAFJ,EAEYC,aAFZ,EAE2BC,cAF3B,QAGO,mBAHP;AAIA,SAASC,EAAT,QAAmB,kBAAnB;AAgFC,C,CAkBD;;AACA,SAASC,MAAT,CAAgBC,KAAhB,EAAoC;AAChC,QAAMC,MAAM,GAAgB,IAAIC,GAAJ,EAA5B;AACAF,OAAK,CAACG,OAAN,CAAeC,CAAD,IAAOH,MAAM,CAACI,GAAP,CAAWD,CAAX,CAArB;AACA,SAAOE,MAAM,CAACC,MAAP,CAAcN,MAAd,CAAP;AACH,C,CAED;;;AACA,MAAMO,QAAQ,GAAG,6DAAjB;AACA,MAAMC,OAAO,GAAGV,MAAM,CAACS,QAAQ,CAACE,KAAT,CAAe,GAAf,CAAD,CAAtB;AAEA,MAAMC,QAAQ,GAAG,0DAAjB;AACA,MAAMC,OAAO,GAAGb,MAAM,CAACY,QAAQ,CAACD,KAAT,CAAe,GAAf,CAAD,CAAtB;AAEA,MAAMG,YAAY,GAAG,yCAArB;AACA,MAAMC,WAAW,GAAGf,MAAM,CAACc,YAAY,CAACH,KAAb,CAAmB,GAAnB,CAAD,CAA1B;AAEA,MAAMK,QAAQ,GAAG,eAAjB,C,CAEA;;AACA,MAAMC,SAAS,GAAG,CAAEL,QAAF,EAAYE,YAAZ,EAA0BE,QAA1B,EAAoCP,QAApC,EAA+CS,IAA/C,CAAoD,GAApD,CAAlB;;AACA,MAAMC,QAAQ,GAAGnB,MAAM,CAACiB,SAAS,CAACN,KAAV,CAAgB,GAAhB,CAAD,CAAvB,C,CAEA;;AACA,MAAMS,YAAY,GAA2B;AAC3C,OAAK,YADsC;AACxB,OAAK,aADmB;AAE3C,OAAK,cAFsC;AAEtB,OAAK,eAFiB;AAG3C,OAAK,OAHsC;AAG7B,OAAK;AAHwB,CAA7C,C,CAMA;;AACA,MAAMC,qBAAqB,GAAG,IAAIC,MAAJ,CAAW,SAAX,CAA9B;AACA,MAAMC,iBAAiB,GAAG,IAAID,MAAJ,CAAW,WAAX,CAA1B;AACA,MAAME,aAAa,GAAG,IAAIF,MAAJ,CAAW,6BAAX,CAAtB,C,CAEA;;AACA,MAAMG,OAAO,GAAG,IAAIH,MAAJ,CAAW,8BAAX,CAAhB;AACA,MAAMI,SAAS,GAAG,IAAIJ,MAAJ,CAAW,qDAAX,CAAlB;;AA8BA,MAAMK,WAAN,CAAiB;AACb;AACA;;AAEU,MAANC,MAAM;AAAa,WAAO,KAAK,OAAZ;AAAsB;;AACnC,MAANC,MAAM;AAAa,WAAO,KAAK,OAAL,CAAaA,MAAb,GAAsB,KAAK,OAAlC;AAA4C;;AAEnEC,cAAYC,MAAZ,EAAwC;AACpC,SAAK,OAAL,GAAe,CAAf;AACA,SAAK,OAAL,GAAeA,MAAM,CAACC,KAAP,EAAf;AACH;;AAEDC,OAAK;AAAkB,WAAO,IAAIN,WAAJ,CAAgB,KAAK,OAArB,CAAP;AAAuC;;AAC9DO,OAAK;AAAW,SAAK,OAAL,GAAe,CAAf;AAAmB;;AAEnC,iBAAe,GAAiC;AAAA,QAAhCC,IAAgC,uEAAjB,CAAiB;AAAA,QAAdC,EAAc,uEAAD,CAAC;AAC5C,WAAO,IAAIT,WAAJ,CAAgB,KAAK,OAAL,CAAaK,KAAb,CAAmBG,IAAnB,EAAyBC,EAAzB,EAA6BC,GAA7B,CAAkCC,CAAD,IAAM;AAC1D,aAAO/B,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACgC,MAAP,CAAc,EAAd,EAAmBD,CAAnB,EAAsB;AACvCE,aAAK,EAAGF,CAAC,CAACE,KAAF,GAAUL,IADqB;AAEvCM,gBAAQ,EAAGH,CAAC,CAACG,QAAF,GAAaN,IAFe;AAGvCO,gBAAQ,EAAGJ,CAAC,CAACI,QAAF,GAAaP;AAHe,OAAtB,CAAd,CAAP;AAKA,aAAOG,CAAP;AACH,KAPsB,CAAhB,CAAP;AAQH,GAxBY,CA0Bb;;;AACAK,YAAU,CAACC,OAAD,EAA6B;AACnC,UAAMC,GAAG,GAAG,KAAKC,IAAL,EAAZ;;AACA,QAAID,GAAG,CAACE,IAAJ,KAAa,SAAb,IAA0B,CAACH,OAAO,CAACI,GAAR,CAAYH,GAAG,CAACI,IAAhB,CAA/B,EAAsD;AAAE,YAAM,IAAIC,KAAJ,CAAU,oBAAqBL,GAAG,CAACI,IAAK,EAAxC,CAAN;AAAoD;;AAC5G,WAAO,KAAKE,GAAL,GAAWF,IAAlB;AACH,GA/BY,CAiCb;;;AACAG,SAAO,CAACL,IAAD,EAAa;AAChB,QAAI,KAAKD,IAAL,GAAYC,IAAZ,KAAqBA,IAAzB,EAA+B;AAAE,YAAM,IAAIG,KAAJ,CAAU,YAAaH,IAAK,SAAUM,IAAI,CAACC,SAAL,CAAe,KAAKR,IAAL,EAAf,CAA4B,EAAlE,CAAN;AAA8E;;AAC/G,WAAO,KAAKK,GAAL,GAAWF,IAAlB;AACH,GArCY,CAuCb;;;AACAM,UAAQ;AACJ,UAAMV,GAAG,GAAG,KAAKC,IAAL,EAAZ;;AACA,QAAID,GAAG,CAACE,IAAJ,KAAa,YAAjB,EAA+B;AAAE,YAAM,IAAIG,KAAJ,CAAU,WAAV,CAAN;AAA+B;;AAChE,UAAMhD,MAAM,GAAG,KAAK,eAAL,CAAqB,KAAK,OAAL,GAAe,CAApC,EAAuC2C,GAAG,CAACL,KAAJ,GAAY,CAAnD,CAAf;AACA,SAAK,OAAL,GAAeK,GAAG,CAACL,KAAJ,GAAY,CAA3B;AACA,WAAOtC,MAAP;AACH,GA9CY,CAgDb;;;AACAsD,WAAS;AACL,UAAMX,GAAG,GAAG,KAAKC,IAAL,EAAZ;;AAEA,QAAID,GAAG,CAACE,IAAJ,KAAa,YAAjB,EAA+B;AAAE,YAAM,IAAIG,KAAJ,CAAU,WAAV,CAAN;AAA+B;;AAEhE,UAAMhD,MAAM,GAAuB,EAAnC;;AAEA,WAAM,KAAK,OAAL,GAAe2C,GAAG,CAACL,KAAJ,GAAY,CAAjC,EAAoC;AAChC,YAAMiB,IAAI,GAAG,KAAKX,IAAL,GAAYJ,QAAzB;AACAxC,YAAM,CAACwD,IAAP,CAAY,KAAK,eAAL,CAAqB,KAAK,OAAL,GAAe,CAApC,EAAuCD,IAAvC,CAAZ;AACA,WAAK,OAAL,GAAeA,IAAf;AACH;;AAED,SAAK,OAAL,GAAeZ,GAAG,CAACL,KAAJ,GAAY,CAA3B;AAEA,WAAOtC,MAAP;AACH,GAjEY,CAmEb;;;AACA4C,MAAI;AACA,QAAI,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAajB,MAAjC,EAAyC;AACrC,YAAM,IAAIqB,KAAJ,CAAU,eAAV,CAAN;AACH;;AACD,WAAO,KAAK,OAAL,CAAa,KAAK,OAAlB,CAAP;AACH,GAzEY,CA2Eb;;;AACAS,aAAW,CAACf,OAAD,EAA6B;AACpC,UAAMC,GAAG,GAAG,KAAKe,QAAL,CAAc,SAAd,CAAZ;AACA,WAAQf,GAAG,IAAI,IAAP,IAAeD,OAAO,CAACI,GAAR,CAAYH,GAAZ,CAAhB,GAAoCA,GAApC,GAAyC,IAAhD;AACH,GA/EY,CAiFb;;;AACAe,UAAQ,CAACb,IAAD,EAAa;AACjB,QAAI,KAAKlB,MAAL,KAAgB,CAApB,EAAuB;AAAE,aAAO,IAAP;AAAc;;AACvC,UAAMgB,GAAG,GAAG,KAAKC,IAAL,EAAZ;AACA,WAAQD,GAAG,CAACE,IAAJ,KAAaA,IAAd,GAAsBF,GAAG,CAACI,IAA1B,GAAgC,IAAvC;AACH,GAtFY,CAwFb;;;AACAE,KAAG;AACC,UAAMjD,MAAM,GAAG,KAAK4C,IAAL,EAAf;AACA,SAAK,OAAL;AACA,WAAO5C,MAAP;AACH;;AAED2D,UAAQ;AACJ,UAAM9B,MAAM,GAAkB,EAA9B;;AACA,SAAK,IAAI+B,CAAC,GAAG,KAAK,OAAlB,EAA2BA,CAAC,GAAG,KAAK,OAAL,CAAajC,MAA5C,EAAoDiC,CAAC,EAArD,EAAyD;AACrD,YAAMC,KAAK,GAAG,KAAK,OAAL,CAAaD,CAAb,CAAd;AACA/B,YAAM,CAAC2B,IAAP,CAAY,GAAIK,KAAK,CAAChB,IAAK,IAAKgB,KAAK,CAACd,IAAK,EAA3C;AACH;;AACD,WAAO,gBAAiBlB,MAAM,CAACb,IAAP,CAAY,GAAZ,CAAiB,GAAzC;AACH;;AAtGY;;AA2GjB,SAAS8C,GAAT,CAAaf,IAAb,EAAyB;AACrB,QAAMlB,MAAM,GAAiB,EAA7B;;AAEA,QAAMkC,UAAU,GAAIC,OAAD,IAAoB;AACnC,UAAMH,KAAK,GAAInC,MAAM,GAAGqB,IAAI,CAACpB,MAAf,GAAyBwB,IAAI,CAACC,SAAL,CAAeL,IAAI,CAACrB,MAAD,CAAnB,CAAzB,GAAuD,MAArE;AACA,UAAM,IAAIsB,KAAJ,CAAU,iBAAkBa,KAAM,OAAQnC,MAAO,KAAMsC,OAAQ,EAA/D,CAAN;AACH,GAHD;;AAKA,MAAIC,QAAQ,GAAkB,EAA9B;AACA,MAAIC,MAAM,GAAkB,EAA5B;AAEA,MAAIxC,MAAM,GAAG,CAAb;;AACA,SAAOA,MAAM,GAAGqB,IAAI,CAACpB,MAArB,EAA6B;AAEzB;AACA,QAAIwC,GAAG,GAAGpB,IAAI,CAACqB,SAAL,CAAe1C,MAAf,CAAV;AACA,QAAIY,KAAK,GAAG6B,GAAG,CAAC7B,KAAJ,CAAUnB,qBAAV,CAAZ;;AACA,QAAImB,KAAJ,EAAW;AACPZ,YAAM,IAAIY,KAAK,CAAC,CAAD,CAAL,CAASX,MAAnB;AACAwC,SAAG,GAAGpB,IAAI,CAACqB,SAAL,CAAe1C,MAAf,CAAN;AACH;;AAED,UAAMmC,KAAK,GAAG;AAAEQ,WAAK,EAAEJ,QAAQ,CAACtC,MAAlB;AAA0BY,cAAQ,EAAE,CAAC,CAArC;AAAwCC,cAAQ,EAAE,CAAC,CAAnD;AAAsDF,WAAK,EAAE,CAAC,CAA9D;AAAiEO,UAAI,EAAE,EAAvE;AAA2EE,UAAI,EAAE,EAAjF;AAAqFrB,YAArF;AAA6F4C,WAAK,EAAE,CAAC;AAArG,KAAd;AACAzC,UAAM,CAAC2B,IAAP,CAAYK,KAAZ;AAEA,QAAIhB,IAAI,GAAI3B,YAAY,CAACiD,GAAG,CAAC,CAAD,CAAJ,CAAZ,IAAwB,EAApC;;AACA,QAAItB,IAAJ,EAAU;AACNgB,WAAK,CAAChB,IAAN,GAAaA,IAAb;AACAgB,WAAK,CAACd,IAAN,GAAaoB,GAAG,CAAC,CAAD,CAAhB;AACAzC,YAAM;;AAEN,UAAImB,IAAI,KAAK,YAAb,EAA2B;AACvBoB,gBAAQ,CAACT,IAAT,CAAc3B,MAAM,CAACF,MAAP,GAAgB,CAA9B;AACAuC,cAAM,CAACV,IAAP,CAAY3B,MAAM,CAACF,MAAP,GAAgB,CAA5B;AAEH,OAJD,MAIO,IAAIkB,IAAI,IAAI,aAAZ,EAA2B;AAC9B,YAAIoB,QAAQ,CAACtC,MAAT,KAAoB,CAAxB,EAA2B;AAAEoC,oBAAU,CAAC,0BAAD,CAAV;AAAyC;;AAEtEF,aAAK,CAACvB,KAAN,GAAc2B,QAAQ,CAAChB,GAAT,EAAd;AACoBpB,cAAM,CAACgC,KAAK,CAACvB,KAAP,CAAP,CAAuBA,KAAvB,GAA+BT,MAAM,CAACF,MAAP,GAAgB,CAA/C;AACnBkC,aAAK,CAACQ,KAAN;AAEAR,aAAK,CAACtB,QAAN,GAAiB2B,MAAM,CAACjB,GAAP,EAAjB;AACoBpB,cAAM,CAACgC,KAAK,CAACtB,QAAP,CAAP,CAA0BC,QAA1B,GAAqCX,MAAM,CAACF,MAAP,GAAgB,CAArD;AAEtB,OAVM,MAUA,IAAIkB,IAAI,KAAK,OAAb,EAAsB;AACzBgB,aAAK,CAACtB,QAAN,GAAiB2B,MAAM,CAACjB,GAAP,EAAjB;AACoBpB,cAAM,CAACgC,KAAK,CAACtB,QAAP,CAAP,CAA0BC,QAA1B,GAAqCX,MAAM,CAACF,MAAP,GAAgB,CAArD;AACnBuC,cAAM,CAACV,IAAP,CAAY3B,MAAM,CAACF,MAAP,GAAgB,CAA5B;AAEH,OALM,MAKA,IAAIkB,IAAI,KAAK,cAAb,EAA6B;AAChCgB,aAAK,CAAChB,IAAN,GAAa,SAAb;AAEH,OAHM,MAGA,IAAIA,IAAI,KAAK,eAAb,EAA8B;AACjC;AACA,YAAI0B,MAAM,GAAI1C,MAAM,CAACoB,GAAP,GAAuBF,IAArC;;AACA,YAAIlB,MAAM,CAACF,MAAP,GAAgB,CAAhB,IAAqBE,MAAM,CAACA,MAAM,CAACF,MAAP,GAAgB,CAAjB,CAAN,CAA0BkB,IAA1B,KAAmC,QAA5D,EAAsE;AAClE,gBAAMyB,KAAK,GAAIzC,MAAM,CAACoB,GAAP,GAAuBF,IAAtC;AACAwB,gBAAM,GAAGD,KAAK,GAAGC,MAAjB;AACoB1C,gBAAM,CAACA,MAAM,CAACF,MAAP,GAAgB,CAAjB,CAAP,CAA6B2C,KAA7B,GAAqC7E,SAAS,CAAC6E,KAAD,CAA9C;AACtB;;AACD,YAAIzC,MAAM,CAACF,MAAP,KAAkB,CAAlB,IAAuBE,MAAM,CAACA,MAAM,CAACF,MAAP,GAAgB,CAAjB,CAAN,CAA0BkB,IAA1B,KAAmC,SAA9D,EAAyE;AACrE,gBAAM,IAAIG,KAAJ,CAAU,yBAAV,CAAN;AACH;;AACmBnB,cAAM,CAACA,MAAM,CAACF,MAAP,GAAgB,CAAjB,CAAP,CAA6BoB,IAA7B,IAAqCwB,MAArC;AACtB;;AAED;AACH;;AAEDjC,SAAK,GAAG6B,GAAG,CAAC7B,KAAJ,CAAUhB,aAAV,CAAR;;AACA,QAAIgB,KAAJ,EAAW;AACPuB,WAAK,CAACd,IAAN,GAAaT,KAAK,CAAC,CAAD,CAAlB;AACAZ,YAAM,IAAImC,KAAK,CAACd,IAAN,CAAWpB,MAArB;;AAEA,UAAIV,QAAQ,CAAC6B,GAAT,CAAae,KAAK,CAACd,IAAnB,CAAJ,EAA8B;AAC1Bc,aAAK,CAAChB,IAAN,GAAa,SAAb;AACA;AACH;;AAED,UAAIgB,KAAK,CAACd,IAAN,CAAWT,KAAX,CAAiBd,SAAjB,CAAJ,EAAiC;AAC7BqC,aAAK,CAAChB,IAAN,GAAa,MAAb;AACA;AACH;;AAEDgB,WAAK,CAAChB,IAAN,GAAa,IAAb;AACA;AACH;;AAEDP,SAAK,GAAG6B,GAAG,CAAC7B,KAAJ,CAAUjB,iBAAV,CAAR;;AACA,QAAIiB,KAAJ,EAAW;AACPuB,WAAK,CAACd,IAAN,GAAaT,KAAK,CAAC,CAAD,CAAlB;AACAuB,WAAK,CAAChB,IAAN,GAAa,QAAb;AACAnB,YAAM,IAAImC,KAAK,CAACd,IAAN,CAAWpB,MAArB;AACA;AACH;;AAED,UAAM,IAAIqB,KAAJ,CAAU,oBAAqBG,IAAI,CAACC,SAAL,CAAee,GAAG,CAAC,CAAD,CAAlB,CAAuB,gBAAiBzC,MAAO,EAA9E,CAAN;AACH;;AAED,SAAO,IAAID,WAAJ,CAAgBI,MAAM,CAACM,GAAP,CAAYC,CAAD,IAAO/B,MAAM,CAACC,MAAP,CAAc8B,CAAd,CAAlB,CAAhB,CAAP;AACH,C,CAED;;;AACA,SAASoC,WAAT,CAAqBC,GAArB,EAA+C/B,OAA/C,EAA2E;AACvE,MAAIgC,QAAQ,GAAkB,EAA9B;;AACA,OAAK,MAAMC,GAAX,IAAkBjC,OAAO,CAACkC,IAAR,EAAlB,EAAkC;AAC9B,QAAIH,GAAG,CAAC3B,GAAJ,CAAQ6B,GAAR,CAAJ,EAAkB;AAAED,cAAQ,CAAClB,IAAT,CAAcmB,GAAd;AAAqB;AAC5C;;AACD,MAAID,QAAQ,CAAC/C,MAAT,GAAkB,CAAtB,EAAyB;AAAE,UAAM,IAAIqB,KAAJ,CAAU,sBAAuB0B,QAAQ,CAAC1D,IAAT,CAAc,IAAd,CAAoB,EAArD,CAAN;AAAiE;AAC/F,C,CAED;AAEA;;;AACA,SAAS6D,WAAT,CAAqBhC,IAArB,EAAmChB,MAAnC,EAAsD;AAClD,MAAIA,MAAM,CAAC4B,WAAP,CAAmB9C,OAAnB,CAAJ,EAAiC;AAC7B,UAAMmE,OAAO,GAAGjD,MAAM,CAACoB,GAAP,GAAaF,IAA7B;;AACA,QAAI+B,OAAO,KAAKjC,IAAhB,EAAsB;AAClB,YAAM,IAAIG,KAAJ,CAAU,YAAaH,IAAK,SAAUiC,OAAQ,EAA9C,CAAN;AACH;AACJ;;AAED,SAAOjD,MAAM,CAACqB,OAAP,CAAe,IAAf,CAAP;AACH,C,CAED;;;AACA,SAAS6B,eAAT,CAAyBlD,MAAzB,EAA8Ca,OAA9C,EAA2E;AACvE,QAAMsC,QAAQ,GAAgB,IAAI/E,GAAJ,EAA9B;;AACA,SAAO,IAAP,EAAa;AACT,UAAM6E,OAAO,GAAGjD,MAAM,CAAC6B,QAAP,CAAgB,SAAhB,CAAhB;;AAEA,QAAIoB,OAAO,IAAI,IAAX,IAAoBpC,OAAO,IAAI,CAACA,OAAO,CAACI,GAAR,CAAYgC,OAAZ,CAApC,EAA2D;AAAE;AAAQ;;AACrEjD,UAAM,CAACoB,GAAP;;AAEA,QAAI+B,QAAQ,CAAClC,GAAT,CAAagC,OAAb,CAAJ,EAA2B;AAAE,YAAM,IAAI9B,KAAJ,CAAU,uBAAwBG,IAAI,CAACC,SAAL,CAAe0B,OAAf,CAAwB,EAA1D,CAAN;AAAsE;;AACnGE,YAAQ,CAAC5E,GAAT,CAAa0E,OAAb;AACH;;AAED,SAAOzE,MAAM,CAACC,MAAP,CAAc0E,QAAd,CAAP;AACH,C,CAED;;;AACA,SAASC,iBAAT,CAA2BpD,MAA3B,EAA8C;AAC1C,MAAIqD,SAAS,GAAGH,eAAe,CAAClD,MAAD,EAASrB,OAAT,CAA/B,CAD0C,CAG1C;;AACAgE,aAAW,CAACU,SAAD,EAAYpF,MAAM,CAAC,8BAA8BW,KAA9B,CAAoC,GAApC,CAAD,CAAlB,CAAX;AACA+D,aAAW,CAACU,SAAD,EAAYpF,MAAM,CAAC,+BAA+BW,KAA/B,CAAqC,GAArC,CAAD,CAAlB,CAAX,CAL0C,CAO1C;;AACA,MAAIyE,SAAS,CAACpC,GAAV,CAAc,MAAd,CAAJ,EAA2B;AAAE,WAAO,MAAP;AAAgB;;AAC7C,MAAIoC,SAAS,CAACpC,GAAV,CAAc,MAAd,CAAJ,EAA2B;AAAE,WAAO,MAAP;AAAgB;;AAC7C,MAAIoC,SAAS,CAACpC,GAAV,CAAc,SAAd,CAAJ,EAA8B;AAAE,WAAO,SAAP;AAAmB;;AACnD,MAAIoC,SAAS,CAACpC,GAAV,CAAc,YAAd,CAAJ,EAAiC;AAAE,WAAO,YAAP;AAAsB,GAXf,CAa1C;;;AACA,MAAIoC,SAAS,CAACpC,GAAV,CAAc,UAAd,CAAJ,EAA+B;AAAE,WAAO,MAAP;AAAgB;;AAEjD,SAAO,YAAP;AACH,C,CAED;;;AACA,SAASqC,aAAT,CAAuBtD,MAAvB,EAA4CuD,YAA5C,EAAkE;AAC9D,SAAOvD,MAAM,CAACyB,SAAP,GAAmBnB,GAAnB,CAAwBC,CAAD,IAAOiD,SAAS,CAACpD,IAAV,CAAeG,CAAf,EAAkBgD,YAAlB,CAA9B,CAAP;AACH,C,CAED;;;AACA,SAASE,UAAT,CAAoBzD,MAApB,EAAuC;AACnC,MAAIA,MAAM,CAAC6B,QAAP,CAAgB,IAAhB,CAAJ,EAA2B;AACvB7B,UAAM,CAACoB,GAAP;;AACA,QAAIpB,MAAM,CAAC6B,QAAP,CAAgB,QAAhB,CAAJ,EAA+B;AAC3B,aAAOlE,SAAS,CAACqC,MAAM,CAACoB,GAAP,GAAaF,IAAd,CAAhB;AACH;;AACD,UAAM,IAAIC,KAAJ,CAAU,aAAV,CAAN;AACH;;AACD,SAAO,IAAP;AACH;;AAED,SAASuC,UAAT,CAAoB1D,MAApB,EAAuC;AACnC,MAAIA,MAAM,CAACF,MAAX,EAAmB;AACf,UAAM,IAAIqB,KAAJ,CAAU,sBAAuBnB,MAAM,CAAC8B,QAAP,EAAkB,EAAnD,CAAN;AACH;AACJ;;AAED,MAAM6B,cAAc,GAAG,IAAIpE,MAAJ,CAAW,oBAAX,CAAvB;;AAEA,SAASqE,eAAT,CAAyB5C,IAAzB,EAAqC;AACjC,QAAMP,KAAK,GAAGO,IAAI,CAACP,KAAL,CAAWd,SAAX,CAAd;AACA5B,gBAAc,CAAC0C,KAAD,EAAQ,cAAR,EAAwB,MAAxB,EAAgCO,IAAhC,CAAd;;AACA,MAAIA,IAAI,KAAK,MAAb,EAAqB;AAAE,WAAO,SAAP;AAAmB;;AAC1C,MAAIA,IAAI,KAAK,KAAb,EAAoB;AAAE,WAAO,QAAP;AAAkB;;AAExC,MAAIP,KAAK,CAAC,CAAD,CAAT,EAAc;AACV;AACA,UAAMX,MAAM,GAAG+D,QAAQ,CAACpD,KAAK,CAAC,CAAD,CAAN,CAAvB;AACA1C,kBAAc,CAAC+B,MAAM,KAAK,CAAX,IAAgBA,MAAM,IAAI,EAA3B,EAA+B,sBAA/B,EAAuD,MAAvD,EAA+DkB,IAA/D,CAAd;AAEH,GALD,MAKO,IAAIP,KAAK,CAAC,CAAD,CAAT,EAAc;AACjB;AACA,UAAMqD,IAAI,GAAGD,QAAQ,CAACpD,KAAK,CAAC,CAAD,CAAN,CAArB;AACA1C,kBAAc,CAAC+F,IAAI,KAAK,CAAT,IAAcA,IAAI,IAAI,GAAtB,IAA8BA,IAAI,GAAG,CAAR,KAAe,CAA7C,EAAgD,uBAAhD,EAAyE,MAAzE,EAAiF9C,IAAjF,CAAd;AACH;;AAED,SAAOA,IAAP;AACH,C,CAED;;;AACA,MAAM+C,MAAM,GAAG,EAAf;AAeA,MAAMC,QAAQ,GAAGC,MAAM,CAACC,GAAP,CAAW,kBAAX,CAAjB;AAEA,MAAMC,iBAAiB,GAAG,oBAA1B;AACA,MAAMC,qBAAqB,GAAG,gBAA9B;AACA,MAAMC,qBAAqB,GAAG,gBAA9B;AACA,MAAMC,2BAA2B,GAAG,sBAApC;AACA,MAAMC,wBAAwB,GAAG,mBAAjC;AACA,MAAMC,wBAAwB,GAAG,mBAAjC;AACA,MAAMC,sBAAsB,GAAG,iBAA/B;AAEA;;;;AAGA,OAAM,MAAOjB,SAAP,CAAgB;AAElB;;;AAGSkB,MAAI;AAEb;;;;;AAIS1D,MAAI;AAEb;;;;AAGS2D,UAAQ;AAEjB;;;;;;;AAMSC,SAAO;AAEhB;;;;;;AAKSC,YAAU;AAEnB;;;;;;AAKSC,aAAW;AAEpB;;;;;;AAKSC,eAAa;AAGtB;;;;AAGAhF,cAAYiF,KAAZ,EAAwBN,IAAxB,EAAsC1D,IAAtC,EAAoD2D,QAApD,EAAsEC,OAAtE,EAA+FC,UAA/F,EAA4IC,WAA5I,EAAwKC,aAAxK,EAAuM;AACnMjH,iBAAa,CAACkH,KAAD,EAAQjB,MAAR,EAAgB,WAAhB,CAAb;AACAvF,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAE0B;AAAT,KAAtC;;AAEA,QAAIU,UAAJ,EAAgB;AAAEA,gBAAU,GAAGrG,MAAM,CAACC,MAAP,CAAcoG,UAAU,CAAC5E,KAAX,EAAd,CAAb;AAAiD;;AAEnE,QAAI0E,QAAQ,KAAK,OAAjB,EAA0B;AACtB,UAAIG,WAAW,IAAI,IAAf,IAAuBC,aAAa,IAAI,IAA5C,EAAkD;AAC9C,cAAM,IAAI5D,KAAJ,CAAU,EAAV,CAAN;AACH;AACJ,KAJD,MAIO,IAAI2D,WAAW,IAAI,IAAf,IAAuBC,aAAa,IAAI,IAA5C,EAAkD;AACrD,YAAM,IAAI5D,KAAJ,CAAU,EAAV,CAAN;AACH;;AAED,QAAIwD,QAAQ,KAAK,OAAjB,EAA0B;AACtB,UAAIE,UAAU,IAAI,IAAlB,EAAwB;AAAE,cAAM,IAAI1D,KAAJ,CAAU,EAAV,CAAN;AAAsB;AACnD,KAFD,MAEO,IAAI0D,UAAU,IAAI,IAAlB,EAAwB;AAC3B,YAAM,IAAI1D,KAAJ,CAAU,EAAV,CAAN;AACH;;AAEDzD,oBAAgB,CAAY,IAAZ,EAAkB;AAC9BgH,UAD8B;AACxB1D,UADwB;AAClB2D,cADkB;AACRC,aADQ;AACCC,gBADD;AACaC,iBADb;AAC0BC;AAD1B,KAAlB,CAAhB;AAGH;AAED;;;;;;;;;;;;;AAWAG,QAAM,CAACA,MAAD,EAAoB;AACtB,QAAIA,MAAM,IAAI,IAAd,EAAoB;AAAEA,YAAM,GAAG,SAAT;AAAqB;;AAC3C,QAAIA,MAAM,KAAK,MAAf,EAAuB;AACnB,UAAI/G,MAAM,GAAQ;AACd6C,YAAI,EAAI,KAAK2D,QAAL,KAAkB,OAAnB,GAA8B,OAA9B,GAAuC,KAAK3D,IADrC;AAEd0D,YAAI,EAAG,KAAKA,IAAL,IAAaS;AAFN,OAAlB;;AAIA,UAAI,OAAO,KAAKP,OAAZ,KAAyB,SAA7B,EAAwC;AAAEzG,cAAM,CAACyG,OAAP,GAAiB,KAAKA,OAAtB;AAAgC;;AAC1E,UAAI,KAAKQ,OAAL,EAAJ,EAAoB;AAChBjH,cAAM,CAAC0G,UAAP,GAAoB,KAAKA,UAAL,CAAgBvE,GAAhB,CAAqB+E,CAAD,IAAO/D,IAAI,CAACgE,KAAL,CAAWD,CAAC,CAACH,MAAF,CAASA,MAAT,CAAX,CAA3B,CAApB;AACH;;AACD,aAAO5D,IAAI,CAACC,SAAL,CAAepD,MAAf,CAAP;AACH;;AAED,QAAIA,MAAM,GAAG,EAAb,CAdsB,CAgBtB;;AACA,QAAI,KAAKoH,OAAL,EAAJ,EAAoB;AAChBpH,YAAM,IAAI,KAAK4G,aAAL,CAAmBG,MAAnB,CAA0BA,MAA1B,CAAV;AACA/G,YAAM,IAAI,IAAM,KAAK2G,WAAL,GAAmB,CAAnB,GAAuB,EAAvB,GAA2BU,MAAM,CAAC,KAAKV,WAAN,CAAoB,GAArE;AACH,KAHD,MAGO;AACH,UAAI,KAAKM,OAAL,EAAJ,EAAoB;AAChB,YAAIF,MAAM,KAAK,SAAf,EAA0B;AAAE/G,gBAAM,IAAI,KAAK6C,IAAf;AAAsB;;AAClD7C,cAAM,IAAI,MAAM,KAAK0G,UAAL,CAAgBvE,GAAhB,CACXmF,IAAD,IAAUA,IAAI,CAACP,MAAL,CAAYA,MAAZ,CADE,EAEd/F,IAFc,CAER+F,MAAM,KAAK,MAAZ,GAAsB,IAAtB,GAA4B,GAFnB,CAAN,GAEgC,GAF1C;AAGH,OALD,MAKO;AACH/G,cAAM,IAAI,KAAK6C,IAAf;AACH;AACJ;;AAED,QAAIkE,MAAM,KAAK,SAAf,EAA0B;AACtB,UAAI,KAAKN,OAAL,KAAiB,IAArB,EAA2B;AAAEzG,cAAM,IAAI,UAAV;AAAuB;;AACpD,UAAI+G,MAAM,KAAK,MAAX,IAAqB,KAAKR,IAA9B,EAAoC;AAChCvG,cAAM,IAAI,MAAM,KAAKuG,IAArB;AACH;AACJ;;AAED,WAAOvG,MAAP;AACH;AAED;;;;;;AAMA;AACA;AACA;;AAEA;;;;;;;;AAMAoH,SAAO;AACH,WAAQ,KAAKZ,QAAL,KAAkB,OAA1B;AACH;AAED;;;;;;;;AAMAS,SAAO;AACH,WAAQ,KAAKT,QAAL,KAAkB,OAA1B;AACH;AAED;;;;;;;;AAMAe,aAAW;AACP,WAAQ,KAAKd,OAAL,IAAgB,IAAxB;AACH;AAED;;;;;;AAIAe,MAAI,CAAClD,KAAD,EAAamD,OAAb,EAAuC;AACvC,QAAI,KAAKL,OAAL,EAAJ,EAAoB;AAChB,UAAI,CAACM,KAAK,CAACN,OAAN,CAAc9C,KAAd,CAAL,EAA2B;AAAE,cAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;AAAyC;;AACtE,UAAI,KAAK2D,WAAL,KAAqB,CAAC,CAAtB,IAA2BrC,KAAK,CAAC3C,MAAN,KAAiB,KAAKgF,WAArD,EAAkE;AAC9D,cAAM,IAAI3D,KAAJ,CAAU,uBAAV,CAAN;AACH;;AACD,YAAM2E,KAAK,GAAG,IAAd;;AACA,aAAOrD,KAAK,CAACnC,GAAN,CAAWyF,CAAD,IAAQD,KAAK,CAACf,aAAN,CAAoBY,IAApB,CAAyBI,CAAzB,EAA4BH,OAA5B,CAAlB,CAAP;AACH;;AAED,QAAI,KAAKR,OAAL,EAAJ,EAAoB;AAChB,UAAI,CAACS,KAAK,CAACN,OAAN,CAAc9C,KAAd,CAAL,EAA2B;AAAE,cAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;AAAyC;;AACtE,UAAIsB,KAAK,CAAC3C,MAAN,KAAiB,KAAK+E,UAAL,CAAgB/E,MAArC,EAA6C;AACzC,cAAM,IAAIqB,KAAJ,CAAU,uBAAV,CAAN;AACH;;AACD,YAAM2E,KAAK,GAAG,IAAd;;AACA,aAAOrD,KAAK,CAACnC,GAAN,CAAU,CAACyF,CAAD,EAAIhE,CAAJ,KAAW+D,KAAK,CAACjB,UAAN,CAAiB9C,CAAjB,EAAoB4D,IAApB,CAAyBI,CAAzB,EAA4BH,OAA5B,CAArB,CAAP;AACH;;AAED,WAAOA,OAAO,CAAC,KAAK5E,IAAN,EAAYyB,KAAZ,CAAd;AACH;;AAED,YAAU,CAACuD,QAAD,EAAiCvD,KAAjC,EAA6CmD,OAA7C,EAA8EK,QAA9E,EAA4G;AAElH,QAAI,KAAKV,OAAL,EAAJ,EAAoB;AAChB,UAAI,CAACM,KAAK,CAACN,OAAN,CAAc9C,KAAd,CAAL,EAA2B;AAAE,cAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;AAAyC;;AACtE,UAAI,KAAK2D,WAAL,KAAqB,CAAC,CAAtB,IAA2BrC,KAAK,CAAC3C,MAAN,KAAiB,KAAKgF,WAArD,EAAkE;AAC9D,cAAM,IAAI3D,KAAJ,CAAU,uBAAV,CAAN;AACH;;AACD,YAAM+E,SAAS,GAAG,KAAKnB,aAAvB;AAEA,YAAM5G,MAAM,GAAGsE,KAAK,CAACxC,KAAN,EAAf;AACA9B,YAAM,CAACE,OAAP,CAAe,CAACoE,KAAD,EAAQ0D,KAAR,KAAiB;AAC5BD,iBAAS,CAAC,UAAV,CAAqBF,QAArB,EAA+BvD,KAA/B,EAAsCmD,OAAtC,EAAgDnD,KAAD,IAAe;AAC1DtE,gBAAM,CAACgI,KAAD,CAAN,GAAgB1D,KAAhB;AACH,SAFD;AAGH,OAJD;AAKAwD,cAAQ,CAAC9H,MAAD,CAAR;AACA;AACH;;AAED,QAAI,KAAKiH,OAAL,EAAJ,EAAoB;AAChB,YAAMP,UAAU,GAAG,KAAKA,UAAxB,CADgB,CAGhB;;AACA,UAAI1G,MAAJ;;AACA,UAAI0H,KAAK,CAACN,OAAN,CAAc9C,KAAd,CAAJ,EAA0B;AACtBtE,cAAM,GAAGsE,KAAK,CAACxC,KAAN,EAAT;AAEH,OAHD,MAGO;AACH,YAAIwC,KAAK,IAAI,IAAT,IAAiB,OAAOA,KAAP,KAAkB,QAAvC,EAAiD;AAC7C,gBAAM,IAAItB,KAAJ,CAAU,qBAAV,CAAN;AACH;;AAEDhD,cAAM,GAAG0G,UAAU,CAACvE,GAAX,CAAgB8F,KAAD,IAAU;AAC9B,cAAI,CAACA,KAAK,CAAC1B,IAAX,EAAiB;AAAE,kBAAM,IAAIvD,KAAJ,CAAU,iDAAV,CAAN;AAAqE;;AACxF,cAAI,EAAEiF,KAAK,CAAC1B,IAAN,IAAcjC,KAAhB,CAAJ,EAA4B;AACxB,kBAAM,IAAItB,KAAJ,CAAU,+BAAgCiF,KAAK,CAAC1B,IAAK,EAArD,CAAN;AACH;;AACD,iBAAOjC,KAAK,CAAC2D,KAAK,CAAC1B,IAAP,CAAZ;AACH,SANQ,CAAT;AAOH;;AAED,UAAIvG,MAAM,CAAC2B,MAAP,KAAkB,KAAK+E,UAAL,CAAgB/E,MAAtC,EAA8C;AAC1C,cAAM,IAAIqB,KAAJ,CAAU,uBAAV,CAAN;AACH;;AAEDhD,YAAM,CAACE,OAAP,CAAe,CAACoE,KAAD,EAAQ0D,KAAR,KAAiB;AAC5BtB,kBAAU,CAACsB,KAAD,CAAV,CAAkB,UAAlB,CAA6BH,QAA7B,EAAuCvD,KAAvC,EAA8CmD,OAA9C,EAAwDnD,KAAD,IAAe;AAClEtE,gBAAM,CAACgI,KAAD,CAAN,GAAgB1D,KAAhB;AACH,SAFD;AAGH,OAJD;AAKAwD,cAAQ,CAAC9H,MAAD,CAAR;AACA;AACH;;AAED,UAAMA,MAAM,GAAGyH,OAAO,CAAC,KAAK5E,IAAN,EAAYyB,KAAZ,CAAtB;;AACA,QAAItE,MAAM,CAACkI,IAAX,EAAiB;AACbL,cAAQ,CAACrE,IAAT,CAAe,kBAAK;AAAcsE,gBAAQ,CAAC,MAAM9H,MAAP,CAAR;AAAyB,OAA7C,EAAd;AACH,KAFD,MAEO;AACH8H,cAAQ,CAAC9H,MAAD,CAAR;AACH;AACJ;AAED;;;;;;;;;AAOe,QAATmI,SAAS,CAAC7D,KAAD,EAAamD,OAAb,EAA4C;AACvD,UAAMI,QAAQ,GAAyB,EAAvC;AACA,UAAM7H,MAAM,GAAY,CAAEsE,KAAF,CAAxB;AACA,SAAK,UAAL,CAAgBuD,QAAhB,EAA0BvD,KAA1B,EAAiCmD,OAAjC,EAA2CnD,KAAD,IAAe;AACrDtE,YAAM,CAAC,CAAD,CAAN,GAAYsE,KAAZ;AACH,KAFD;;AAGA,QAAIuD,QAAQ,CAAClG,MAAb,EAAqB;AAAE,YAAMyG,OAAO,CAACC,GAAR,CAAYR,QAAZ,CAAN;AAA8B;;AACrD,WAAO7H,MAAM,CAAC,CAAD,CAAb;AACH;AAED;;;;;;;;AAMW,SAAJiC,IAAI,CAACqG,GAAD,EAAWlD,YAAX,EAAiC;AACxC,QAAIC,SAAS,CAACkD,WAAV,CAAsBD,GAAtB,CAAJ,EAAgC;AAAE,aAAOA,GAAP;AAAa;;AAE/C,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AAC1B,aAAOjD,SAAS,CAACpD,IAAV,CAAe6B,GAAG,CAACwE,GAAD,CAAlB,EAAyBlD,YAAzB,CAAP;AAEH,KAHD,MAGO,IAAIkD,GAAG,YAAY7G,WAAnB,EAAgC;AACnC,UAAIoB,IAAI,GAAG,EAAX;AAAA,UAAe2D,QAAQ,GAAG,EAA1B;AACA,UAAIgC,KAAK,GAA4B,IAArC;;AAEA,UAAIzD,eAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,OAAF,CAAD,CAAZ,CAAf,CAA0CgD,GAA1C,CAA8C,OAA9C,KAA0DwF,GAAG,CAAC5E,QAAJ,CAAa,YAAb,CAA9D,EAA0F;AACtF;AACA8C,gBAAQ,GAAG,OAAX;AACAgC,aAAK,GAAGF,GAAG,CAAChF,SAAJ,GAAgBnB,GAAhB,CAAqBC,CAAD,IAAOiD,SAAS,CAACpD,IAAV,CAAeG,CAAf,CAA3B,CAAR;AACAS,YAAI,GAAG,SAAU2F,KAAK,CAACrG,GAAN,CAAW+E,CAAD,IAAOA,CAAC,CAACH,MAAF,EAAjB,EAA6B/F,IAA7B,CAAkC,GAAlC,CAAuC,GAAxD;AACH,OALD,MAKO;AACH;AACA6B,YAAI,GAAG4C,eAAe,CAAC6C,GAAG,CAACpF,OAAJ,CAAY,MAAZ,CAAD,CAAtB;AACAsD,gBAAQ,GAAG3D,IAAX;AACH,OAbkC,CAenC;;;AACA,UAAI+D,aAAa,GAAsB,IAAvC;AACA,UAAID,WAAW,GAAkB,IAAjC;;AAEA,aAAO2B,GAAG,CAAC3G,MAAJ,IAAc2G,GAAG,CAAC5E,QAAJ,CAAa,SAAb,CAArB,EAA8C;AAC1C,cAAM+E,OAAO,GAAGH,GAAG,CAACrF,GAAJ,EAAhB,CAD0C,CACf;;AAC3B2D,qBAAa,GAAG,IAAIvB,SAAJ,CAAcO,MAAd,EAAsB,EAAtB,EAA0B/C,IAA1B,EAAgC2D,QAAhC,EAA0C,IAA1C,EAAgDgC,KAAhD,EAAuD7B,WAAvD,EAAoEC,aAApE,CAAhB;AACAD,mBAAW,GAAG8B,OAAO,CAACnE,KAAtB;AACAzB,YAAI,IAAI4F,OAAO,CAAC1F,IAAhB;AACAyD,gBAAQ,GAAG,OAAX;AACAgC,aAAK,GAAG,IAAR;AACH;;AAED,UAAI/B,OAAO,GAAG,IAAd;AACA,YAAMzB,QAAQ,GAAGD,eAAe,CAACuD,GAAD,EAAMzH,WAAN,CAAhC;;AACA,UAAImE,QAAQ,CAAClC,GAAT,CAAa,SAAb,CAAJ,EAA6B;AACzB,YAAI,CAACsC,YAAL,EAAmB;AAAE,gBAAM,IAAIpC,KAAJ,CAAU,EAAV,CAAN;AAAsB;;AAC3CyD,eAAO,GAAG,IAAV;AACH;;AAED,YAAMF,IAAI,GAAI+B,GAAG,CAAC5E,QAAJ,CAAa,IAAb,IAAqB4E,GAAG,CAACrF,GAAJ,GAAUF,IAA/B,GAAqC,EAAnD;;AAEA,UAAIuF,GAAG,CAAC3G,MAAR,EAAgB;AAAE,cAAM,IAAIqB,KAAJ,CAAU,iBAAV,CAAN;AAAqC;;AAEvD,aAAO,IAAIqC,SAAJ,CAAcO,MAAd,EAAsBW,IAAtB,EAA4B1D,IAA5B,EAAkC2D,QAAlC,EAA4CC,OAA5C,EAAqD+B,KAArD,EAA4D7B,WAA5D,EAAyEC,aAAzE,CAAP;AACH;;AAED,UAAML,IAAI,GAAG+B,GAAG,CAAC/B,IAAjB;AACA3G,kBAAc,CAAC,CAAC2G,IAAD,IAAU,OAAOA,IAAP,KAAiB,QAAjB,IAA6BA,IAAI,CAACjE,KAAL,CAAWf,OAAX,CAAxC,EACV,cADU,EACM,UADN,EACkBgF,IADlB,CAAd;AAGA,QAAIE,OAAO,GAAG6B,GAAG,CAAC7B,OAAlB;;AACA,QAAIA,OAAO,IAAI,IAAf,EAAqB;AACjB7G,oBAAc,CAACwF,YAAD,EAAe,6BAAf,EAA8C,aAA9C,EAA6DkD,GAAG,CAAC7B,OAAjE,CAAd;AACAA,aAAO,GAAG,CAAC,CAACA,OAAZ;AACH;;AAED,QAAI5D,IAAI,GAAGyF,GAAG,CAACzF,IAAf;AAEA,QAAI6F,UAAU,GAAG7F,IAAI,CAACP,KAAL,CAAWkD,cAAX,CAAjB;;AACA,QAAIkD,UAAJ,EAAgB;AACZ,YAAM/B,WAAW,GAAGjB,QAAQ,CAACgD,UAAU,CAAC,CAAD,CAAV,IAAiB,IAAlB,CAA5B;AACA,YAAM9B,aAAa,GAAGvB,SAAS,CAACpD,IAAV,CAAe;AACjCY,YAAI,EAAE6F,UAAU,CAAC,CAAD,CADiB;AAEjChC,kBAAU,EAAE4B,GAAG,CAAC5B;AAFiB,OAAf,CAAtB;AAKA,aAAO,IAAIrB,SAAJ,CAAcO,MAAd,EAAsBW,IAAI,IAAI,EAA9B,EAAkC1D,IAAlC,EAAwC,OAAxC,EAAiD4D,OAAjD,EAA0D,IAA1D,EAAgEE,WAAhE,EAA6EC,aAA7E,CAAP;AACH;;AAED,QAAI/D,IAAI,KAAK,OAAT,IAAoBA,IAAI,CAACuB,SAAL,CAAe,CAAf,EAAkB,CAAlB,MAAyB,QAA7C,IAAyDvB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAzE,EAA8E;AAC1E,YAAM2F,KAAK,GAAIF,GAAG,CAAC5B,UAAJ,IAAkB,IAAnB,GAA2B4B,GAAG,CAAC5B,UAAJ,CAAevE,GAAf,CAAoB+E,CAAD,IAAY7B,SAAS,CAACpD,IAAV,CAAeiF,CAAf,CAA/B,CAA3B,GAA8E,IAA5F;AACA,YAAMyB,KAAK,GAAG,IAAItD,SAAJ,CAAcO,MAAd,EAAsBW,IAAI,IAAI,EAA9B,EAAkC1D,IAAlC,EAAwC,OAAxC,EAAiD4D,OAAjD,EAA0D+B,KAA1D,EAAiE,IAAjE,EAAuE,IAAvE,CAAd,CAF0E,CAG1E;;AACA,aAAOG,KAAP;AACH;;AAED9F,QAAI,GAAG4C,eAAe,CAAC6C,GAAG,CAACzF,IAAL,CAAtB;AAEA,WAAO,IAAIwC,SAAJ,CAAcO,MAAd,EAAsBW,IAAI,IAAI,EAA9B,EAAkC1D,IAAlC,EAAwCA,IAAxC,EAA8C4D,OAA9C,EAAuD,IAAvD,EAA6D,IAA7D,EAAmE,IAAnE,CAAP;AACH;AAED;;;;;AAGkB,SAAX8B,WAAW,CAACjE,KAAD,EAAW;AACzB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBG,iBAArC;AACH;;AA/WiB;AAuXtB;;;;AAGA,OAAM,MAAgB4C,QAAhB,CAAwB;AAC1B;;;AAGS/F,MAAI;AAEb;;;;AAGSgG,QAAM;AAEf;;;;AAGAjH,cAAYiF,KAAZ,EAAwBhE,IAAxB,EAA4CgG,MAA5C,EAA4E;AACxElJ,iBAAa,CAACkH,KAAD,EAAQjB,MAAR,EAAgB,UAAhB,CAAb;AACAiD,UAAM,GAAGxI,MAAM,CAACC,MAAP,CAAcuI,MAAM,CAAC/G,KAAP,EAAd,CAAT;AACAvC,oBAAgB,CAAW,IAAX,EAAiB;AAAEsD,UAAF;AAAQgG;AAAR,KAAjB,CAAhB;AACH;AAOD;;;;;;AAIW,SAAJ5G,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AAE1B;AACA,UAAI;AACAM,gBAAQ,CAAC3G,IAAT,CAAckB,IAAI,CAACgE,KAAL,CAAWmB,GAAX,CAAd;AACH,OAFD,CAEE,OAAOQ,CAAP,EAAU,CAAG,CALW,CAO1B;;;AACA,aAAOF,QAAQ,CAAC3G,IAAT,CAAc6B,GAAG,CAACwE,GAAD,CAAjB,CAAP;AACH;;AAED,QAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AAC5B;AAEA,YAAMoB,IAAI,GAAGyF,GAAG,CAAC7E,WAAJ,CAAgB9C,OAAhB,CAAb;;AAEA,cAAQkC,IAAR;AACI,aAAK,aAAL;AAAoB,iBAAOkG,mBAAmB,CAAC9G,IAApB,CAAyBqG,GAAzB,CAAP;;AACpB,aAAK,OAAL;AAAc,iBAAOU,aAAa,CAAC/G,IAAd,CAAmBqG,GAAnB,CAAP;;AACd,aAAK,OAAL;AAAc,iBAAOW,aAAa,CAAChH,IAAd,CAAmBqG,GAAnB,CAAP;;AACd,aAAK,UAAL;AAAiB,aAAK,SAAL;AACb,iBAAOY,gBAAgB,CAACjH,IAAjB,CAAsBqG,GAAtB,CAAP;;AACJ,aAAK,UAAL;AAAiB,iBAAOa,gBAAgB,CAAClH,IAAjB,CAAsBqG,GAAtB,CAAP;;AACjB,aAAK,QAAL;AAAe,iBAAOc,cAAc,CAACnH,IAAf,CAAoBqG,GAApB,CAAP;AAPnB;AAUH,KAfD,MAeO,IAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AACjC;AAEA,cAAQA,GAAG,CAACzF,IAAZ;AACI,aAAK,aAAL;AAAoB,iBAAOkG,mBAAmB,CAAC9G,IAApB,CAAyBqG,GAAzB,CAAP;;AACpB,aAAK,OAAL;AAAc,iBAAOU,aAAa,CAAC/G,IAAd,CAAmBqG,GAAnB,CAAP;;AACd,aAAK,OAAL;AAAc,iBAAOW,aAAa,CAAChH,IAAd,CAAmBqG,GAAnB,CAAP;;AACd,aAAK,UAAL;AAAiB,aAAK,SAAL;AACb,iBAAOY,gBAAgB,CAACjH,IAAjB,CAAsBqG,GAAtB,CAAP;;AACJ,aAAK,UAAL;AAAiB,iBAAOa,gBAAgB,CAAClH,IAAjB,CAAsBqG,GAAtB,CAAP;;AACjB,aAAK,QAAL;AAAe,iBAAOc,cAAc,CAACnH,IAAf,CAAoBqG,GAApB,CAAP;AAPnB;;AAUA5I,YAAM,CAAC,KAAD,EAAQ,qBAAsB4I,GAAG,CAACzF,IAAK,EAAvC,EAA2C,uBAA3C,EAAoE;AACtEwG,iBAAS,EAAE;AAD2D,OAApE,CAAN;AAGH;;AAEDzJ,kBAAc,CAAC,KAAD,EAAQ,6BAAR,EAAuC,KAAvC,EAA8C0I,GAA9C,CAAd;AACH;AAED;;;;;AAGoB,SAAbgB,aAAa,CAAChF,KAAD,EAAW;AAC3B,WAAOyE,mBAAmB,CAACQ,UAApB,CAA+BjF,KAA/B,CAAP;AACH;AAED;;;;;AAGc,SAAPkF,OAAO,CAAClF,KAAD,EAAW;AACrB,WAAO0E,aAAa,CAACO,UAAd,CAAyBjF,KAAzB,CAAP;AACH;AAED;;;;;AAGc,SAAPmF,OAAO,CAACnF,KAAD,EAAW;AACrB,WAAO2E,aAAa,CAACM,UAAd,CAAyBjF,KAAzB,CAAP;AACH;AAED;;;;;AAGiB,SAAVoF,UAAU,CAACpF,KAAD,EAAW;AACxB,WAAO6E,gBAAgB,CAACI,UAAjB,CAA4BjF,KAA5B,CAAP;AACH;AAED;;;;;AAGe,SAARqF,QAAQ,CAACrF,KAAD,EAAW;AACtB,WAAO8E,cAAc,CAACG,UAAf,CAA0BjF,KAA1B,CAAP;AACH;;AA9GyB;AAiH9B;;;;;AAIA,OAAM,MAAgBsF,aAAhB,SAAsChB,QAAtC,CAA8C;AAChD;;;AAGSrC,MAAI;AAEb;;;;AAGA3E,cAAYiF,KAAZ,EAAwBhE,IAAxB,EAA4C0D,IAA5C,EAA0DsC,MAA1D,EAA0F;AACtF,UAAMhC,KAAN,EAAahE,IAAb,EAAmBgG,MAAnB;AACAjJ,kBAAc,CAAC,OAAO2G,IAAP,KAAiB,QAAjB,IAA6BA,IAAI,CAACjE,KAAL,CAAWf,OAAX,CAA9B,EACV,oBADU,EACY,MADZ,EACoBgF,IADpB,CAAd;AAEAsC,UAAM,GAAGxI,MAAM,CAACC,MAAP,CAAcuI,MAAM,CAAC/G,KAAP,EAAd,CAAT;AACAvC,oBAAgB,CAAgB,IAAhB,EAAsB;AAAEgH;AAAF,KAAtB,CAAhB;AACH;;AAf+C;;AAkBpD,SAASsD,UAAT,CAAoB9C,MAApB,EAAwC+C,MAAxC,EAAwE;AACpE,SAAO,MAAMA,MAAM,CAAC3H,GAAP,CAAY4H,CAAD,IAAOA,CAAC,CAAChD,MAAF,CAASA,MAAT,CAAlB,EAAoC/F,IAApC,CAA0C+F,MAAM,KAAK,MAAZ,GAAsB,IAAtB,GAA4B,GAArE,CAAN,GAAkF,GAAzF;AACH;AAED;;;;;AAGA,OAAM,MAAOiC,aAAP,SAA6BY,aAA7B,CAA0C;AAC5C;;;AAGAhI,cAAYiF,KAAZ,EAAwBN,IAAxB,EAAsCsC,MAAtC,EAAsE;AAClE,UAAMhC,KAAN,EAAa,OAAb,EAAsBN,IAAtB,EAA4BsC,MAA5B;AACAxI,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAE2B;AAAT,KAAtC;AACH;AAED;;;;;AAGY,MAAR+D,QAAQ;AACR,WAAOnK,EAAE,CAAC,KAAKkH,MAAL,CAAY,SAAZ,CAAD,CAAF,CAA2B3C,SAA3B,CAAqC,CAArC,EAAwC,EAAxC,CAAP;AACH;;AAED2C,QAAM,CAACA,MAAD,EAAoB;AACtB,QAAIA,MAAM,IAAI,IAAd,EAAoB;AAAEA,YAAM,GAAG,SAAT;AAAqB;;AAC3C,QAAIA,MAAM,KAAK,MAAf,EAAuB;AACnB,aAAO5D,IAAI,CAACC,SAAL,CAAe;AAClBP,YAAI,EAAE,OADY;AAElB0D,YAAI,EAAE,KAAKA,IAFO;AAGlBsC,cAAM,EAAE,KAAKA,MAAL,CAAY1G,GAAZ,CAAiB8H,KAAD,IAAW9G,IAAI,CAACgE,KAAL,CAAW8C,KAAK,CAAClD,MAAN,CAAaA,MAAb,CAAX,CAA3B;AAHU,OAAf,CAAP;AAKH;;AAED,UAAM/G,MAAM,GAAG,EAAf;;AACA,QAAI+G,MAAM,KAAK,SAAf,EAA0B;AAAE/G,YAAM,CAACwD,IAAP,CAAY,OAAZ;AAAuB;;AACnDxD,UAAM,CAACwD,IAAP,CAAY,KAAK+C,IAAL,GAAYsD,UAAU,CAAC9C,MAAD,EAAS,KAAK8B,MAAd,CAAlC;AACA,WAAO7I,MAAM,CAACgB,IAAP,CAAY,GAAZ,CAAP;AACH;;AAEU,SAAJiB,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAIU,aAAa,CAACO,UAAd,CAAyBjB,GAAzB,CAAJ,EAAmC;AAAE,aAAOA,GAAP;AAAa;;AAElD,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AAC1B,aAAOU,aAAa,CAAC/G,IAAd,CAAmB6B,GAAG,CAACwE,GAAD,CAAtB,CAAP;AAEH,KAHD,MAGO,IAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AACnC,YAAM8E,IAAI,GAAG1B,WAAW,CAAC,OAAD,EAAUyD,GAAV,CAAxB;AACA,YAAMO,MAAM,GAAG1D,aAAa,CAACmD,GAAD,CAA5B;AACA/C,gBAAU,CAAC+C,GAAD,CAAV;AAEA,aAAO,IAAIU,aAAJ,CAAkBpD,MAAlB,EAA0BW,IAA1B,EAAgCsC,MAAhC,CAAP;AACH;;AAED,WAAO,IAAIG,aAAJ,CAAkBpD,MAAlB,EAA0B0C,GAAG,CAAC/B,IAA9B,EACH+B,GAAG,CAACO,MAAJ,GAAaP,GAAG,CAACO,MAAJ,CAAW1G,GAAX,CAAekD,SAAS,CAACpD,IAAzB,CAAb,GAA6C,EAD1C,CAAP;AAEH;;AAEgB,SAAVsH,UAAU,CAACjF,KAAD,EAAW;AACxB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBI,qBAArC;AACH;;AApD2C;AAuDhD;;;;AAGA,OAAM,MAAOgD,aAAP,SAA6BW,aAA7B,CAA0C;AACnCM,WAAS;AAElB;;;;AAGAtI,cAAYiF,KAAZ,EAAwBN,IAAxB,EAAsCsC,MAAtC,EAAwEqB,SAAxE,EAA0F;AACtF,UAAMrD,KAAN,EAAa,OAAb,EAAsBN,IAAtB,EAA4BsC,MAA5B;AACAxI,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAE4B;AAAT,KAAtC;AACA3G,oBAAgB,CAAgB,IAAhB,EAAsB;AAAE2K;AAAF,KAAtB,CAAhB;AACH;AAED;;;;;AAGa,MAATC,SAAS;AACT,WAAOtK,EAAE,CAAC,KAAKkH,MAAL,CAAY,SAAZ,CAAD,CAAT;AACH;;AAEDA,QAAM,CAACA,MAAD,EAAoB;AACtB,QAAIA,MAAM,IAAI,IAAd,EAAoB;AAAEA,YAAM,GAAG,SAAT;AAAqB;;AAC3C,QAAIA,MAAM,KAAK,MAAf,EAAuB;AACnB,aAAO5D,IAAI,CAACC,SAAL,CAAe;AAClBP,YAAI,EAAE,OADY;AAElBqH,iBAAS,EAAE,KAAKA,SAFE;AAGlB3D,YAAI,EAAE,KAAKA,IAHO;AAIlBsC,cAAM,EAAE,KAAKA,MAAL,CAAY1G,GAAZ,CAAiByB,CAAD,IAAOT,IAAI,CAACgE,KAAL,CAAWvD,CAAC,CAACmD,MAAF,CAASA,MAAT,CAAX,CAAvB;AAJU,OAAf,CAAP;AAMH;;AAED,UAAM/G,MAAM,GAAG,EAAf;;AACA,QAAI+G,MAAM,KAAK,SAAf,EAA0B;AAAE/G,YAAM,CAACwD,IAAP,CAAY,OAAZ;AAAuB;;AACnDxD,UAAM,CAACwD,IAAP,CAAY,KAAK+C,IAAL,GAAYsD,UAAU,CAAC9C,MAAD,EAAS,KAAK8B,MAAd,CAAlC;;AACA,QAAI9B,MAAM,KAAK,SAAX,IAAwB,KAAKmD,SAAjC,EAA4C;AAAElK,YAAM,CAACwD,IAAP,CAAY,WAAZ;AAA2B;;AACzE,WAAOxD,MAAM,CAACgB,IAAP,CAAY,GAAZ,CAAP;AACH;;AAEkB,SAAZoJ,YAAY,CAAC7D,IAAD,EAAeuD,MAAf,EAAkC;AACjDA,UAAM,GAAG,CAACA,MAAM,IAAI,EAAX,EAAe3H,GAAf,CAAoB4H,CAAD,IAAO1E,SAAS,CAACpD,IAAV,CAAe8H,CAAf,CAA1B,CAAT;AACA,UAAMM,QAAQ,GAAG,IAAIpB,aAAJ,CAAkBrD,MAAlB,EAA0BW,IAA1B,EAAgCuD,MAAhC,EAAwC,KAAxC,CAAjB;AACA,WAAOO,QAAQ,CAACF,SAAhB;AACH;;AAEU,SAAJlI,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAIW,aAAa,CAACM,UAAd,CAAyBjB,GAAzB,CAAJ,EAAmC;AAAE,aAAOA,GAAP;AAAa;;AAElD,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AAC1B,aAAOW,aAAa,CAAChH,IAAd,CAAmB6B,GAAG,CAACwE,GAAD,CAAtB,CAAP;AAEH,KAHD,MAGO,IAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AACnC,YAAM8E,IAAI,GAAG1B,WAAW,CAAC,OAAD,EAAUyD,GAAV,CAAxB;AACA,YAAMO,MAAM,GAAG1D,aAAa,CAACmD,GAAD,EAAM,IAAN,CAA5B;AACA,YAAM4B,SAAS,GAAG,CAAC,CAACnF,eAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,WAAF,CAAD,CAAZ,CAAf,CAA8CgD,GAA9C,CAAkD,WAAlD,CAApB;AACAyC,gBAAU,CAAC+C,GAAD,CAAV;AAEA,aAAO,IAAIW,aAAJ,CAAkBrD,MAAlB,EAA0BW,IAA1B,EAAgCsC,MAAhC,EAAwCqB,SAAxC,CAAP;AACH;;AAED,WAAO,IAAIjB,aAAJ,CAAkBrD,MAAlB,EAA0B0C,GAAG,CAAC/B,IAA9B,EACH+B,GAAG,CAACO,MAAJ,GAAaP,GAAG,CAACO,MAAJ,CAAW1G,GAAX,CAAgB4H,CAAD,IAAY1E,SAAS,CAACpD,IAAV,CAAe8H,CAAf,EAAkB,IAAlB,CAA3B,CAAb,GAAkE,EAD/D,EACoE,CAAC,CAACzB,GAAG,CAAC4B,SAD1E,CAAP;AAEH;;AAEgB,SAAVX,UAAU,CAACjF,KAAD,EAAW;AACxB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBK,qBAArC;AACH;;AAhE2C;AAmEhD;;;;AAGA,OAAM,MAAO6C,mBAAP,SAAmCH,QAAnC,CAA2C;AACpC0B,SAAO;AACPC,KAAG;AAEZ;;;;AAGA3I,cAAYiF,KAAZ,EAAwBhE,IAAxB,EAA4CgG,MAA5C,EAA8EyB,OAA9E,EAAgGC,GAAhG,EAAkH;AAC9G,UAAM1D,KAAN,EAAahE,IAAb,EAAmBgG,MAAnB;AACAxI,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAE6B;AAAT,KAAtC;AACA5G,oBAAgB,CAAsB,IAAtB,EAA4B;AAAE+K,aAAF;AAAWC;AAAX,KAA5B,CAAhB;AACH;;AAEDxD,QAAM,CAACA,MAAD,EAAoB;AACtBrH,UAAM,CAACqH,MAAM,IAAI,IAAV,IAAkBA,MAAM,KAAK,SAA9B,EAAyC,yCAAzC,EACF,uBADE,EACuB;AAAEsC,eAAS,EAAE;AAAb,KADvB,CAAN;;AAGA,QAAItC,MAAM,KAAK,MAAf,EAAuB;AACnB,aAAO5D,IAAI,CAACC,SAAL,CAAe;AAClBP,YAAI,EAAE,aADY;AAElB2H,uBAAe,EAAG,KAAKF,OAAL,GAAe,SAAf,GAA0B,WAF1B;AAGlBA,eAAO,EAAE,KAAKA,OAHI;AAIlBC,WAAG,EAAI,KAAKA,GAAL,IAAY,IAAb,GAAqB,KAAKA,GAA1B,GAA+BvD,SAJnB;AAKlB6B,cAAM,EAAE,KAAKA,MAAL,CAAY1G,GAAZ,CAAiByB,CAAD,IAAOT,IAAI,CAACgE,KAAL,CAAWvD,CAAC,CAACmD,MAAF,CAASA,MAAT,CAAX,CAAvB;AALU,OAAf,CAAP;AAOH;;AAED,UAAM/G,MAAM,GAAG,CAAE,cAAe6J,UAAU,CAAC9C,MAAD,EAAS,KAAK8B,MAAd,CAAsB,EAAjD,CAAf;AACA7I,UAAM,CAACwD,IAAP,CAAa,KAAK8G,OAAN,GAAiB,SAAjB,GAA4B,YAAxC;;AACA,QAAI,KAAKC,GAAL,IAAY,IAAhB,EAAsB;AAAEvK,YAAM,CAACwD,IAAP,CAAY,IAAK,KAAK+G,GAAL,CAAS5G,QAAT,EAAoB,EAArC;AAA2C;;AACnE,WAAO3D,MAAM,CAACgB,IAAP,CAAY,GAAZ,CAAP;AACH;;AAEU,SAAJiB,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAIS,mBAAmB,CAACQ,UAApB,CAA+BjB,GAA/B,CAAJ,EAAyC;AAAE,aAAOA,GAAP;AAAa;;AAExD,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AAC1B,aAAOS,mBAAmB,CAAC9G,IAApB,CAAyB6B,GAAG,CAACwE,GAAD,CAA5B,CAAP;AAEH,KAHD,MAGO,IAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AACnCsD,qBAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,aAAF,CAAD,CAAZ,CAAf;AACA,YAAM+I,MAAM,GAAG1D,aAAa,CAACmD,GAAD,CAA5B;AACA,YAAMgC,OAAO,GAAG,CAAC,CAACvF,eAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,SAAF,CAAD,CAAZ,CAAf,CAA4CgD,GAA5C,CAAgD,SAAhD,CAAlB;AACA,YAAMyH,GAAG,GAAGjF,UAAU,CAACgD,GAAD,CAAtB;AACA/C,gBAAU,CAAC+C,GAAD,CAAV;AAEA,aAAO,IAAIS,mBAAJ,CAAwBnD,MAAxB,EAAgC,aAAhC,EAA+CiD,MAA/C,EAAuDyB,OAAvD,EAAgEC,GAAhE,CAAP;AACH;;AAED,WAAO,IAAIxB,mBAAJ,CAAwBnD,MAAxB,EAAgC,aAAhC,EACH0C,GAAG,CAACO,MAAJ,GAAaP,GAAG,CAACO,MAAJ,CAAW1G,GAAX,CAAekD,SAAS,CAACpD,IAAzB,CAAb,GAA6C,EAD1C,EAEH,CAAC,CAACqG,GAAG,CAACgC,OAFH,EAEahC,GAAG,CAACiC,GAAJ,IAAW,IAAZ,GAAoBjC,GAAG,CAACiC,GAAxB,GAA6B,IAFzC,CAAP;AAGH;;AAEgB,SAAVhB,UAAU,CAACjF,KAAD,EAAW;AACxB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBM,2BAArC;AACH;;AAxD4C;AA2DjD;;;;AAGA,OAAM,MAAO+C,gBAAP,SAAgCN,QAAhC,CAAwC;AAE1C;;;AAGS0B,SAAO;;AAEhB1I,cAAYiF,KAAZ,EAAwBgC,MAAxB,EAA0DyB,OAA1D,EAA0E;AACtE,UAAMzD,KAAN,EAAa,UAAb,EAAyBgC,MAAzB;AACAxI,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAE8B;AAAT,KAAtC;AACA7G,oBAAgB,CAAmB,IAAnB,EAAyB;AAAE+K;AAAF,KAAzB,CAAhB;AACH;;AAEDvD,QAAM,CAACA,MAAD,EAAoB;AACtB,UAAMlE,IAAI,GAAK,KAAKgG,MAAL,CAAYlH,MAAZ,KAAuB,CAAxB,GAA6B,SAA7B,GAAwC,UAAtD;;AAEA,QAAIoF,MAAM,KAAK,MAAf,EAAuB;AACnB,YAAMyD,eAAe,GAAI,KAAKF,OAAL,GAAe,SAAf,GAA0B,YAAnD;AACA,aAAOnH,IAAI,CAACC,SAAL,CAAe;AAAEP,YAAF;AAAQ2H;AAAR,OAAf,CAAP;AACH;;AAED,WAAO,GAAI3H,IAAK,KAAM,KAAKyH,OAAL,GAAe,UAAf,GAA2B,EAAG,EAApD;AACH;;AAEU,SAAJrI,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAIY,gBAAgB,CAACK,UAAjB,CAA4BjB,GAA5B,CAAJ,EAAsC;AAAE,aAAOA,GAAP;AAAa;;AAErD,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AACzB,aAAOY,gBAAgB,CAACjH,IAAjB,CAAsB6B,GAAG,CAACwE,GAAD,CAAzB,CAAP;AAEJ,KAHD,MAGO,IAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AACnC,YAAMgJ,QAAQ,GAAGnC,GAAG,CAAC3E,QAAJ,EAAjB;AAEA,YAAM+G,UAAU,GAAGpC,GAAG,CAAC7E,WAAJ,CAAgB3D,MAAM,CAAC,CAAE,UAAF,EAAc,SAAd,CAAD,CAAtB,CAAnB;AACAF,oBAAc,CAAC8K,UAAD,EAAa,kCAAb,EAAiD,KAAjD,EAAwDD,QAAxD,CAAd;AAEA,YAAM5H,IAAI,GAAGyF,GAAG,CAAC7F,UAAJ,CAAe3C,MAAM,CAAC,CAAE,UAAF,EAAc,SAAd,CAAD,CAArB,CAAb,CANmC,CAQnC;;AACA,UAAI+C,IAAI,KAAK,SAAb,EAAwB;AACpB,cAAMgG,MAAM,GAAG1D,aAAa,CAACmD,GAAD,CAA5B;AACA1I,sBAAc,CAACiJ,MAAM,CAAClH,MAAP,KAAkB,CAAnB,EAAsB,+BAAtB,EAAuD,YAAvD,EAAqEkH,MAArE,CAAd;AACA9D,uBAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,SAAF,CAAD,CAAZ,CAAf;AACAyF,kBAAU,CAAC+C,GAAD,CAAV;AACA,eAAO,IAAIY,gBAAJ,CAAqBtD,MAArB,EAA6B,EAA7B,EAAkC,IAAlC,CAAP;AACH,OAfkC,CAiBnC;AACA;;;AACA,UAAIiD,MAAM,GAAG1D,aAAa,CAACmD,GAAD,CAA1B;;AACA,UAAIO,MAAM,CAAClH,MAAX,EAAmB;AACf/B,sBAAc,CAACiJ,MAAM,CAAClH,MAAP,KAAkB,CAAlB,IAAuBkH,MAAM,CAAC,CAAD,CAAN,CAAUhG,IAAV,KAAmB,OAA3C,EACV,yBADU,EACiB,YADjB,EAEVgG,MAAM,CAAC1G,GAAP,CAAYyB,CAAD,IAAOA,CAAC,CAACmD,MAAF,CAAS,SAAT,CAAlB,EAAuC/F,IAAvC,CAA4C,IAA5C,CAFU,CAAd;AAGH,OAJD,MAIO;AACH6H,cAAM,GAAG,CAAExD,SAAS,CAACpD,IAAV,CAAe,OAAf,CAAF,CAAT;AACH;;AAED,YAAM0I,UAAU,GAAG1F,iBAAiB,CAACqD,GAAD,CAApC;AACA1I,oBAAc,CAAC+K,UAAU,KAAK,YAAf,IAA+BA,UAAU,KAAK,SAA/C,EAA0D,8BAA1D,EAA0F,qBAA1F,EAAiHA,UAAjH,CAAd;;AAEA,UAAI5F,eAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,SAAF,CAAD,CAAZ,CAAf,CAA4CgD,GAA5C,CAAgD,SAAhD,CAAJ,EAAgE;AAC5D,cAAM8H,OAAO,GAAGzF,aAAa,CAACmD,GAAD,CAA7B;AACA1I,sBAAc,CAACgL,OAAO,CAACjJ,MAAR,KAAmB,CAAnB,IAAwBiJ,OAAO,CAAC,CAAD,CAAP,CAAW/H,IAAX,KAAoB,OAA7C,EACV,0BADU,EACkB,aADlB,EAEV+H,OAAO,CAACzI,GAAR,CAAayB,CAAD,IAAOA,CAAC,CAACmD,MAAF,CAAS,SAAT,CAAnB,EAAwC/F,IAAxC,CAA6C,IAA7C,CAFU,CAAd;AAGH;;AAEDuE,gBAAU,CAAC+C,GAAD,CAAV;AAEA,aAAO,IAAIY,gBAAJ,CAAqBtD,MAArB,EAA6BiD,MAA7B,EAAqC8B,UAAU,KAAK,SAApD,CAAP;AACH;;AAED,QAAIrC,GAAG,CAACzF,IAAJ,KAAa,SAAjB,EAA4B;AACxB,aAAO,IAAIqG,gBAAJ,CAAqBtD,MAArB,EAA6B,EAA7B,EAAkC,IAAlC,CAAP;AACH;;AAED,QAAI0C,GAAG,CAACzF,IAAJ,KAAa,UAAjB,EAA6B;AACzB,YAAMgG,MAAM,GAAG,CAAExD,SAAS,CAACpD,IAAV,CAAe,OAAf,CAAF,CAAf;AACA,YAAMqI,OAAO,GAAIhC,GAAG,CAACkC,eAAJ,KAAwB,SAAzC;AACA,aAAO,IAAItB,gBAAJ,CAAqBtD,MAArB,EAA6BiD,MAA7B,EAAqCyB,OAArC,CAAP;AACH;;AAED1K,kBAAc,CAAC,KAAD,EAAQ,8BAAR,EAAwC,KAAxC,EAA+C0I,GAA/C,CAAd;AACH;;AAEgB,SAAViB,UAAU,CAACjF,KAAD,EAAW;AACxB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBO,wBAArC;AACH;;AAxFyC;AA4F9C;;;;AAGA,OAAM,MAAO+C,gBAAP,SAAgCS,aAAhC,CAA6C;AAC/C;;;AAGSiB,UAAQ;AAEjB;;;;AAGSD,SAAO;AAEhB;;;;;AAISJ,iBAAe;AAExB;;;;AAGSF,SAAO;AAEhB;;;;AAGSC,KAAG;AAEZ;;;;AAGA3I,cAAYiF,KAAZ,EAAwBN,IAAxB,EAAsCiE,eAAtC,EAAmG3B,MAAnG,EAAqI+B,OAArI,EAAwKL,GAAxK,EAA0L;AACtL,UAAM1D,KAAN,EAAa,UAAb,EAAyBN,IAAzB,EAA+BsC,MAA/B;AACAxI,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAE+B;AAAT,KAAtC;AACAuE,WAAO,GAAGvK,MAAM,CAACC,MAAP,CAAcsK,OAAO,CAAC9I,KAAR,EAAd,CAAV;AACA,UAAM+I,QAAQ,GAAIL,eAAe,KAAK,MAApB,IAA8BA,eAAe,KAAK,MAApE;AACA,UAAMF,OAAO,GAAIE,eAAe,KAAK,SAArC;AACAjL,oBAAgB,CAAmB,IAAnB,EAAyB;AAAEsL,cAAF;AAAYN,SAAZ;AAAiBK,aAAjB;AAA0BN,aAA1B;AAAmCE;AAAnC,KAAzB,CAAhB;AACH;AAED;;;;;AAGY,MAARR,QAAQ;AACR,WAAOnK,EAAE,CAAC,KAAKkH,MAAL,CAAY,SAAZ,CAAD,CAAF,CAA2B3C,SAA3B,CAAqC,CAArC,EAAwC,EAAxC,CAAP;AACH;;AAED2C,QAAM,CAACA,MAAD,EAAoB;AACtB,QAAIA,MAAM,IAAI,IAAd,EAAoB;AAAEA,YAAM,GAAG,SAAT;AAAqB;;AAC3C,QAAIA,MAAM,KAAK,MAAf,EAAuB;AACnB,aAAO5D,IAAI,CAACC,SAAL,CAAe;AAClBP,YAAI,EAAE,UADY;AAElB0D,YAAI,EAAE,KAAKA,IAFO;AAGlBsE,gBAAQ,EAAE,KAAKA,QAHG;AAIlBL,uBAAe,EAAI,KAAKA,eAAL,KAAyB,YAA1B,GAA0C,KAAKA,eAA/C,GAAgExD,SAJhE;AAKlBsD,eAAO,EAAE,KAAKA,OALI;AAMlBC,WAAG,EAAI,KAAKA,GAAL,IAAY,IAAb,GAAqB,KAAKA,GAA1B,GAA+BvD,SANnB;AAOlB6B,cAAM,EAAE,KAAKA,MAAL,CAAY1G,GAAZ,CAAiByB,CAAD,IAAOT,IAAI,CAACgE,KAAL,CAAWvD,CAAC,CAACmD,MAAF,CAASA,MAAT,CAAX,CAAvB,CAPU;AAQlB6D,eAAO,EAAE,KAAKA,OAAL,CAAazI,GAAb,CAAkB2I,CAAD,IAAO3H,IAAI,CAACgE,KAAL,CAAW2D,CAAC,CAAC/D,MAAF,CAASA,MAAT,CAAX,CAAxB;AARS,OAAf,CAAP;AAUH;;AAED,UAAM/G,MAAM,GAAG,EAAf;;AAEA,QAAI+G,MAAM,KAAK,SAAf,EAA0B;AAAE/G,YAAM,CAACwD,IAAP,CAAY,UAAZ;AAA0B;;AAEtDxD,UAAM,CAACwD,IAAP,CAAY,KAAK+C,IAAL,GAAYsD,UAAU,CAAC9C,MAAD,EAAS,KAAK8B,MAAd,CAAlC;;AAEA,QAAI9B,MAAM,KAAK,SAAf,EAA0B;AACtB,UAAI,KAAKyD,eAAL,KAAyB,YAA7B,EAA2C;AACvCxK,cAAM,CAACwD,IAAP,CAAY,KAAKgH,eAAjB;AACH;;AAED,UAAI,KAAKI,OAAL,IAAgB,KAAKA,OAAL,CAAajJ,MAAjC,EAAyC;AACrC3B,cAAM,CAACwD,IAAP,CAAY,SAAZ;AACAxD,cAAM,CAACwD,IAAP,CAAYqG,UAAU,CAAC9C,MAAD,EAAS,KAAK6D,OAAd,CAAtB;AACH;;AAED,UAAI,KAAKL,GAAL,IAAY,IAAhB,EAAsB;AAAEvK,cAAM,CAACwD,IAAP,CAAY,IAAK,KAAK+G,GAAL,CAAS5G,QAAT,EAAoB,EAArC;AAA2C;AACtE;;AACD,WAAO3D,MAAM,CAACgB,IAAP,CAAY,GAAZ,CAAP;AACH;;AAEiB,SAAX+J,WAAW,CAACxE,IAAD,EAAeuD,MAAf,EAAkC;AAChDA,UAAM,GAAG,CAACA,MAAM,IAAI,EAAX,EAAe3H,GAAf,CAAoB4H,CAAD,IAAO1E,SAAS,CAACpD,IAAV,CAAe8H,CAAf,CAA1B,CAAT;AACA,UAAMM,QAAQ,GAAG,IAAIlB,gBAAJ,CAAqBvD,MAArB,EAA6BW,IAA7B,EAAmC,MAAnC,EAA2CuD,MAA3C,EAAmD,EAAnD,EAAwD,IAAxD,CAAjB;AACA,WAAOO,QAAQ,CAACL,QAAhB;AACH;;AAEU,SAAJ/H,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAIa,gBAAgB,CAACI,UAAjB,CAA4BjB,GAA5B,CAAJ,EAAsC;AAAE,aAAOA,GAAP;AAAa;;AAErD,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AACzB,aAAOa,gBAAgB,CAAClH,IAAjB,CAAsB6B,GAAG,CAACwE,GAAD,CAAzB,CAAP;AAEJ,KAHD,MAGO,IAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AACnC,YAAM8E,IAAI,GAAG1B,WAAW,CAAC,UAAD,EAAayD,GAAb,CAAxB;AACA,YAAMO,MAAM,GAAG1D,aAAa,CAACmD,GAAD,CAA5B;AACA,YAAMqC,UAAU,GAAG1F,iBAAiB,CAACqD,GAAD,CAApC;AAEA,UAAIsC,OAAO,GAAqB,EAAhC;;AACA,UAAI7F,eAAe,CAACuD,GAAD,EAAMxI,MAAM,CAAC,CAAE,SAAF,CAAD,CAAZ,CAAf,CAA4CgD,GAA5C,CAAgD,SAAhD,CAAJ,EAAgE;AAC5D8H,eAAO,GAAGzF,aAAa,CAACmD,GAAD,CAAvB;AACH;;AAED,YAAMiC,GAAG,GAAGjF,UAAU,CAACgD,GAAD,CAAtB;AAEA/C,gBAAU,CAAC+C,GAAD,CAAV;AAEA,aAAO,IAAIa,gBAAJ,CAAqBvD,MAArB,EAA6BW,IAA7B,EAAmCoE,UAAnC,EAA+C9B,MAA/C,EAAuD+B,OAAvD,EAAgEL,GAAhE,CAAP;AACH,KArBe,CAuBhB;;;AAEA,WAAO,IAAIpB,gBAAJ,CAAqBvD,MAArB,EAA6B0C,GAAG,CAAC/B,IAAjC,EAAuC+B,GAAG,CAACkC,eAA3C,EACFlC,GAAG,CAACO,MAAJ,GAAaP,GAAG,CAACO,MAAJ,CAAW1G,GAAX,CAAekD,SAAS,CAACpD,IAAzB,CAAb,GAA6C,EAD3C,EAEFqG,GAAG,CAACsC,OAAJ,GAActC,GAAG,CAACsC,OAAJ,CAAYzI,GAAZ,CAAgBkD,SAAS,CAACpD,IAA1B,CAAd,GAA+C,EAF7C,EAGDqG,GAAG,CAACiC,GAAJ,IAAW,IAAZ,GAAoBjC,GAAG,CAACiC,GAAxB,GAA6B,IAH3B,CAAP;AAIH;;AAEgB,SAAVhB,UAAU,CAACjF,KAAD,EAAW;AACxB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBQ,wBAArC;AACH;;AAzH8C;AA4HnD;;;;AAGA,OAAM,MAAO+C,cAAP,SAA8BQ,aAA9B,CAA2C;AAE7C;;;AAGAhI,cAAYiF,KAAZ,EAAwBN,IAAxB,EAAsCsC,MAAtC,EAAsE;AAClE,UAAMhC,KAAN,EAAa,QAAb,EAAuBN,IAAvB,EAA6BsC,MAA7B;AACAxI,UAAM,CAACyG,cAAP,CAAsB,IAAtB,EAA4BjB,QAA5B,EAAsC;AAAEvB,WAAK,EAAEgC;AAAT,KAAtC;AACH;;AAEDS,QAAM;AACF,UAAM,IAAI/D,KAAJ,CAAU,OAAV,CAAN;AACH;;AAEU,SAAJf,IAAI,CAACqG,GAAD,EAAS;AAChB,QAAI,OAAOA,GAAP,KAAgB,QAApB,EAA8B;AAC1B,aAAOc,cAAc,CAACnH,IAAf,CAAoB6B,GAAG,CAACwE,GAAD,CAAvB,CAAP;AAEH,KAHD,MAGO,IAAIA,GAAG,YAAY7G,WAAnB,EAAgC;AACnC,YAAM8E,IAAI,GAAG1B,WAAW,CAAC,QAAD,EAAWyD,GAAX,CAAxB;AACA,YAAMO,MAAM,GAAG1D,aAAa,CAACmD,GAAD,CAA5B;AACA/C,gBAAU,CAAC+C,GAAD,CAAV;AACA,aAAO,IAAIc,cAAJ,CAAmBxD,MAAnB,EAA2BW,IAA3B,EAAiCsC,MAAjC,CAAP;AACH;;AAED,WAAO,IAAIO,cAAJ,CAAmBxD,MAAnB,EAA2B0C,GAAG,CAAC/B,IAA/B,EAAqC+B,GAAG,CAACO,MAAJ,GAAaP,GAAG,CAACO,MAAJ,CAAW1G,GAAX,CAAekD,SAAS,CAACpD,IAAzB,CAAb,GAA6C,EAAlF,CAAP;AACH;;AAEgB,SAAVsH,UAAU,CAACjF,KAAD,EAAW;AACxB,WAAQA,KAAK,IAAIA,KAAK,CAACuB,QAAD,CAAL,KAAoBS,sBAArC;AACH;;AA9B4C","names":["defineProperties","getBigInt","getNumber","assert","assertPrivate","assertArgument","id","setify","items","result","Set","forEach","k","add","Object","freeze","_kwVisib","KwVisib","split","_kwTypes","KwTypes","_kwModifiers","KwModifiers","_kwOther","_keywords","join","Keywords","SimpleTokens","regexWhitespacePrefix","RegExp","regexNumberPrefix","regexIdPrefix","regexId","regexType","TokenString","offset","length","constructor","tokens","slice","clone","reset","from","to","map","t","assign","match","linkBack","linkNext","popKeyword","allowed","top","peek","type","has","text","Error","pop","popType","JSON","stringify","popParen","popParams","link","push","peekKeyword","peekType","toString","i","token","lex","throwError","message","brackets","commas","cur","substring","depth","value","suffix","allowSingle","set","included","key","keys","consumeName","keyword","consumeKeywords","keywords","consumeMutability","modifiers","consumeParams","allowIndexed","ParamType","consumeGas","consumeEoi","regexArrayType","verifyBasicType","parseInt","size","_guard","internal","Symbol","for","ParamTypeInternal","ErrorFragmentInternal","EventFragmentInternal","ConstructorFragmentInternal","FallbackFragmentInternal","FunctionFragmentInternal","StructFragmentInternal","name","baseType","indexed","components","arrayLength","arrayChildren","guard","defineProperty","format","undefined","isTuple","c","parse","isArray","String","comp","isIndexable","walk","process","Array","_this","v","promises","setValue","childType","index","param","then","walkAsync","Promise","all","obj","isParamType","comps","bracket","arrayMatch","tuple","Fragment","inputs","e","ConstructorFragment","ErrorFragment","EventFragment","FallbackFragment","FunctionFragment","StructFragment","operation","isConstructor","isFragment","isError","isEvent","isFunction","isStruct","NamedFragment","joinParams","params","p","selector","input","anonymous","topicHash","getTopicHash","fragment","payable","gas","stateMutability","errorObj","topIsValid","mutability","outputs","constant","o","getSelector"],"sourceRoot":"","sources":["../../src.ts/abi/fragments.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}