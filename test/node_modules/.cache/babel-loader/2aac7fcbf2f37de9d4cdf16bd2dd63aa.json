{"ast":null,"code":"/**\n *  A **Password-Based Key-Derivation Function** is designed to create\n *  a sequence of bytes suitible as a **key** from a human-rememberable\n *  password.\n *\n *  @_subsection: api/crypto:Passwords  [about-pbkdf]\n */\nimport { pbkdf2Sync } from \"./crypto.js\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nlet locked = false;\n\nconst _pbkdf2 = function (password, salt, iterations, keylen, algo) {\n  return pbkdf2Sync(password, salt, iterations, keylen, algo);\n};\n\nlet __pbkdf2 = _pbkdf2;\n/**\n *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using\n *  the %%salt%% and using %%iterations%% of %%algo%%.\n *\n *  This PBKDF is outdated and should not be used in new projects, but is\n *  required to decrypt older files.\n *\n *  @example:\n *    // The password must be converted to bytes, and it is generally\n *    // best practices to ensure the string has been normalized. Many\n *    // formats explicitly indicate the normalization form to use.\n *    password = \"hello\"\n *    passwordBytes = toUtf8Bytes(password, \"NFKC\")\n *\n *    salt = id(\"some-salt\")\n *\n *    // Compute the PBKDF2\n *    pbkdf2(passwordBytes, salt, 1024, 16, \"sha256\")\n *    //_result:\n */\n\nexport function pbkdf2(_password, _salt, iterations, keylen, algo) {\n  const password = getBytes(_password, \"password\");\n  const salt = getBytes(_salt, \"salt\");\n  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));\n}\npbkdf2._ = _pbkdf2;\n\npbkdf2.lock = function () {\n  locked = true;\n};\n\npbkdf2.register = function (func) {\n  if (locked) {\n    throw new Error(\"pbkdf2 is locked\");\n  }\n\n  __pbkdf2 = func;\n};\n\nObject.freeze(pbkdf2);","map":{"version":3,"mappings":"AAAA;;;;;;;AAQA,SAASA,UAAT,QAA2B,aAA3B;AAEA,SAASC,QAAT,EAAmBC,OAAnB,QAAkC,mBAAlC;AAKA,IAAIC,MAAM,GAAG,KAAb;;AAEA,MAAMC,OAAO,GAAG,UAASC,QAAT,EAA+BC,IAA/B,EAAiDC,UAAjD,EAAqEC,MAArE,EAAqFC,IAArF,EAA8G;AAC1H,SAAOT,UAAU,CAACK,QAAD,EAAWC,IAAX,EAAiBC,UAAjB,EAA6BC,MAA7B,EAAqCC,IAArC,CAAjB;AACH,CAFD;;AAIA,IAAIC,QAAQ,GAAGN,OAAf;AAEA;;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUO,MAAV,CAAiBC,SAAjB,EAAuCC,KAAvC,EAAyDN,UAAzD,EAA6EC,MAA7E,EAA6FC,IAA7F,EAAsH;AACxH,QAAMJ,QAAQ,GAAGJ,QAAQ,CAACW,SAAD,EAAY,UAAZ,CAAzB;AACA,QAAMN,IAAI,GAAGL,QAAQ,CAACY,KAAD,EAAQ,MAAR,CAArB;AACA,SAAOX,OAAO,CAACQ,QAAQ,CAACL,QAAD,EAAWC,IAAX,EAAiBC,UAAjB,EAA6BC,MAA7B,EAAqCC,IAArC,CAAT,CAAd;AACH;AACDE,MAAM,CAACG,CAAP,GAAWV,OAAX;;AACAO,MAAM,CAACI,IAAP,GAAc;AAAmBZ,QAAM,GAAG,IAAT;AAAgB,CAAjD;;AACAQ,MAAM,CAACK,QAAP,GAAkB,UAASC,IAAT,EAAmI;AACjJ,MAAId,MAAJ,EAAY;AAAE,UAAM,IAAIe,KAAJ,CAAU,kBAAV,CAAN;AAAsC;;AACpDR,UAAQ,GAAGO,IAAX;AACH,CAHD;;AAIAE,MAAM,CAACC,MAAP,CAAcT,MAAd","names":["pbkdf2Sync","getBytes","hexlify","locked","_pbkdf2","password","salt","iterations","keylen","algo","__pbkdf2","pbkdf2","_password","_salt","_","lock","register","func","Error","Object","freeze"],"sourceRoot":"","sources":["../../src.ts/crypto/pbkdf2.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}