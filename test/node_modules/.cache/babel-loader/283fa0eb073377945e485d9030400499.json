{"ast":null,"code":"/**\n *  About JSON-RPC...\n *\n * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]\n */\n// @TODO:\n// - Add the batching API\n// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false\nimport { AbiCoder } from \"../abi/index.js\";\nimport { getAddress, resolveAddress } from \"../address/index.js\";\nimport { TypedDataEncoder } from \"../hash/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nimport { defineProperties, getBigInt, hexlify, isHexString, toQuantity, toUtf8Bytes, makeError, assert, assertArgument, FetchRequest, resolveProperties } from \"../utils/index.js\";\nimport { AbstractProvider, UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { AbstractSigner } from \"./abstract-signer.js\";\nimport { Network } from \"./network.js\";\nimport { FilterIdEventSubscriber, FilterIdPendingSubscriber } from \"./subscriber-filterid.js\";\nconst Primitive = \"bigint,boolean,function,number,string,symbol\".split(/,/g); //const Methods = \"getAddress,then\".split(/,/g);\n\nfunction deepCopy(value) {\n  if (value == null || Primitive.indexOf(typeof value) >= 0) {\n    return value;\n  } // Keep any Addressable\n\n\n  if (typeof value.getAddress === \"function\") {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(deepCopy);\n  }\n\n  if (typeof value === \"object\") {\n    return Object.keys(value).reduce((accum, key) => {\n      accum[key] = value[key];\n      return accum;\n    }, {});\n  }\n\n  throw new Error(`should not happen: ${value} (${typeof value})`);\n}\n\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\n\nfunction getLowerCase(value) {\n  if (value) {\n    return value.toLowerCase();\n  }\n\n  return value;\n}\n\nfunction isPollable(value) {\n  return value && typeof value.pollingInterval === \"number\";\n}\n\nconst defaultOptions = {\n  polling: false,\n  staticNetwork: null,\n  batchStallTime: 10,\n  batchMaxSize: 1 << 20,\n  batchMaxCount: 100 // 100 requests\n\n}; // @TODO: Unchecked Signers\n\nexport class JsonRpcSigner extends AbstractSigner {\n  address;\n\n  constructor(provider, address) {\n    super(provider);\n    defineProperties(this, {\n      address\n    });\n  }\n\n  connect(provider) {\n    assert(false, \"cannot reconnect JsonRpcSigner\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"signer.connect\"\n    });\n  }\n\n  async getAddress() {\n    return this.address;\n  } // JSON-RPC will automatially fill in nonce, etc. so we just check from\n\n\n  async populateTransaction(tx) {\n    return await this.populateCall(tx);\n  } // Returns just the hash of the transaction after sent, which is what\n  // the bare JSON-RPC API does;\n\n\n  async sendUncheckedTransaction(_tx) {\n    const tx = deepCopy(_tx);\n    const promises = []; // Make sure the from matches the sender\n\n    if (tx.from) {\n      const _from = tx.from;\n      promises.push((async () => {\n        const from = await resolveAddress(_from, this.provider);\n        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n        tx.from = from;\n      })());\n    } else {\n      tx.from = this.address;\n    } // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n    // wishes to use this, it is easy to specify explicitly, otherwise\n    // we look it up for them.\n\n\n    if (tx.gasLimit == null) {\n      promises.push((async () => {\n        tx.gasLimit = await this.provider.estimateGas({ ...tx,\n          from: this.address\n        });\n      })());\n    } // The address may be an ENS name or Addressable\n\n\n    if (tx.to != null) {\n      const _to = tx.to;\n      promises.push((async () => {\n        tx.to = await resolveAddress(_to, this.provider);\n      })());\n    } // Wait until all of our properties are filled in\n\n\n    if (promises.length) {\n      await Promise.all(promises);\n    }\n\n    const hexTx = this.provider.getRpcTransaction(tx);\n    return this.provider.send(\"eth_sendTransaction\", [hexTx]);\n  }\n\n  async sendTransaction(tx) {\n    // This cannot be mined any earlier than any recent block\n    const blockNumber = await this.provider.getBlockNumber(); // Send the transaction\n\n    const hash = await this.sendUncheckedTransaction(tx); // Unfortunately, JSON-RPC only provides and opaque transaction hash\n    // for a response, and we need the actual transaction, so we poll\n    // for it; it should show up very quickly\n\n    return await new Promise((resolve, reject) => {\n      const timeouts = [1000, 100];\n\n      const checkTx = async () => {\n        // Try getting the transaction\n        const tx = await this.provider.getTransaction(hash);\n\n        if (tx != null) {\n          resolve(tx.replaceableTransaction(blockNumber));\n          return;\n        } // Wait another 4 seconds\n\n\n        this.provider._setTimeout(() => {\n          checkTx();\n        }, timeouts.pop() || 4000);\n      };\n\n      checkTx();\n    });\n  }\n\n  async signTransaction(_tx) {\n    const tx = deepCopy(_tx); // Make sure the from matches the sender\n\n    if (tx.from) {\n      const from = await resolveAddress(tx.from, this.provider);\n      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), \"from address mismatch\", \"transaction\", _tx);\n      tx.from = from;\n    } else {\n      tx.from = this.address;\n    }\n\n    const hexTx = this.provider.getRpcTransaction(tx);\n    return await this.provider.send(\"eth_signTransaction\", [hexTx]);\n  }\n\n  async signMessage(_message) {\n    const message = typeof _message === \"string\" ? toUtf8Bytes(_message) : _message;\n    return await this.provider.send(\"personal_sign\", [hexlify(message), this.address.toLowerCase()]);\n  }\n\n  async signTypedData(domain, types, _value) {\n    const value = deepCopy(_value); // Populate any ENS names (in-place)\n\n    const populated = await TypedDataEncoder.resolveNames(domain, types, value, async value => {\n      const address = await resolveAddress(value);\n      assertArgument(address != null, \"TypedData does not support null address\", \"value\", value);\n      return address;\n    });\n    return await this.provider.send(\"eth_signTypedData_v4\", [this.address.toLowerCase(), JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);\n  }\n\n  async unlock(password) {\n    return this.provider.send(\"personal_unlockAccount\", [this.address.toLowerCase(), password, null]);\n  } // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n\n\n  async _legacySignMessage(_message) {\n    const message = typeof _message === \"string\" ? toUtf8Bytes(_message) : _message;\n    return await this.provider.send(\"eth_sign\", [this.address.toLowerCase(), hexlify(message)]);\n  }\n\n}\n/**\n *  The JsonRpcApiProvider is an abstract class and **MUST** be\n *  sub-classed.\n *\n *  It provides the base for all JSON-RPC-based Provider interaction.\n *\n *  Sub-classing Notes:\n *  - a sub-class MUST override _send\n *  - a sub-class MUST call the `_start()` method once connected\n */\n\nexport class JsonRpcApiProvider extends AbstractProvider {\n  #options; // The next ID to use for the JSON-RPC ID field\n\n  #nextId; // Payloads are queued and triggered in batches using the drainTimer\n\n  #payloads;\n  #drainTimer;\n  #notReady;\n  #network;\n\n  #scheduleDrain() {\n    if (this.#drainTimer) {\n      return;\n    } // If we aren't using batching, no hard in sending it immeidately\n\n\n    const stallTime = this._getOption(\"batchMaxCount\") === 1 ? 0 : this._getOption(\"batchStallTime\");\n    this.#drainTimer = setTimeout(() => {\n      this.#drainTimer = null;\n      const payloads = this.#payloads;\n      this.#payloads = [];\n\n      while (payloads.length) {\n        // Create payload batches that satisfy our batch constraints\n        const batch = [payloads.shift()];\n\n        while (payloads.length) {\n          if (batch.length === this.#options.batchMaxCount) {\n            break;\n          }\n\n          batch.push(payloads.shift());\n          const bytes = JSON.stringify(batch.map(p => p.payload));\n\n          if (bytes.length > this.#options.batchMaxSize) {\n            payloads.unshift(batch.pop());\n            break;\n          }\n        } // Process the result to each payload\n\n\n        (async () => {\n          const payload = batch.length === 1 ? batch[0].payload : batch.map(p => p.payload);\n          this.emit(\"debug\", {\n            action: \"sendRpcPayload\",\n            payload\n          });\n\n          try {\n            const result = await this._send(payload);\n            this.emit(\"debug\", {\n              action: \"receiveRpcResult\",\n              result\n            }); // Process results in batch order\n\n            for (const {\n              resolve,\n              reject,\n              payload\n            } of batch) {\n              // Find the matching result\n              const resp = result.filter(r => r.id === payload.id)[0]; // No result; the node failed us in unexpected ways\n\n              if (resp == null) {\n                return reject(new Error(\"@TODO: no result\"));\n              } // The response is an error\n\n\n              if (\"error\" in resp) {\n                return reject(this.getRpcError(payload, resp));\n              } // All good; send the result\n\n\n              resolve(resp.result);\n            }\n          } catch (error) {\n            this.emit(\"debug\", {\n              action: \"receiveRpcError\",\n              error\n            });\n\n            for (const {\n              reject\n            } of batch) {\n              // @TODO: augment the error with the payload\n              reject(error);\n            }\n          }\n        })();\n      }\n    }, stallTime);\n  }\n\n  constructor(network, options) {\n    super(network);\n    this.#nextId = 1;\n    this.#options = Object.assign({}, defaultOptions, options || {});\n    this.#payloads = [];\n    this.#drainTimer = null;\n    this.#network = null;\n    {\n      let resolve = null;\n      const promise = new Promise(_resolve => {\n        resolve = _resolve;\n      });\n      this.#notReady = {\n        promise,\n        resolve\n      };\n    } // This could be relaxed in the future to just check equivalent networks\n\n    const staticNetwork = this._getOption(\"staticNetwork\");\n\n    if (staticNetwork) {\n      assertArgument(staticNetwork === network, \"staticNetwork MUST match network object\", \"options\", options);\n      this.#network = staticNetwork;\n    }\n  }\n  /**\n   *  Returns the value associated with the option %%key%%.\n   *\n   *  Sub-classes can use this to inquire about configuration options.\n   */\n\n\n  _getOption(key) {\n    return this.#options[key];\n  }\n  /**\n   *  Gets the [[Network]] this provider has committed to. On each call, the network\n   *  is detected, and if it has changed, the call will reject.\n   */\n\n\n  get _network() {\n    assert(this.#network, \"network is not available yet\", \"NETWORK_ERROR\");\n    return this.#network;\n  }\n  /*\n   {\n      assert(false, \"sub-classes must override _send\", \"UNSUPPORTED_OPERATION\", {\n          operation: \"jsonRpcApiProvider._send\"\n      });\n  }\n  */\n\n  /**\n   *  Resolves to the non-normalized value by performing %%req%%.\n   *\n   *  Sub-classes may override this to modify behavior of actions,\n   *  and should generally call ``super._perform`` as a fallback.\n   */\n\n\n  async _perform(req) {\n    // Legacy networks do not like the type field being passed along (which\n    // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n    if (req.method === \"call\" || req.method === \"estimateGas\") {\n      let tx = req.transaction;\n\n      if (tx && tx.type != null && getBigInt(tx.type)) {\n        // If there are no EIP-1559 properties, it might be non-EIP-a559\n        if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n          const feeData = await this.getFeeData();\n\n          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n            // Network doesn't know about EIP-1559 (and hence type)\n            req = Object.assign({}, req, {\n              transaction: Object.assign({}, tx, {\n                type: undefined\n              })\n            });\n          }\n        }\n      }\n    }\n\n    const request = this.getRpcRequest(req);\n\n    if (request != null) {\n      return await this.send(request.method, request.args);\n    }\n\n    return super._perform(req);\n  }\n  /**\n   *  Sub-classes may override this; it detects the *actual* network that\n   *  we are **currently** connected to.\n   *\n   *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the\n   *  _send primitive must be used instead.\n   */\n\n\n  async _detectNetwork() {\n    const network = this._getOption(\"staticNetwork\");\n\n    if (network) {\n      return network;\n    } // If we are ready, use ``send``, which enabled requests to be batched\n\n\n    if (this.ready) {\n      return Network.from(getBigInt(await this.send(\"eth_chainId\", [])));\n    } // We are not ready yet; use the primitive _send\n\n\n    const payload = {\n      id: this.#nextId++,\n      method: \"eth_chainId\",\n      params: [],\n      jsonrpc: \"2.0\"\n    };\n    this.emit(\"debug\", {\n      action: \"sendRpcPayload\",\n      payload\n    });\n    let result;\n\n    try {\n      result = (await this._send(payload))[0];\n    } catch (error) {\n      this.emit(\"debug\", {\n        action: \"receiveRpcError\",\n        error\n      });\n      throw error;\n    }\n\n    this.emit(\"debug\", {\n      action: \"receiveRpcResult\",\n      result\n    });\n\n    if (\"result\" in result) {\n      return Network.from(getBigInt(result.result));\n    }\n\n    throw this.getRpcError(payload, result);\n  }\n  /**\n   *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls\n   *  will be passed to [[_send]] from [[send]]. If it is overridden, then\n   *  ``super._start()`` **MUST** be called.\n   *\n   *  Calling it multiple times is safe and has no effect.\n   */\n\n\n  _start() {\n    if (this.#notReady == null || this.#notReady.resolve == null) {\n      return;\n    }\n\n    this.#notReady.resolve();\n    this.#notReady = null;\n\n    (async () => {\n      // Bootstrap the network\n      while (this.#network == null) {\n        try {\n          this.#network = await this._detectNetwork();\n        } catch (error) {\n          console.log(\"JsonRpcProvider failed to startup; retry in 1s\");\n          await stall(1000);\n        }\n      } // Start dispatching requests\n\n\n      this.#scheduleDrain();\n    })();\n  }\n  /**\n   *  Resolves once the [[_start]] has been called. This can be used in\n   *  sub-classes to defer sending data until the connection has been\n   *  established.\n   */\n\n\n  async _waitUntilReady() {\n    if (this.#notReady == null) {\n      return;\n    }\n\n    return await this.#notReady.promise;\n  }\n  /**\n   *  Return a Subscriber that will manage the %%sub%%.\n   *\n   *  Sub-classes may override this to modify the behavior of\n   *  subscription management.\n   */\n\n\n  _getSubscriber(sub) {\n    // Pending Filters aren't availble via polling\n    if (sub.type === \"pending\") {\n      return new FilterIdPendingSubscriber(this);\n    }\n\n    if (sub.type === \"event\") {\n      return new FilterIdEventSubscriber(this, sub.filter);\n    } // Orphaned Logs are handled automatically, by the filter, since\n    // logs with removed are emitted by it\n\n\n    if (sub.type === \"orphan\" && sub.filter.orphan === \"drop-log\") {\n      return new UnmanagedSubscriber(\"orphan\");\n    }\n\n    return super._getSubscriber(sub);\n  }\n  /**\n   *  Returns true only if the [[_start]] has been called.\n   */\n\n\n  get ready() {\n    return this.#notReady == null;\n  }\n  /**\n   *  Returns %%tx%% as a normalized JSON-RPC transaction request,\n   *  which has all values hexlified and any numeric values converted\n   *  to Quantity values.\n   */\n\n\n  getRpcTransaction(tx) {\n    const result = {}; // JSON-RPC now requires numeric values to be \"quantity\" values\n\n    [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n\n      let dstKey = key;\n\n      if (key === \"gasLimit\") {\n        dstKey = \"gas\";\n      }\n\n      result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));\n    }); // Make sure addresses and data are lowercase\n\n    [\"from\", \"to\", \"data\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n\n      result[key] = hexlify(tx[key]);\n    }); // Normalize the access list object\n\n    if (tx.accessList) {\n      result[\"accessList\"] = accessListify(tx.accessList);\n    }\n\n    return result;\n  }\n  /**\n   *  Returns the request method and arguments required to perform\n   *  %%req%%.\n   */\n\n\n  getRpcRequest(req) {\n    switch (req.method) {\n      case \"chainId\":\n        return {\n          method: \"eth_chainId\",\n          args: []\n        };\n\n      case \"getBlockNumber\":\n        return {\n          method: \"eth_blockNumber\",\n          args: []\n        };\n\n      case \"getGasPrice\":\n        return {\n          method: \"eth_gasPrice\",\n          args: []\n        };\n\n      case \"getBalance\":\n        return {\n          method: \"eth_getBalance\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n\n      case \"getTransactionCount\":\n        return {\n          method: \"eth_getTransactionCount\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n\n      case \"getCode\":\n        return {\n          method: \"eth_getCode\",\n          args: [getLowerCase(req.address), req.blockTag]\n        };\n\n      case \"getStorage\":\n        return {\n          method: \"eth_getStorageAt\",\n          args: [getLowerCase(req.address), \"0x\" + req.position.toString(16), req.blockTag]\n        };\n\n      case \"broadcastTransaction\":\n        return {\n          method: \"eth_sendRawTransaction\",\n          args: [req.signedTransaction]\n        };\n\n      case \"getBlock\":\n        if (\"blockTag\" in req) {\n          return {\n            method: \"eth_getBlockByNumber\",\n            args: [req.blockTag, !!req.includeTransactions]\n          };\n        } else if (\"blockHash\" in req) {\n          return {\n            method: \"eth_getBlockByHash\",\n            args: [req.blockHash, !!req.includeTransactions]\n          };\n        }\n\n        break;\n\n      case \"getTransaction\":\n        return {\n          method: \"eth_getTransactionByHash\",\n          args: [req.hash]\n        };\n\n      case \"getTransactionReceipt\":\n        return {\n          method: \"eth_getTransactionReceipt\",\n          args: [req.hash]\n        };\n\n      case \"call\":\n        return {\n          method: \"eth_call\",\n          args: [this.getRpcTransaction(req.transaction), req.blockTag]\n        };\n\n      case \"estimateGas\":\n        {\n          return {\n            method: \"eth_estimateGas\",\n            args: [this.getRpcTransaction(req.transaction)]\n          };\n        }\n\n      case \"getLogs\":\n        if (req.filter && req.filter.address != null) {\n          if (Array.isArray(req.filter.address)) {\n            req.filter.address = req.filter.address.map(getLowerCase);\n          } else {\n            req.filter.address = getLowerCase(req.filter.address);\n          }\n        }\n\n        return {\n          method: \"eth_getLogs\",\n          args: [req.filter]\n        };\n    }\n\n    return null;\n  }\n  /**\n   *  Returns an ethers-style Error for the given JSON-RPC error\n   *  %%payload%%, coalescing the various strings and error shapes\n   *  that different nodes return, coercing them into a machine-readable\n   *  standardized error.\n   */\n\n\n  getRpcError(payload, _error) {\n    const {\n      method\n    } = payload;\n    const {\n      error\n    } = _error;\n\n    if (method === \"eth_estimateGas\" && error.message) {\n      const msg = error.message;\n\n      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {\n        return makeError(\"insufficient funds\", \"INSUFFICIENT_FUNDS\", {\n          transaction: payload.params[0]\n        });\n      }\n    }\n\n    if (method === \"eth_call\" || method === \"eth_estimateGas\") {\n      const result = spelunkData(error);\n      const e = AbiCoder.getBuiltinCallException(method === \"eth_call\" ? \"call\" : \"estimateGas\", payload.params[0], result ? result.data : null);\n      e.info = {\n        error,\n        payload\n      };\n      return e;\n      /*\n                  let message = \"missing revert data during JSON-RPC call\";\n      \n                  const action = <\"call\" | \"estimateGas\" | \"unknown\">(({ eth_call: \"call\", eth_estimateGas: \"estimateGas\" })[method] || \"unknown\");\n                  let data: null | string = null;\n                  let reason: null | string = null;\n                  const transaction = <{ from: string, to: string, data: string }>((<any>payload).params[0]);\n                  const invocation = null;\n                  let revert: null | { signature: string, name: string, args: Array<any> } = null;\n      \n                  if (result) {\n                      // @TODO: Extract errorSignature, errorName, errorArgs, reason if\n                      //        it is Error(string) or Panic(uint25)\n                      message = \"execution reverted during JSON-RPC call\";\n                      data = result.data;\n      \n                      let bytes = getBytes(data);\n                      if (bytes.length % 32 !== 4) {\n                          message += \" (could not parse reason; invalid data length)\";\n      \n                      } else if (data.substring(0, 10) === \"0x08c379a0\") {\n                          // Error(string)\n                          try {\n                              if (bytes.length < 68) { throw new Error(\"bad length\"); }\n                              bytes = bytes.slice(4);\n                              const pointer = getNumber(hexlify(bytes.slice(0, 32)));\n                              bytes = bytes.slice(pointer);\n                              if (bytes.length < 32) { throw new Error(\"overrun\"); }\n                              const length = getNumber(hexlify(bytes.slice(0, 32)));\n                              bytes = bytes.slice(32);\n                              if (bytes.length < length) { throw new Error(\"overrun\"); }\n                              reason = toUtf8String(bytes.slice(0, length));\n                              revert = {\n                                  signature: \"Error(string)\",\n                                  name: \"Error\",\n                                  args: [ reason ]\n                              };\n                              message += `: ${ JSON.stringify(reason) }`;\n      \n                          } catch (error) {\n                              console.log(error);\n                              message += \" (could not parse reason; invalid data length)\";\n                          }\n      \n                      } else if (data.substring(0, 10) === \"0x4e487b71\") {\n                          // Panic(uint256)\n                          try {\n                              if (bytes.length !== 36) { throw new Error(\"bad length\"); }\n                              const arg = getNumber(hexlify(bytes.slice(4)));\n                              revert = {\n                                  signature: \"Panic(uint256)\",\n                                  name: \"Panic\",\n                                  args: [ arg ]\n                              };\n                              reason = `Panic due to ${ PanicReasons.get(Number(arg)) || \"UNKNOWN\" }(${ arg })`;\n                              message += `: ${ reason }`;\n                          } catch (error) {\n                              console.log(error);\n                              message += \" (could not parse panic reason)\";\n                          }\n                      }\n                  }\n      \n                  return makeError(message, \"CALL_EXCEPTION\", {\n                      action, data, reason, transaction, invocation, revert,\n                      info: { payload, error }\n                  });\n                  */\n    } // Only estimateGas and call can return arbitrary contract-defined text, so now we\n    // we can process text safely.\n\n\n    const message = JSON.stringify(spelunkMessage(error));\n\n    if (typeof error.message === \"string\" && error.message.match(/user denied|ethers-user-denied/i)) {\n      const actionMap = {\n        eth_sign: \"signMessage\",\n        personal_sign: \"signMessage\",\n        eth_signTypedData_v4: \"signTypedData\",\n        eth_signTransaction: \"signTransaction\",\n        eth_sendTransaction: \"sendTransaction\",\n        eth_requestAccounts: \"requestAccess\",\n        wallet_requestAccounts: \"requestAccess\"\n      };\n      return makeError(`user rejected action`, \"ACTION_REJECTED\", {\n        action: actionMap[method] || \"unknown\",\n        reason: \"rejected\",\n        info: {\n          payload,\n          error\n        }\n      });\n    }\n\n    if (method === \"eth_sendRawTransaction\" || method === \"eth_sendTransaction\") {\n      const transaction = payload.params[0];\n\n      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {\n        return makeError(\"insufficient funds for intrinsic transaction cost\", \"INSUFFICIENT_FUNDS\", {\n          transaction\n        });\n      }\n\n      if (message.match(/nonce/i) && message.match(/too low/i)) {\n        return makeError(\"nonce has already been used\", \"NONCE_EXPIRED\", {\n          transaction\n        });\n      } // \"replacement transaction underpriced\"\n\n\n      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {\n        return makeError(\"replacement fee too low\", \"REPLACEMENT_UNDERPRICED\", {\n          transaction\n        });\n      }\n\n      if (message.match(/only replay-protected/i)) {\n        return makeError(\"legacy pre-eip-155 transactions not supported\", \"UNSUPPORTED_OPERATION\", {\n          operation: method,\n          info: {\n            transaction\n          }\n        });\n      }\n    }\n\n    if (message.match(/the method .* does not exist/i)) {\n      return makeError(\"unsupported operation\", \"UNSUPPORTED_OPERATION\", {\n        operation: payload.method\n      });\n    }\n\n    return makeError(\"could not coalesce error\", \"UNKNOWN_ERROR\", {\n      error\n    });\n  }\n  /**\n   *  Requests the %%method%% with %%params%% via the JSON-RPC protocol\n   *  over the underlying channel. This can be used to call methods\n   *  on the backend that do not have a high-level API within the Provider\n   *  API.\n   *\n   *  This method queues requests according to the batch constraints\n   *  in the options, assigns the request a unique ID.\n   *\n   *  **Do NOT override** this method in sub-classes; instead\n   *  override [[_send]] or force the options values in the\n   *  call to the constructor to modify this method's behavior.\n   */\n\n\n  send(method, params) {\n    // @TODO: cache chainId?? purge on switch_networks\n    const id = this.#nextId++;\n    const promise = new Promise((resolve, reject) => {\n      this.#payloads.push({\n        resolve,\n        reject,\n        payload: {\n          method,\n          params,\n          id,\n          jsonrpc: \"2.0\"\n        }\n      });\n    }); // If there is not a pending drainTimer, set one\n\n    this.#scheduleDrain();\n    return promise;\n  }\n  /**\n   *  Resolves to the [[Signer]] account for  %%address%% managed by\n   *  the client.\n   *\n   *  If the %%address%% is a number, it is used as an index in the\n   *  the accounts from [[listAccounts]].\n   *\n   *  This can only be used on clients which manage accounts (such as\n   *  Geth with imported account or MetaMask).\n   *\n   *  Throws if the account doesn't exist.\n   */\n\n\n  async getSigner(address) {\n    if (address == null) {\n      address = 0;\n    }\n\n    const accountsPromise = this.send(\"eth_accounts\", []); // Account index\n\n    if (typeof address === \"number\") {\n      const accounts = await accountsPromise;\n\n      if (address >= accounts.length) {\n        throw new Error(\"no such account\");\n      }\n\n      return new JsonRpcSigner(this, accounts[address]);\n    }\n\n    const {\n      accounts\n    } = await resolveProperties({\n      network: this.getNetwork(),\n      accounts: accountsPromise\n    }); // Account address\n\n    address = getAddress(address);\n\n    for (const account of accounts) {\n      if (getAddress(account) === account) {\n        return new JsonRpcSigner(this, account);\n      }\n    }\n\n    throw new Error(\"invalid account\");\n  }\n\n}\nexport class JsonRpcApiPollingProvider extends JsonRpcApiProvider {\n  #pollingInterval;\n\n  constructor(network, options) {\n    super(network, options);\n    this.#pollingInterval = 4000;\n  }\n\n  _getSubscriber(sub) {\n    const subscriber = super._getSubscriber(sub);\n\n    if (isPollable(subscriber)) {\n      subscriber.pollingInterval = this.#pollingInterval;\n    }\n\n    return subscriber;\n  }\n  /**\n   *  The polling interval (default: 4000 ms)\n   */\n\n\n  get pollingInterval() {\n    return this.#pollingInterval;\n  }\n\n  set pollingInterval(value) {\n    if (!Number.isInteger(value) || value < 0) {\n      throw new Error(\"invalid interval\");\n    }\n\n    this.#pollingInterval = value;\n\n    this._forEachSubscriber(sub => {\n      if (isPollable(sub)) {\n        sub.pollingInterval = this.#pollingInterval;\n      }\n    });\n  }\n\n}\n/**\n *  The JsonRpcProvider is one of the most common Providers,\n *  which performs all operations over HTTP (or HTTPS) requests.\n *\n *  Events are processed by polling the backend for the current block\n *  number; when it advances, all block-base events are then checked\n *  for updates.\n */\n\nexport class JsonRpcProvider extends JsonRpcApiPollingProvider {\n  #connect;\n\n  constructor(url, network, options) {\n    if (url == null) {\n      url = \"http:/\\/localhost:8545\";\n    }\n\n    super(network, options);\n\n    if (typeof url === \"string\") {\n      this.#connect = new FetchRequest(url);\n    } else {\n      this.#connect = url.clone();\n    }\n  }\n\n  _getConnection() {\n    return this.#connect.clone();\n  }\n\n  async send(method, params) {\n    // All requests are over HTTP, so we can just start handling requests\n    // We do this here rather than the constructor so that we don't send any\n    // requests to the network (i.e. eth_chainId) until we absolutely have to.\n    await this._start();\n    return await super.send(method, params);\n  }\n\n  async _send(payload) {\n    // Configure a POST connection for the requested method\n    const request = this._getConnection();\n\n    request.body = JSON.stringify(payload);\n    request.setHeader(\"content-type\", \"application/json\");\n    const response = await request.send();\n    response.assertOk();\n    let resp = response.bodyJson;\n\n    if (!Array.isArray(resp)) {\n      resp = [resp];\n    }\n\n    return resp;\n  }\n\n}\n\nfunction spelunkData(value) {\n  if (value == null) {\n    return null;\n  } // These *are* the droids we're looking for.\n\n\n  if (typeof value.message === \"string\" && value.message.match(\"reverted\") && isHexString(value.data)) {\n    return {\n      message: value.message,\n      data: value.data\n    };\n  } // Spelunk further...\n\n\n  if (typeof value === \"object\") {\n    for (const key in value) {\n      const result = spelunkData(value[key]);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  } // Might be a JSON string we can further descend...\n\n\n  if (typeof value === \"string\") {\n    try {\n      return spelunkData(JSON.parse(value));\n    } catch (error) {}\n  }\n\n  return null;\n}\n\nfunction _spelunkMessage(value, result) {\n  if (value == null) {\n    return;\n  } // These *are* the droids we're looking for.\n\n\n  if (typeof value.message === \"string\") {\n    result.push(value.message);\n  } // Spelunk further...\n\n\n  if (typeof value === \"object\") {\n    for (const key in value) {\n      _spelunkMessage(value[key], result);\n    }\n  } // Might be a JSON string we can further descend...\n\n\n  if (typeof value === \"string\") {\n    try {\n      return _spelunkMessage(JSON.parse(value), result);\n    } catch (error) {}\n  }\n}\n\nfunction spelunkMessage(value) {\n  const result = [];\n\n  _spelunkMessage(value, result);\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["AbiCoder","getAddress","resolveAddress","TypedDataEncoder","accessListify","defineProperties","getBigInt","hexlify","isHexString","toQuantity","toUtf8Bytes","makeError","assert","assertArgument","FetchRequest","resolveProperties","AbstractProvider","UnmanagedSubscriber","AbstractSigner","Network","FilterIdEventSubscriber","FilterIdPendingSubscriber","Primitive","split","deepCopy","value","indexOf","Array","isArray","map","Object","keys","reduce","accum","key","Error","stall","duration","Promise","resolve","setTimeout","getLowerCase","toLowerCase","isPollable","pollingInterval","defaultOptions","polling","staticNetwork","batchStallTime","batchMaxSize","batchMaxCount","JsonRpcSigner","address","constructor","provider","connect","operation","populateTransaction","tx","populateCall","sendUncheckedTransaction","_tx","promises","from","_from","push","gasLimit","estimateGas","to","_to","length","all","hexTx","getRpcTransaction","send","sendTransaction","blockNumber","getBlockNumber","hash","reject","timeouts","checkTx","getTransaction","replaceableTransaction","_setTimeout","pop","signTransaction","signMessage","_message","message","signTypedData","domain","types","_value","populated","resolveNames","JSON","stringify","getPayload","unlock","password","_legacySignMessage","JsonRpcApiProvider","stallTime","_getOption","payloads","batch","shift","bytes","p","payload","unshift","emit","action","result","_send","resp","filter","r","id","getRpcError","error","network","options","assign","promise","_resolve","_network","_perform","req","method","transaction","type","maxFeePerGas","maxPriorityFeePerGas","feeData","getFeeData","undefined","request","getRpcRequest","args","_detectNetwork","ready","params","jsonrpc","_start","console","log","_waitUntilReady","_getSubscriber","sub","orphan","forEach","dstKey","accessList","blockTag","position","toString","signedTransaction","includeTransactions","blockHash","_error","msg","match","spelunkData","e","getBuiltinCallException","data","info","spelunkMessage","actionMap","eth_sign","personal_sign","eth_signTypedData_v4","eth_signTransaction","eth_sendTransaction","eth_requestAccounts","wallet_requestAccounts","reason","getSigner","accountsPromise","accounts","getNetwork","account","JsonRpcApiPollingProvider","subscriber","Number","isInteger","_forEachSubscriber","JsonRpcProvider","url","clone","_getConnection","body","setHeader","response","assertOk","bodyJson","parse","_spelunkMessage"],"sourceRoot":"","sources":["../../src.ts/providers/provider-jsonrpc.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}