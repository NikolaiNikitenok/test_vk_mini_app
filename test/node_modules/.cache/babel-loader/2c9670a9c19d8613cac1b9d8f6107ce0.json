{"ast":null,"code":"import { assert, assertArgument } from \"../utils/index.js\";\nimport { getAddress } from \"./address.js\";\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\n\nexport function isAddressable(value) {\n  return value && typeof value.getAddress === \"function\";\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\n\nexport function isAddress(value) {\n  try {\n    getAddress(value);\n    return true;\n  } catch (error) {}\n\n  return false;\n}\n\nasync function checkAddress(target, promise) {\n  const result = await promise;\n\n  if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n    assert(typeof target !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", {\n      value: target\n    });\n    assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n  }\n\n  return getAddress(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\n\n\nexport function resolveAddress(target, resolver) {\n  if (typeof target === \"string\") {\n    if (target.match(/^0x[0-9a-f]{40}$/i)) {\n      return getAddress(target);\n    }\n\n    assert(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"resolveName\"\n    });\n    return checkAddress(target, resolver.resolveName(target));\n  } else if (isAddressable(target)) {\n    return checkAddress(target, target.getAddress());\n  } else if (target && typeof target.then === \"function\") {\n    return checkAddress(target, target);\n  }\n\n  assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}","map":{"version":3,"mappings":"AAAA,SAASA,MAAT,EAAiBC,cAAjB,QAAuC,mBAAvC;AAEA,SAASC,UAAT,QAA2B,cAA3B;AAKA;;;;;;;;;;;;;;;AAcA,OAAM,SAAUC,aAAV,CAAwBC,KAAxB,EAAkC;AACpC,SAAQA,KAAK,IAAI,OAAOA,KAAK,CAACF,UAAb,KAA6B,UAA9C;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAUG,SAAV,CAAoBD,KAApB,EAA8B;AAChC,MAAI;AACAF,cAAU,CAACE,KAAD,CAAV;AACA,WAAO,IAAP;AACH,GAHD,CAGE,OAAOE,KAAP,EAAc,CAAG;;AACnB,SAAO,KAAP;AACH;;AAED,eAAeC,YAAf,CAA4BC,MAA5B,EAAyCC,OAAzC,EAAwE;AACpE,QAAMC,MAAM,GAAG,MAAMD,OAArB;;AACA,MAAIC,MAAM,IAAI,IAAV,IAAkBA,MAAM,KAAK,4CAAjC,EAA+E;AAC3EV,UAAM,CAAC,OAAOQ,MAAP,KAAmB,QAApB,EAA8B,mBAA9B,EAAmD,mBAAnD,EAAwE;AAAEJ,WAAK,EAAEI;AAAT,KAAxE,CAAN;AACAP,kBAAc,CAAC,KAAD,EAAQ,+DAAR,EAAyE,QAAzE,EAAmFO,MAAnF,CAAd;AACH;;AACD,SAAON,UAAU,CAACQ,MAAD,CAAjB;AACH;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,OAAM,SAAUC,cAAV,CAAyBH,MAAzB,EAA8CI,QAA9C,EAA4E;AAE9E,MAAI,OAAOJ,MAAP,KAAmB,QAAvB,EAAiC;AAC7B,QAAIA,MAAM,CAACK,KAAP,CAAa,mBAAb,CAAJ,EAAuC;AAAE,aAAOX,UAAU,CAACM,MAAD,CAAjB;AAA4B;;AAErER,UAAM,CAACY,QAAQ,IAAI,IAAb,EAAmB,oCAAnB,EACF,uBADE,EACuB;AAAEE,eAAS,EAAE;AAAb,KADvB,CAAN;AAGA,WAAOP,YAAY,CAACC,MAAD,EAASI,QAAQ,CAACG,WAAT,CAAqBP,MAArB,CAAT,CAAnB;AAEH,GARD,MAQO,IAAIL,aAAa,CAACK,MAAD,CAAjB,EAA2B;AAC9B,WAAOD,YAAY,CAACC,MAAD,EAASA,MAAM,CAACN,UAAP,EAAT,CAAnB;AAEH,GAHM,MAGA,IAAIM,MAAM,IAAI,OAAOA,MAAM,CAACQ,IAAd,KAAwB,UAAtC,EAAkD;AACrD,WAAOT,YAAY,CAACC,MAAD,EAASA,MAAT,CAAnB;AACH;;AAEDP,gBAAc,CAAC,KAAD,EAAQ,+BAAR,EAAyC,QAAzC,EAAmDO,MAAnD,CAAd;AACH","names":["assert","assertArgument","getAddress","isAddressable","value","isAddress","error","checkAddress","target","promise","result","resolveAddress","resolver","match","operation","resolveName","then"],"sourceRoot":"","sources":["../../src.ts/address/checks.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}