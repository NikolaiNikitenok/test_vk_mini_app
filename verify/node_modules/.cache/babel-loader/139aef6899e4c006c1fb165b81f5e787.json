{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"children\", \"slideWidth\", \"slideIndex\", \"isDraggable\", \"onDragStart\", \"onDragEnd\", \"onChange\", \"onEnd\", \"align\", \"bullets\", \"platform\", \"hasMouse\", \"showArrows\", \"window\", \"document\", \"getRef\", \"getRootRef\"],\n    _excluded2 = [\"initialSlideIndex\", \"children\", \"timeout\", \"onChange\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from \"react\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { Touch } from \"../Touch/Touch\";\nimport { classNames } from \"../../lib/classNames\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { withDOM } from \"../../lib/dom\";\nimport { setRef } from \"../../lib/utils\";\nimport { withAdaptivity } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"../HorizontalScroll/HorizontalScrollArrow\";\nimport { clamp } from \"../../helpers/math\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\n\nvar BaseGallery = /*#__PURE__*/function (_React$Component) {\n  _inherits(BaseGallery, _React$Component);\n\n  var _super = _createSuper(BaseGallery);\n\n  function BaseGallery(props) {\n    var _this;\n\n    _classCallCheck(this, BaseGallery);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"container\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"slidesStore\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"viewport\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"onStart\", function () {\n      _this.setState({\n        animation: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onMoveX\", function (e) {\n      if (_this.props.isDraggable && !_this.isFullyVisible) {\n        e.originalEvent.preventDefault();\n\n        if (e.isSlideX) {\n          _this.props.onDragStart && _this.props.onDragStart(e);\n\n          if (_this.state.deltaX !== e.shiftX || _this.state.dragging !== e.isSlideX) {\n            _this.setState({\n              deltaX: e.shiftX,\n              dragging: e.isSlideX\n            });\n          }\n        }\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onEnd\", function (e) {\n      var _this$props$slideInde;\n\n      var targetIndex = e.isSlide ? _this.getTarget(e) : (_this$props$slideInde = _this.props.slideIndex) !== null && _this$props$slideInde !== void 0 ? _this$props$slideInde : 0;\n      _this.props.onDragEnd && _this.props.onDragEnd(e);\n\n      _this.setState({\n        deltaX: 0,\n        animation: true\n      }, function () {\n        var _this$props$onChange, _this$props;\n\n        return (_this$props$onChange = (_this$props = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props, targetIndex);\n      });\n\n      if (_this.props.onEnd) {\n        _this.props.onEnd({\n          targetIndex: targetIndex\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onResize\", function () {\n      return _this.initializeSlides({\n        animation: false\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"slideLeft\", function () {\n      var _this$props2 = _this.props,\n          _this$props2$slideInd = _this$props2.slideIndex,\n          slideIndex = _this$props2$slideInd === void 0 ? 0 : _this$props2$slideInd,\n          onChange = _this$props2.onChange;\n\n      if (_this.canSlideLeft) {\n        _this.setState({\n          deltaX: 0,\n          animation: true\n        }, function () {\n          return onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex - 1);\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"slideRight\", function () {\n      var _this$props3 = _this.props,\n          _this$props3$slideInd = _this$props3.slideIndex,\n          slideIndex = _this$props3$slideInd === void 0 ? 0 : _this$props3$slideInd,\n          onChange = _this$props3.onChange;\n\n      if (_this.canSlideRight) {\n        _this.setState({\n          deltaX: 0,\n          animation: true\n        }, function () {\n          return onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex + 1);\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getSlideRef\", function (id) {\n      return function (slide) {\n        _this.slidesStore[\"slide-\".concat(id)] = slide;\n      };\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getViewportRef\", function (viewport) {\n      _this.viewport = viewport;\n\n      if (_this.props.getRef) {\n        setRef(viewport, _this.props.getRef);\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getRootRef\", function (container) {\n      _this.container = container;\n\n      if (_this.props.getRootRef) {\n        setRef(container, _this.props.getRootRef);\n      }\n    });\n\n    _this.state = {\n      containerWidth: 0,\n      deltaX: 0,\n      shiftX: 0,\n      slides: [],\n      animation: true,\n      duration: 0.24\n    };\n    _this.slidesStore = {};\n    return _this;\n  }\n\n  _createClass(BaseGallery, [{\n    key: \"isCenterWithCustomWidth\",\n    get: function get() {\n      return this.props.slideWidth === \"custom\" && this.props.align === \"center\";\n    }\n  }, {\n    key: \"initializeSlides\",\n    value: function initializeSlides() {\n      var _React$Children$map,\n          _this2 = this,\n          _this$container$offse,\n          _this$container;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var slides = (_React$Children$map = React.Children.map(this.props.children, function (_item, i) {\n        var _elem$offsetLeft, _elem$offsetWidth;\n\n        var elem = _this2.slidesStore[\"slide-\".concat(i)];\n\n        return {\n          coordX: (_elem$offsetLeft = elem === null || elem === void 0 ? void 0 : elem.offsetLeft) !== null && _elem$offsetLeft !== void 0 ? _elem$offsetLeft : 0,\n          width: (_elem$offsetWidth = elem === null || elem === void 0 ? void 0 : elem.offsetWidth) !== null && _elem$offsetWidth !== void 0 ? _elem$offsetWidth : 0\n        };\n      })) !== null && _React$Children$map !== void 0 ? _React$Children$map : [];\n      var containerWidth = (_this$container$offse = (_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.offsetWidth) !== null && _this$container$offse !== void 0 ? _this$container$offse : 0;\n      var layerWidth = slides.reduce(function (val, slide) {\n        return slide.width + val;\n      }, 0);\n      var min = this.calcMin({\n        containerWidth: containerWidth,\n        layerWidth: layerWidth,\n        slides: slides\n      });\n      var max = this.calcMax({\n        slides: slides\n      });\n      this.setState({\n        min: min,\n        max: max,\n        layerWidth: layerWidth,\n        containerWidth: containerWidth,\n        slides: slides\n      }, function () {\n        if (_this2.props.slideIndex !== undefined) {\n          var shiftX = _this2.calculateIndent(_this2.props.slideIndex);\n\n          if (_this2.state.shiftX === shiftX) {\n            return;\n          }\n\n          var isValidShift = _this2.state.shiftX === _this2.validateIndent(_this2.state.shiftX);\n\n          var _options$animation = options.animation,\n              animation = _options$animation === void 0 ? isValidShift : _options$animation;\n\n          _this2.setState({\n            shiftX: shiftX,\n            animation: animation\n          }, function () {\n            if (!_this2.state.animation) {\n              var _this2$props$window;\n\n              (_this2$props$window = _this2.props.window) === null || _this2$props$window === void 0 ? void 0 : _this2$props$window.requestAnimationFrame(function () {\n                return _this2.setState({\n                  animation: true\n                });\n              });\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"calcMin\",\n    value: function calcMin(_ref) {\n      var _this$viewport$offset, _this$viewport;\n\n      var containerWidth = _ref.containerWidth,\n          _ref$layerWidth = _ref.layerWidth,\n          layerWidth = _ref$layerWidth === void 0 ? 0 : _ref$layerWidth,\n          slides = _ref.slides;\n      var viewportWidth = (_this$viewport$offset = (_this$viewport = this.viewport) === null || _this$viewport === void 0 ? void 0 : _this$viewport.offsetWidth) !== null && _this$viewport$offset !== void 0 ? _this$viewport$offset : 0;\n\n      switch (this.props.align) {\n        case \"left\":\n          return containerWidth - layerWidth;\n\n        case \"right\":\n          return viewportWidth - layerWidth;\n\n        case \"center\":\n          if (this.isCenterWithCustomWidth && slides.length) {\n            var _slides = slides[slides.length - 1],\n                coordX = _slides.coordX,\n                width = _slides.width;\n            return viewportWidth / 2 - coordX - width / 2;\n          } else {\n            return viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth;\n          }\n\n      }\n\n      return undefined;\n    }\n  }, {\n    key: \"calcMax\",\n    value: function calcMax(_ref2) {\n      var _this$viewport$offset2, _this$viewport2;\n\n      var slides = _ref2.slides;\n      var viewportWidth = (_this$viewport$offset2 = (_this$viewport2 = this.viewport) === null || _this$viewport2 === void 0 ? void 0 : _this$viewport2.offsetWidth) !== null && _this$viewport$offset2 !== void 0 ? _this$viewport$offset2 : 0;\n\n      if (this.isCenterWithCustomWidth && slides.length) {\n        var _slides$ = slides[0],\n            width = _slides$.width,\n            coordX = _slides$.coordX;\n        return viewportWidth / 2 - coordX - width / 2;\n      } else {\n        return 0;\n      }\n    }\n    /*\n     * Считает отступ слоя галереи\n     */\n\n  }, {\n    key: \"calculateIndent\",\n    value: function calculateIndent(targetIndex) {\n      var slides = this.state.slides;\n\n      if (this.isFullyVisible) {\n        return 0;\n      }\n\n      var targetSlide = slides.length ? slides[targetIndex] : null;\n\n      if (targetSlide) {\n        var coordX = targetSlide.coordX,\n            width = targetSlide.width;\n\n        if (this.isCenterWithCustomWidth) {\n          var _this$viewport$offset3, _this$viewport3;\n\n          var viewportWidth = (_this$viewport$offset3 = (_this$viewport3 = this.viewport) === null || _this$viewport3 === void 0 ? void 0 : _this$viewport3.offsetWidth) !== null && _this$viewport$offset3 !== void 0 ? _this$viewport$offset3 : 0;\n          return viewportWidth / 2 - coordX - width / 2;\n        }\n\n        return this.validateIndent(-1 * coordX);\n      } else {\n        return 0;\n      }\n    }\n    /*\n     * Считает отступ слоя галереи во время драга\n     */\n\n  }, {\n    key: \"calculateDragIndent\",\n    value: function calculateDragIndent() {\n      var _this$state = this.state,\n          shiftX = _this$state.shiftX,\n          deltaX = _this$state.deltaX,\n          _this$state$min = _this$state.min,\n          min = _this$state$min === void 0 ? 0 : _this$state$min,\n          _this$state$max = _this$state.max,\n          max = _this$state$max === void 0 ? 0 : _this$state$max;\n      var indent = shiftX + deltaX;\n\n      if (indent > max) {\n        return max + Number((indent - max) / 3);\n      } else if (indent < min) {\n        return min + Number((indent - min) / 3);\n      }\n\n      return indent;\n    }\n  }, {\n    key: \"validateIndent\",\n    value: function validateIndent(value) {\n      var _this$state2 = this.state,\n          _this$state2$min = _this$state2.min,\n          min = _this$state2$min === void 0 ? 0 : _this$state2$min,\n          _this$state2$max = _this$state2.max,\n          max = _this$state2$max === void 0 ? 0 : _this$state2$max;\n\n      if (value < min) {\n        return min;\n      } else if (value > max) {\n        return max;\n      }\n\n      return value;\n    }\n  }, {\n    key: \"isFullyVisible\",\n    get: function get() {\n      var _this$state$layerWidt;\n\n      return ((_this$state$layerWidt = this.state.layerWidth) !== null && _this$state$layerWidt !== void 0 ? _this$state$layerWidt : 0) <= this.state.containerWidth;\n    }\n    /*\n     * Получает индекс слайда, к которому будет осуществлен переход\n     */\n\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(e) {\n      var _this$state3 = this.state,\n          slides = _this$state3.slides,\n          deltaX = _this$state3.deltaX,\n          shiftX = _this$state3.shiftX,\n          _this$state3$max = _this$state3.max,\n          max = _this$state3$max === void 0 ? 0 : _this$state3$max;\n      var _this$props$slideInde2 = this.props.slideIndex,\n          slideIndex = _this$props$slideInde2 === void 0 ? 0 : _this$props$slideInde2;\n      var expectDeltaX = deltaX / e.duration * 240 * 0.6;\n      var shift = shiftX + deltaX + expectDeltaX - max;\n      var direction = deltaX < 0 ? 1 : -1; // Находим ближайшую границу слайда к текущему отступу\n\n      var targetIndex = slides.reduce(function (val, item, index) {\n        var previousValue = Math.abs(slides[val].coordX + shift);\n        var currentValue = Math.abs(item.coordX + shift);\n        return previousValue < currentValue ? val : index;\n      }, slideIndex);\n\n      if (targetIndex === slideIndex) {\n        var targetSlide = slideIndex + direction;\n\n        if (targetSlide >= 0 && targetSlide < slides.length) {\n          if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {\n            targetIndex = targetSlide;\n          }\n        }\n      }\n\n      return targetIndex;\n    }\n  }, {\n    key: \"canSlideLeft\",\n    get: function get() {\n      // shiftX is negative number <= 0, we can swipe back only if it is < 0\n      return !this.isFullyVisible && this.state.shiftX < 0;\n    }\n  }, {\n    key: \"canSlideRight\",\n    get: function get() {\n      var _this$state4 = this.state,\n          containerWidth = _this$state4.containerWidth,\n          _this$state4$layerWid = _this$state4.layerWidth,\n          layerWidth = _this$state4$layerWid === void 0 ? 0 : _this$state4$layerWid,\n          shiftX = _this$state4.shiftX,\n          slides = _this$state4.slides;\n      var _this$props4 = this.props,\n          align = _this$props4.align,\n          _this$props4$slideInd = _this$props4.slideIndex,\n          slideIndex = _this$props4$slideInd === void 0 ? 0 : _this$props4$slideInd;\n      return !this.isFullyVisible && ( // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      align === \"left\" && containerWidth - shiftX < layerWidth || // otherwise we need to check current slide index (align = right or align = center)\n      align !== \"left\" && slideIndex < slides.length - 1);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.initializeSlides({\n        animation: false\n      });\n      this.props.window.addEventListener(\"resize\", this.onResize);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var widthChanged = this.props.slideWidth !== prevProps.slideWidth;\n      var isPropUpdate = this.props !== prevProps;\n      var slideCountChanged = React.Children.count(this.props.children) !== React.Children.count(prevProps.children);\n      var isCustomWidth = this.props.slideWidth === \"custom\"; // в любом из этих случаев позиция могла поменяться\n\n      if (widthChanged || slideCountChanged || isCustomWidth && isPropUpdate) {\n        this.initializeSlides();\n      } else if (this.props.slideIndex !== prevProps.slideIndex) {\n        var _this$props$slideInde3;\n\n        this.setState({\n          animation: true,\n          deltaX: 0,\n          shiftX: this.calculateIndent((_this$props$slideInde3 = this.props.slideIndex) !== null && _this$props$slideInde3 !== void 0 ? _this$props$slideInde3 : 0)\n        });\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.window.removeEventListener(\"resize\", this.onResize);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$state5 = this.state,\n          animation = _this$state5.animation,\n          duration = _this$state5.duration,\n          dragging = _this$state5.dragging;\n\n      var _this$props5 = this.props,\n          children = _this$props5.children,\n          slideWidth = _this$props5.slideWidth,\n          _this$props5$slideInd = _this$props5.slideIndex,\n          slideIndex = _this$props5$slideInd === void 0 ? 0 : _this$props5$slideInd,\n          isDraggable = _this$props5.isDraggable,\n          onDragStart = _this$props5.onDragStart,\n          onDragEnd = _this$props5.onDragEnd,\n          onChange = _this$props5.onChange,\n          onEnd = _this$props5.onEnd,\n          align = _this$props5.align,\n          bullets = _this$props5.bullets,\n          platform = _this$props5.platform,\n          hasMouse = _this$props5.hasMouse,\n          showArrows = _this$props5.showArrows,\n          window = _this$props5.window,\n          document = _this$props5.document,\n          getRef = _this$props5.getRef,\n          getRootRef = _this$props5.getRootRef,\n          restProps = _objectWithoutProperties(_this$props5, _excluded);\n\n      var indent = dragging ? this.calculateDragIndent() : this.calculateIndent(slideIndex);\n      var layerStyle = {\n        WebkitTransform: \"translateX(\".concat(indent, \"px)\"),\n        transform: \"translateX(\".concat(indent, \"px)\"),\n        WebkitTransition: animation ? \"-webkit-transform \".concat(duration, \"s cubic-bezier(.1, 0, .25, 1)\") : \"none\",\n        transition: animation ? \"transform \".concat(duration, \"s cubic-bezier(.1, 0, .25, 1)\") : \"none\"\n      };\n      return createScopedElement(\"div\", _extends({}, restProps, {\n        vkuiClass: classNames(getClassName(\"Gallery\", platform), \"Gallery--\".concat(align), {\n          \"Gallery--dragging\": dragging,\n          \"Gallery--custom-width\": slideWidth === \"custom\"\n        }),\n        ref: this.getRootRef\n      }), createScopedElement(Touch, {\n        vkuiClass: \"Gallery__viewport\",\n        onStartX: this.onStart,\n        onMoveX: this.onMoveX,\n        onEnd: this.onEnd,\n        noSlideClick: true,\n        style: {\n          width: slideWidth === \"custom\" ? \"100%\" : slideWidth\n        },\n        getRootRef: this.getViewportRef\n      }, createScopedElement(\"div\", {\n        vkuiClass: \"Gallery__layer\",\n        style: layerStyle\n      }, React.Children.map(children, function (item, i) {\n        return createScopedElement(\"div\", {\n          vkuiClass: \"Gallery__slide\",\n          key: \"slide-\".concat(i),\n          ref: _this3.getSlideRef(i)\n        }, item);\n      }))), bullets && createScopedElement(\"div\", {\n        \"aria-hidden\": \"true\",\n        vkuiClass: classNames(\"Gallery__bullets\", \"Gallery__bullets--\".concat(bullets))\n      }, React.Children.map(children, function (_item, index) {\n        return createScopedElement(\"div\", {\n          vkuiClass: classNames(\"Gallery__bullet\", {\n            \"Gallery__bullet--active\": index === slideIndex\n          }),\n          key: index\n        });\n      })), showArrows && hasMouse && this.canSlideLeft && createScopedElement(HorizontalScrollArrow, {\n        direction: \"left\",\n        onClick: this.slideLeft\n      }), showArrows && hasMouse && this.canSlideRight && createScopedElement(HorizontalScrollArrow, {\n        direction: \"right\",\n        onClick: this.slideRight\n      }));\n    }\n  }]);\n\n  return BaseGallery;\n}(React.Component);\n\n_defineProperty(BaseGallery, \"defaultProps\", {\n  slideWidth: \"100%\",\n  children: \"\",\n  align: \"left\",\n  bullets: false,\n  isDraggable: true\n});\n\nvar BaseGalleryAdaptive = withAdaptivity(withDOM(BaseGallery), {\n  hasMouse: true\n});\n\nvar Gallery = function Gallery(_ref3) {\n  var _props$slideIndex;\n\n  var _ref3$initialSlideInd = _ref3.initialSlideIndex,\n      initialSlideIndex = _ref3$initialSlideInd === void 0 ? 0 : _ref3$initialSlideInd,\n      children = _ref3.children,\n      _ref3$timeout = _ref3.timeout,\n      timeout = _ref3$timeout === void 0 ? 0 : _ref3$timeout,\n      onChange = _ref3.onChange,\n      props = _objectWithoutProperties(_ref3, _excluded2);\n\n  var _React$useState = React.useState(initialSlideIndex),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      localSlideIndex = _React$useState2[0],\n      setSlideIndex = _React$useState2[1];\n\n  var isControlled = typeof props.slideIndex === \"number\";\n  var slideIndex = isControlled ? (_props$slideIndex = props.slideIndex) !== null && _props$slideIndex !== void 0 ? _props$slideIndex : 0 : localSlideIndex;\n  var isDraggable = !isControlled || Boolean(onChange);\n  var slides = React.Children.toArray(children).filter(function (item) {\n    return Boolean(item);\n  });\n  var childCount = slides.length;\n  var handleChange = React.useCallback(function (current) {\n    if (current === slideIndex) {\n      return;\n    }\n\n    !isControlled && setSlideIndex(current);\n    onChange && onChange(current);\n  }, [isControlled, onChange, slideIndex]);\n  var autoplay = useTimeout(function () {\n    return handleChange((slideIndex + 1) % childCount);\n  }, timeout);\n  React.useEffect(function () {\n    return timeout ? autoplay.set() : autoplay.clear();\n  }, [timeout, slideIndex, autoplay]); // prevent invalid slideIndex\n  // any slide index is invalid with no slides, just keep it as is\n\n  var safeSlideIndex = childCount > 0 ? clamp(slideIndex, 0, childCount - 1) : slideIndex; // notify parent in controlled mode\n\n  React.useEffect(function () {\n    if (onChange && safeSlideIndex !== slideIndex) {\n      onChange(safeSlideIndex);\n    }\n  }, [onChange, safeSlideIndex, slideIndex]);\n  return createScopedElement(BaseGalleryAdaptive, _extends({\n    isDraggable: isDraggable\n  }, props, {\n    slideIndex: safeSlideIndex,\n    onChange: handleChange\n  }), slides);\n}; // eslint-disable-next-line import/no-default-export\n\n\nexport default withPlatform(Gallery);","map":{"version":3,"mappings":"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","names":["React","getClassName","Touch","classNames","withPlatform","withDOM","setRef","withAdaptivity","HorizontalScrollArrow","clamp","useTimeout","BaseGallery","props","_classCallCheck","_this","_defineProperty","setState","animation","e","isDraggable","isFullyVisible","originalEvent","preventDefault","isSlideX","onDragStart","state","deltaX","shiftX","dragging","targetIndex","isSlide","getTarget","slideIndex","onDragEnd","onChange","_this$props$onChange","onEnd","initializeSlides","canSlideLeft","canSlideRight","id","slide","slidesStore","viewport","getRef","container","getRootRef","containerWidth","slides","duration","slideWidth","align","options","Children","map","children","_item","i","elem","_this2","coordX","offsetLeft","width","offsetWidth","_this$container","layerWidth","reduce","val","min","calcMin","max","calcMax","undefined","calculateIndent","isValidShift","validateIndent","window","requestAnimationFrame","viewportWidth","_this$viewport","isCenterWithCustomWidth","length","_this$viewport2","targetSlide","_this$viewport3","indent","Number","value","expectDeltaX","shift","direction","item","index","previousValue","Math","abs","currentValue","addEventListener","onResize","prevProps","widthChanged","isPropUpdate","slideCountChanged","count","isCustomWidth","removeEventListener","bullets","platform","hasMouse","showArrows","document","restProps","calculateDragIndent","layerStyle","WebkitTransform","transform","WebkitTransition","transition","createScopedElement","vkuiClass","ref","onStartX","onStart","onMoveX","noSlideClick","style","getViewportRef","key","_this3","getSlideRef","onClick","slideLeft","slideRight","Component","BaseGalleryAdaptive","Gallery","initialSlideIndex","timeout","useState","localSlideIndex","setSlideIndex","isControlled","Boolean","toArray","filter","childCount","handleChange","useCallback","current","autoplay","useEffect","set","clear","safeSlideIndex"],"sources":["../../../src/components/Gallery/Gallery.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { Touch, TouchEventHandler, TouchEvent } from \"../Touch/Touch\";\nimport { classNames } from \"../../lib/classNames\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { HasAlign, HasPlatform, HasRef, HasRootRef } from \"../../types\";\nimport { withDOM, DOMProps } from \"../../lib/dom\";\nimport { setRef } from \"../../lib/utils\";\nimport { withAdaptivity, AdaptivityProps } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"../HorizontalScroll/HorizontalScrollArrow\";\nimport { clamp } from \"../../helpers/math\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nimport \"./Gallery.css\";\n\nexport interface BaseGalleryProps\n  extends Omit<\n      React.HTMLAttributes<HTMLDivElement>,\n      \"onChange\" | \"onDragStart\" | \"onDragEnd\"\n    >,\n    HasPlatform,\n    HasAlign,\n    HasRootRef<HTMLDivElement>,\n    HasRef<HTMLElement> {\n  slideWidth?: string | number;\n  slideIndex?: number;\n  onDragStart?: TouchEventHandler;\n  onDragEnd?: TouchEventHandler;\n  onChange?(current: number): void;\n  onEnd?({ targetIndex }: { targetIndex: number }): void;\n  bullets?: \"dark\" | \"light\" | false;\n  isDraggable?: boolean;\n  showArrows?: boolean;\n}\n\nexport interface GalleryProps extends BaseGalleryProps {\n  initialSlideIndex?: number;\n  timeout?: number;\n}\n\nexport interface GalleryState {\n  containerWidth: number;\n  layerWidth?: number;\n  min?: number;\n  max?: number;\n  deltaX: number;\n  shiftX: number;\n  slides: GallerySlidesState[];\n  animation: boolean;\n  duration: number;\n  dragging?: boolean;\n}\n\nexport interface GallerySlidesState {\n  coordX: number;\n  width: number;\n}\n\ntype GetSlideRef = (index: number) => React.RefCallback<HTMLElement>;\n\nclass BaseGallery extends React.Component<\n  BaseGalleryProps & DOMProps & AdaptivityProps,\n  GalleryState\n> {\n  constructor(props: GalleryProps) {\n    super(props);\n\n    this.state = {\n      containerWidth: 0,\n      deltaX: 0,\n      shiftX: 0,\n      slides: [],\n      animation: true,\n      duration: 0.24,\n    };\n\n    this.slidesStore = {};\n  }\n\n  container: HTMLDivElement | null = null;\n  slidesStore: {\n    [index: string]: HTMLElement | null;\n  };\n  viewport: HTMLElement | null = null;\n\n  static defaultProps: Partial<BaseGalleryProps> = {\n    slideWidth: \"100%\",\n    children: \"\",\n    align: \"left\",\n    bullets: false,\n    isDraggable: true,\n  };\n\n  get isCenterWithCustomWidth() {\n    return this.props.slideWidth === \"custom\" && this.props.align === \"center\";\n  }\n\n  initializeSlides(options: { animation?: boolean } = {}) {\n    const slides =\n      React.Children.map(\n        this.props.children,\n        (_item: React.ReactNode, i: number): GallerySlidesState => {\n          const elem = this.slidesStore[`slide-${i}`];\n          return {\n            coordX: elem?.offsetLeft ?? 0,\n            width: elem?.offsetWidth ?? 0,\n          };\n        }\n      ) ?? [];\n\n    const containerWidth = this.container?.offsetWidth ?? 0;\n    const layerWidth = slides.reduce(\n      (val: number, slide: GallerySlidesState) => slide.width + val,\n      0\n    );\n\n    const min = this.calcMin({ containerWidth, layerWidth, slides });\n    const max = this.calcMax({ slides });\n\n    this.setState({ min, max, layerWidth, containerWidth, slides }, () => {\n      if (this.props.slideIndex !== undefined) {\n        const shiftX = this.calculateIndent(this.props.slideIndex);\n        if (this.state.shiftX === shiftX) {\n          return;\n        }\n        const isValidShift =\n          this.state.shiftX === this.validateIndent(this.state.shiftX);\n        const { animation = isValidShift } = options;\n        this.setState({ shiftX, animation }, () => {\n          if (!this.state.animation) {\n            this.props.window?.requestAnimationFrame(() =>\n              this.setState({ animation: true })\n            );\n          }\n        });\n      }\n    });\n  }\n\n  calcMin({\n    containerWidth,\n    layerWidth = 0,\n    slides,\n  }: Pick<GalleryState, \"containerWidth\" | \"layerWidth\" | \"slides\">) {\n    const viewportWidth = this.viewport?.offsetWidth ?? 0;\n    switch (this.props.align) {\n      case \"left\":\n        return containerWidth - layerWidth;\n      case \"right\":\n        return viewportWidth - layerWidth;\n      case \"center\":\n        if (this.isCenterWithCustomWidth && slides.length) {\n          const { coordX, width } = slides[slides.length - 1];\n          return viewportWidth / 2 - coordX - width / 2;\n        } else {\n          return (\n            viewportWidth - (containerWidth - viewportWidth) / 2 - layerWidth\n          );\n        }\n    }\n    return undefined;\n  }\n\n  calcMax({ slides }: Pick<GalleryState, \"slides\">) {\n    const viewportWidth = this.viewport?.offsetWidth ?? 0;\n    if (this.isCenterWithCustomWidth && slides.length) {\n      const { width, coordX } = slides[0];\n      return viewportWidth / 2 - coordX - width / 2;\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n   * Считает отступ слоя галереи\n   */\n  calculateIndent(targetIndex: number) {\n    const { slides } = this.state;\n\n    if (this.isFullyVisible) {\n      return 0;\n    }\n\n    const targetSlide = slides.length ? slides[targetIndex] : null;\n\n    if (targetSlide) {\n      const { coordX, width } = targetSlide;\n\n      if (this.isCenterWithCustomWidth) {\n        const viewportWidth = this.viewport?.offsetWidth ?? 0;\n        return viewportWidth / 2 - coordX - width / 2;\n      }\n\n      return this.validateIndent(-1 * coordX);\n    } else {\n      return 0;\n    }\n  }\n\n  /*\n   * Считает отступ слоя галереи во время драга\n   */\n  calculateDragIndent() {\n    const { shiftX, deltaX, min = 0, max = 0 } = this.state;\n    const indent = shiftX + deltaX;\n\n    if (indent > max) {\n      return max + Number((indent - max) / 3);\n    } else if (indent < min) {\n      return min + Number((indent - min) / 3);\n    }\n\n    return indent;\n  }\n\n  validateIndent(value: number) {\n    const { min = 0, max = 0 } = this.state;\n\n    if (value < min) {\n      return min;\n    } else if (value > max) {\n      return max;\n    }\n\n    return value;\n  }\n\n  get isFullyVisible() {\n    return (this.state.layerWidth ?? 0) <= this.state.containerWidth;\n  }\n\n  /*\n   * Получает индекс слайда, к которому будет осуществлен переход\n   */\n  getTarget(e: TouchEvent) {\n    const { slides, deltaX, shiftX, max = 0 } = this.state;\n    const { slideIndex = 0 } = this.props;\n    const expectDeltaX = (deltaX / e.duration) * 240 * 0.6;\n    const shift = shiftX + deltaX + expectDeltaX - max;\n    const direction = deltaX < 0 ? 1 : -1;\n\n    // Находим ближайшую границу слайда к текущему отступу\n    let targetIndex = slides.reduce(\n      (val: number, item: GallerySlidesState, index: number) => {\n        const previousValue = Math.abs(slides[val].coordX + shift);\n        const currentValue = Math.abs(item.coordX + shift);\n\n        return previousValue < currentValue ? val : index;\n      },\n      slideIndex\n    );\n\n    if (targetIndex === slideIndex) {\n      let targetSlide = slideIndex + direction;\n\n      if (targetSlide >= 0 && targetSlide < slides.length) {\n        if (Math.abs(deltaX) > slides[targetSlide].width * 0.05) {\n          targetIndex = targetSlide;\n        }\n      }\n    }\n\n    return targetIndex;\n  }\n\n  onStart: TouchEventHandler = () => {\n    this.setState({\n      animation: false,\n    });\n  };\n\n  onMoveX: TouchEventHandler = (e: TouchEvent) => {\n    if (this.props.isDraggable && !this.isFullyVisible) {\n      e.originalEvent.preventDefault();\n\n      if (e.isSlideX) {\n        this.props.onDragStart && this.props.onDragStart(e);\n\n        if (\n          this.state.deltaX !== e.shiftX ||\n          this.state.dragging !== e.isSlideX\n        ) {\n          this.setState({\n            deltaX: e.shiftX,\n            dragging: e.isSlideX,\n          });\n        }\n      }\n    }\n  };\n\n  onEnd: TouchEventHandler = (e: TouchEvent) => {\n    const targetIndex = e.isSlide\n      ? this.getTarget(e)\n      : this.props.slideIndex ?? 0;\n    this.props.onDragEnd && this.props.onDragEnd(e);\n    this.setState({ deltaX: 0, animation: true }, () =>\n      this.props.onChange?.(targetIndex)\n    );\n\n    if (this.props.onEnd) {\n      this.props.onEnd({ targetIndex });\n    }\n  };\n\n  onResize: VoidFunction = () => this.initializeSlides({ animation: false });\n\n  get canSlideLeft() {\n    // shiftX is negative number <= 0, we can swipe back only if it is < 0\n    return !this.isFullyVisible && this.state.shiftX < 0;\n  }\n\n  get canSlideRight() {\n    const { containerWidth, layerWidth = 0, shiftX, slides } = this.state;\n    const { align, slideIndex = 0 } = this.props;\n    return (\n      !this.isFullyVisible &&\n      // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side\n      ((align === \"left\" && containerWidth - shiftX < layerWidth) ||\n        // otherwise we need to check current slide index (align = right or align = center)\n        (align !== \"left\" && slideIndex < slides.length - 1))\n    );\n  }\n\n  slideLeft = () => {\n    const { slideIndex = 0, onChange } = this.props;\n    if (this.canSlideLeft) {\n      this.setState({ deltaX: 0, animation: true }, () =>\n        onChange?.(slideIndex - 1)\n      );\n    }\n  };\n\n  slideRight = () => {\n    const { slideIndex = 0, onChange } = this.props;\n    if (this.canSlideRight) {\n      this.setState({ deltaX: 0, animation: true }, () =>\n        onChange?.(slideIndex + 1)\n      );\n    }\n  };\n\n  getSlideRef: GetSlideRef = (id: number) => (slide) => {\n    this.slidesStore[`slide-${id}`] = slide;\n  };\n\n  getViewportRef: React.RefCallback<HTMLElement> = (viewport) => {\n    this.viewport = viewport;\n    if (this.props.getRef) {\n      setRef(viewport, this.props.getRef);\n    }\n  };\n\n  getRootRef: React.RefCallback<HTMLDivElement> = (container) => {\n    this.container = container;\n    if (this.props.getRootRef) {\n      setRef(container, this.props.getRootRef);\n    }\n  };\n\n  componentDidMount() {\n    this.initializeSlides({ animation: false });\n    this.props.window!.addEventListener(\"resize\", this.onResize);\n  }\n\n  componentDidUpdate(prevProps: GalleryProps) {\n    const widthChanged = this.props.slideWidth !== prevProps.slideWidth;\n    const isPropUpdate = this.props !== prevProps;\n    const slideCountChanged =\n      React.Children.count(this.props.children) !==\n      React.Children.count(prevProps.children);\n    const isCustomWidth = this.props.slideWidth === \"custom\";\n\n    // в любом из этих случаев позиция могла поменяться\n    if (widthChanged || slideCountChanged || (isCustomWidth && isPropUpdate)) {\n      this.initializeSlides();\n    } else if (this.props.slideIndex !== prevProps.slideIndex) {\n      this.setState({\n        animation: true,\n        deltaX: 0,\n        shiftX: this.calculateIndent(this.props.slideIndex ?? 0),\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    this.props.window!.removeEventListener(\"resize\", this.onResize);\n  }\n\n  render() {\n    const { animation, duration, dragging } = this.state;\n    const {\n      children,\n      slideWidth,\n      slideIndex = 0,\n      isDraggable,\n      onDragStart,\n      onDragEnd,\n      onChange,\n      onEnd,\n      align,\n      bullets,\n      platform,\n      hasMouse,\n      showArrows,\n      window,\n      document,\n      getRef,\n      getRootRef,\n      ...restProps\n    } = this.props;\n\n    const indent = dragging\n      ? this.calculateDragIndent()\n      : this.calculateIndent(slideIndex);\n\n    const layerStyle = {\n      WebkitTransform: `translateX(${indent}px)`,\n      transform: `translateX(${indent}px)`,\n      WebkitTransition: animation\n        ? `-webkit-transform ${duration}s cubic-bezier(.1, 0, .25, 1)`\n        : \"none\",\n      transition: animation\n        ? `transform ${duration}s cubic-bezier(.1, 0, .25, 1)`\n        : \"none\",\n    };\n\n    return (\n      <div\n        {...restProps}\n        vkuiClass={classNames(\n          getClassName(\"Gallery\", platform),\n          `Gallery--${align}`,\n          {\n            \"Gallery--dragging\": dragging,\n            \"Gallery--custom-width\": slideWidth === \"custom\",\n          }\n        )}\n        ref={this.getRootRef}\n      >\n        <Touch\n          vkuiClass=\"Gallery__viewport\"\n          onStartX={this.onStart}\n          onMoveX={this.onMoveX}\n          onEnd={this.onEnd}\n          noSlideClick\n          style={{ width: slideWidth === \"custom\" ? \"100%\" : slideWidth }}\n          getRootRef={this.getViewportRef}\n        >\n          <div vkuiClass=\"Gallery__layer\" style={layerStyle}>\n            {React.Children.map(\n              children,\n              (item: React.ReactNode, i: number) => (\n                <div\n                  vkuiClass=\"Gallery__slide\"\n                  key={`slide-${i}`}\n                  ref={this.getSlideRef(i)}\n                >\n                  {item}\n                </div>\n              )\n            )}\n          </div>\n        </Touch>\n\n        {bullets && (\n          <div\n            aria-hidden=\"true\"\n            vkuiClass={classNames(\n              \"Gallery__bullets\",\n              `Gallery__bullets--${bullets}`\n            )}\n          >\n            {React.Children.map(\n              children,\n              (_item: React.ReactNode, index: number) => (\n                <div\n                  vkuiClass={classNames(\"Gallery__bullet\", {\n                    \"Gallery__bullet--active\": index === slideIndex,\n                  })}\n                  key={index}\n                />\n              )\n            )}\n          </div>\n        )}\n\n        {showArrows && hasMouse && this.canSlideLeft && (\n          <HorizontalScrollArrow direction=\"left\" onClick={this.slideLeft} />\n        )}\n        {showArrows && hasMouse && this.canSlideRight && (\n          <HorizontalScrollArrow direction=\"right\" onClick={this.slideRight} />\n        )}\n      </div>\n    );\n  }\n}\n\nconst BaseGalleryAdaptive = withAdaptivity(withDOM(BaseGallery), {\n  hasMouse: true,\n});\n\nconst Gallery: React.FC<GalleryProps> = ({\n  initialSlideIndex = 0,\n  children,\n  timeout = 0,\n  onChange,\n  ...props\n}: GalleryProps) => {\n  const [localSlideIndex, setSlideIndex] = React.useState(initialSlideIndex);\n  const isControlled = typeof props.slideIndex === \"number\";\n  const slideIndex = isControlled ? props.slideIndex ?? 0 : localSlideIndex;\n  const isDraggable = !isControlled || Boolean(onChange);\n  const slides = React.Children.toArray(children).filter((item) =>\n    Boolean(item)\n  );\n  const childCount = slides.length;\n\n  const handleChange: GalleryProps[\"onChange\"] = React.useCallback(\n    (current) => {\n      if (current === slideIndex) {\n        return;\n      }\n      !isControlled && setSlideIndex(current);\n      onChange && onChange(current);\n    },\n    [isControlled, onChange, slideIndex]\n  );\n\n  const autoplay = useTimeout(\n    () => handleChange((slideIndex + 1) % childCount),\n    timeout\n  );\n  React.useEffect(\n    () => (timeout ? autoplay.set() : autoplay.clear()),\n    [timeout, slideIndex, autoplay]\n  );\n\n  // prevent invalid slideIndex\n  // any slide index is invalid with no slides, just keep it as is\n  const safeSlideIndex =\n    childCount > 0 ? clamp(slideIndex, 0, childCount - 1) : slideIndex;\n  // notify parent in controlled mode\n  React.useEffect(() => {\n    if (onChange && safeSlideIndex !== slideIndex) {\n      onChange(safeSlideIndex);\n    }\n  }, [onChange, safeSlideIndex, slideIndex]);\n\n  return (\n    <BaseGalleryAdaptive\n      isDraggable={isDraggable}\n      {...props}\n      slideIndex={safeSlideIndex}\n      onChange={handleChange}\n    >\n      {slides}\n    </BaseGalleryAdaptive>\n  );\n};\n\n// eslint-disable-next-line import/no-default-export\nexport default withPlatform(Gallery);\n"]},"metadata":{},"sourceType":"module"}