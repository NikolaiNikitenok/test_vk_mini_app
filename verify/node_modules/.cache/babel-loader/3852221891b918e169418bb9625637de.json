{"ast":null,"code":"/**\r\n *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value\r\n *  to be encoded as a compact string using a radix of 58 using only\r\n *  alpha-numeric characters. Confusingly similar characters are omitted\r\n *  (i.e. ``\"l0O\"``).\r\n *\r\n *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,\r\n *  since any zero-bytes on the left would get removed. To mitigate this\r\n *  issue most schemes that use Base58 choose specific high-order values\r\n *  to ensure non-zero prefixes.\r\n *\r\n *  @_subsection: api/utils:Base58 Encoding [about-base58]\r\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument } from \"./errors.js\";\nimport { toBigInt } from \"./maths.js\";\nconst Alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nlet Lookup = null;\n\nfunction getAlpha(letter) {\n  if (Lookup == null) {\n    Lookup = {};\n\n    for (let i = 0; i < Alphabet.length; i++) {\n      Lookup[Alphabet[i]] = BigInt(i);\n    }\n  }\n\n  const result = Lookup[letter];\n  assertArgument(result != null, `invalid base58 value`, \"letter\", letter);\n  return result;\n}\n\nconst BN_0 = BigInt(0);\nconst BN_58 = BigInt(58);\n/**\r\n *  Encode %%value%% as a Base58-encoded string.\r\n */\n\nexport function encodeBase58(_value) {\n  let value = toBigInt(getBytes(_value));\n  let result = \"\";\n\n  while (value) {\n    result = Alphabet[Number(value % BN_58)] + result;\n    value /= BN_58;\n  }\n\n  return result;\n}\n/**\r\n *  Decode the Base58-encoded %%value%%.\r\n */\n\nexport function decodeBase58(value) {\n  let result = BN_0;\n\n  for (let i = 0; i < value.length; i++) {\n    result *= BN_58;\n    result += getAlpha(value[i]);\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;AAcA,SAASA,QAAT,QAAyB,WAAzB;AACA,SAASC,cAAT,QAA+B,aAA/B;AACA,SAASC,QAAT,QAAyB,YAAzB;AAKA,MAAMC,QAAQ,GAAG,4DAAjB;AACA,IAAIC,MAAM,GAAkC,IAA5C;;AAEA,SAASC,QAAT,CAAkBC,MAAlB,EAAgC;AAC5B,MAAIF,MAAM,IAAI,IAAd,EAAoB;AAChBA,UAAM,GAAG,EAAT;;AACA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAAQ,CAACK,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACtCH,YAAM,CAACD,QAAQ,CAACI,CAAD,CAAT,CAAN,GAAsBE,MAAM,CAACF,CAAD,CAA5B;AACH;AACJ;;AACD,QAAMG,MAAM,GAAGN,MAAM,CAACE,MAAD,CAArB;AACAL,gBAAc,CAACS,MAAM,IAAI,IAAX,EAAiB,sBAAjB,EAAyC,QAAzC,EAAmDJ,MAAnD,CAAd;AACA,SAAOI,MAAP;AACH;;AAGD,MAAMC,IAAI,GAAGF,MAAM,CAAC,CAAD,CAAnB;AACA,MAAMG,KAAK,GAAGH,MAAM,CAAC,EAAD,CAApB;AAEA;;;;AAGA,OAAM,SAAUI,YAAV,CAAuBC,MAAvB,EAAwC;AAC1C,MAAIC,KAAK,GAAGb,QAAQ,CAACF,QAAQ,CAACc,MAAD,CAAT,CAApB;AACA,MAAIJ,MAAM,GAAG,EAAb;;AACA,SAAOK,KAAP,EAAc;AACVL,UAAM,GAAGP,QAAQ,CAACa,MAAM,CAACD,KAAK,GAAGH,KAAT,CAAP,CAAR,GAAkCF,MAA3C;AACAK,SAAK,IAAIH,KAAT;AACH;;AACD,SAAOF,MAAP;AACH;AAED;;;;AAGA,OAAM,SAAUO,YAAV,CAAuBF,KAAvB,EAAoC;AACtC,MAAIL,MAAM,GAAGC,IAAb;;AACA,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGQ,KAAK,CAACP,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnCG,UAAM,IAAIE,KAAV;AACAF,UAAM,IAAIL,QAAQ,CAACU,KAAK,CAACR,CAAD,CAAN,CAAlB;AACH;;AACD,SAAOG,MAAP;AACH","names":["getBytes","assertArgument","toBigInt","Alphabet","Lookup","getAlpha","letter","i","length","BigInt","result","BN_0","BN_58","encodeBase58","_value","value","Number","decodeBase58"],"sourceRoot":"","sources":["../../src.ts/utils/base58.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}