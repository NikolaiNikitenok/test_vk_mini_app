{"ast":null,"code":"/**\n *  Generic long-lived socket provider.\n *\n *  Sub-classing notes\n *  - a sub-class MUST call the `_start()` method once connected\n *  - a sub-class MUST override the `_write(string)` method\n *  - a sub-class MUST call `_processMessage(string)` for each message\n *\n *  @_subsection: api/providers/abstract-provider\n */\nimport { UnmanagedSubscriber } from \"./abstract-provider.js\";\nimport { assert, assertArgument } from \"../utils/index.js\";\nimport { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\nexport class SocketSubscriber {\n  #provider;\n  #filter;\n\n  get filter() {\n    return JSON.parse(this.#filter);\n  }\n\n  #filterId;\n  #paused;\n  #emitPromise;\n\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = JSON.stringify(filter);\n    this.#filterId = null;\n    this.#paused = null;\n    this.#emitPromise = null;\n  }\n\n  start() {\n    this.#filterId = this.#provider.send(\"eth_subscribe\", this.filter).then(filterId => {\n      ;\n\n      this.#provider._register(filterId, this);\n\n      return filterId;\n    });\n  }\n\n  stop() {\n    this.#filterId.then(filterId => {\n      this.#provider.send(\"eth_unsubscribe\", [filterId]);\n    });\n    this.#filterId = null;\n  } // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs\n  //        and resume\n\n\n  pause(dropWhilePaused) {\n    assert(dropWhilePaused, \"preserve logs while paused not supported by SocketSubscriber yet\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"pause(false)\"\n    });\n    this.#paused = !!dropWhilePaused;\n  }\n\n  resume() {\n    this.#paused = null;\n  }\n\n  _handleMessage(message) {\n    if (this.#filterId == null) {\n      return;\n    }\n\n    if (this.#paused === null) {\n      let emitPromise = this.#emitPromise;\n\n      if (emitPromise == null) {\n        emitPromise = this._emit(this.#provider, message);\n      } else {\n        emitPromise = emitPromise.then(async () => {\n          await this._emit(this.#provider, message);\n        });\n      }\n\n      this.#emitPromise = emitPromise.then(() => {\n        if (this.#emitPromise === emitPromise) {\n          this.#emitPromise = null;\n        }\n      });\n    }\n  }\n\n  async _emit(provider, message) {\n    throw new Error(\"sub-classes must implemente this; _emit\");\n  }\n\n}\nexport class SocketBlockSubscriber extends SocketSubscriber {\n  constructor(provider) {\n    super(provider, [\"newHeads\"]);\n  }\n\n  async _emit(provider, message) {\n    provider.emit(\"block\", parseInt(message.number));\n  }\n\n}\nexport class SocketPendingSubscriber extends SocketSubscriber {\n  constructor(provider) {\n    super(provider, [\"newPendingTransactions\"]);\n  }\n\n  async _emit(provider, message) {\n    provider.emit(\"pending\", message);\n  }\n\n}\nexport class SocketEventSubscriber extends SocketSubscriber {\n  #logFilter;\n\n  get logFilter() {\n    return JSON.parse(this.#logFilter);\n  }\n\n  constructor(provider, filter) {\n    super(provider, [\"logs\", filter]);\n    this.#logFilter = JSON.stringify(filter);\n  }\n\n  async _emit(provider, message) {\n    provider.emit(this.#logFilter, provider._wrapLog(message, provider._network));\n  }\n\n}\n/**\n *  SocketProvider...\n *\n */\n\nexport class SocketProvider extends JsonRpcApiProvider {\n  #callbacks; // Maps each filterId to its subscriber\n\n  #subs; // If any events come in before a subscriber has finished\n  // registering, queue them\n\n  #pending;\n\n  constructor(network) {\n    super(network, {\n      batchMaxCount: 1\n    });\n    this.#callbacks = new Map();\n    this.#subs = new Map();\n    this.#pending = new Map();\n  } // This value is only valid after _start has been called\n\n  /*\n  get _network(): Network {\n      if (this.#network == null) {\n          throw new Error(\"this shouldn't happen\");\n      }\n      return this.#network.clone();\n  }\n  */\n\n\n  _getSubscriber(sub) {\n    switch (sub.type) {\n      case \"close\":\n        return new UnmanagedSubscriber(\"close\");\n\n      case \"block\":\n        return new SocketBlockSubscriber(this);\n\n      case \"pending\":\n        return new SocketPendingSubscriber(this);\n\n      case \"event\":\n        return new SocketEventSubscriber(this, sub.filter);\n\n      case \"orphan\":\n        // Handled auto-matically within AbstractProvider\n        // when the log.removed = true\n        if (sub.filter.orphan === \"drop-log\") {\n          return new UnmanagedSubscriber(\"drop-log\");\n        }\n\n    }\n\n    return super._getSubscriber(sub);\n  }\n\n  _register(filterId, subscriber) {\n    this.#subs.set(filterId, subscriber);\n    const pending = this.#pending.get(filterId);\n\n    if (pending) {\n      for (const message of pending) {\n        subscriber._handleMessage(message);\n      }\n\n      this.#pending.delete(filterId);\n    }\n  }\n\n  async _send(payload) {\n    // WebSocket provider doesn't accept batches\n    assertArgument(!Array.isArray(payload), \"WebSocket does not support batch send\", \"payload\", payload); // @TODO: stringify payloads here and store to prevent mutations\n    // Prepare a promise to respond to\n\n    const promise = new Promise((resolve, reject) => {\n      this.#callbacks.set(payload.id, {\n        payload,\n        resolve,\n        reject\n      });\n    }); // Wait until the socket is connected before writing to it\n\n    await this._waitUntilReady(); // Write the request to the socket\n\n    await this._write(JSON.stringify(payload));\n    return [await promise];\n  } // Sub-classes must call this once they are connected\n\n  /*\n  async _start(): Promise<void> {\n      if (this.#ready) { return; }\n       for (const { payload } of this.#callbacks.values()) {\n          await this._write(JSON.stringify(payload));\n      }\n       this.#ready = (async function() {\n          await super._start();\n      })();\n  }\n  */\n  // Sub-classes must call this for each message\n\n\n  async _processMessage(message) {\n    const result = JSON.parse(message);\n\n    if (\"id\" in result) {\n      const callback = this.#callbacks.get(result.id);\n\n      if (callback == null) {\n        console.log(\"Weird... Response for not a thing we sent\");\n        return;\n      }\n\n      this.#callbacks.delete(result.id);\n      callback.resolve(result);\n      /*\n                  if (\"error\" in result) {\n                      const { message, code, data } = result.error;\n                      const error = makeError(message || \"unkonwn error\", \"SERVER_ERROR\", {\n                          request: `ws:${ JSON.stringify(callback.payload) }`,\n                          info: { code, data }\n                      });\n                      callback.reject(error);\n                  } else {\n                      callback.resolve(result.result);\n                  }\n      */\n    } else if (result.method === \"eth_subscription\") {\n      const filterId = result.params.subscription;\n      const subscriber = this.#subs.get(filterId);\n\n      if (subscriber) {\n        subscriber._handleMessage(result.params.result);\n      } else {\n        let pending = this.#pending.get(filterId);\n\n        if (pending == null) {\n          pending = [];\n          this.#pending.set(filterId, pending);\n        }\n\n        pending.push(result.params.result);\n      }\n    }\n  }\n\n  async _write(message) {\n    throw new Error(\"sub-classes must override this\");\n  }\n\n}","map":{"version":3,"mappings":"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","names":["UnmanagedSubscriber","assert","assertArgument","JsonRpcApiProvider","SocketSubscriber","filter","JSON","parse","constructor","provider","stringify","start","send","then","filterId","_register","stop","pause","dropWhilePaused","operation","resume","_handleMessage","message","emitPromise","_emit","Error","SocketBlockSubscriber","emit","parseInt","number","SocketPendingSubscriber","SocketEventSubscriber","logFilter","_wrapLog","_network","SocketProvider","network","batchMaxCount","Map","_getSubscriber","sub","type","orphan","subscriber","set","pending","get","delete","_send","payload","Array","isArray","promise","Promise","resolve","reject","id","_waitUntilReady","_write","_processMessage","result","callback","console","log","method","params","subscription","push"],"sourceRoot":"","sources":["../../src.ts/providers/provider-socket.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}