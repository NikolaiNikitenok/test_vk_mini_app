{"ast":null,"code":"import { SigningKey } from \"../crypto/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { HDNodeWallet } from \"./hdwallet.js\";\nimport { decryptCrowdsaleJson, isCrowdsaleJson } from \"./json-crowdsale.js\";\nimport { decryptKeystoreJson, decryptKeystoreJsonSync, encryptKeystoreJson, encryptKeystoreJsonSync, isKeystoreJson } from \"./json-keystore.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\n\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve();\n    }, duration);\n  });\n}\n/**\r\n *  A **Wallet** manages a single private key which is used to sign\r\n *  transactions, messages and other common payloads.\r\n *\r\n *  This class is generally the main entry point for developers\r\n *  that wish to use a private key directly, as it can create\r\n *  instances from a large variety of common sources, including\r\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\r\n *  wallets.\r\n */\n\n\nexport class Wallet extends BaseWallet {\n  /**\r\n   *  Create a new wallet for the %%privateKey%%, optionally connected\r\n   *  to %%provider%%.\r\n   */\n  constructor(key, provider) {\n    let signingKey = typeof key === \"string\" ? new SigningKey(key) : key;\n    super(signingKey, provider);\n  }\n\n  connect(provider) {\n    return new Wallet(this.signingKey, provider);\n  }\n  /**\r\n   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\r\n   *  %%password%%.\r\n   *\r\n   *  If %%progressCallback%% is specified, it will receive periodic\r\n   *  updates as the encryption process progreses.\r\n   */\n\n\n  async encrypt(password, progressCallback) {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    return await encryptKeystoreJson(account, password, {\n      progressCallback\n    });\n  }\n  /**\r\n   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\r\n   *  %%password%%.\r\n   *\r\n   *  It is preferred to use the [async version](encrypt) instead,\r\n   *  which allows a [[ProgressCallback]] to keep the user informed.\r\n   *\r\n   *  This method will block the event loop (freezing all UI) until\r\n   *  it is complete, which may be a non-trivial duration.\r\n   */\n\n\n  encryptSync(password) {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    return encryptKeystoreJsonSync(account, password);\n  }\n\n  static #fromAccount(account) {\n    assertArgument(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n\n    if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n      const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);\n      const wallet = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n\n      if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n        return wallet;\n      }\n\n      console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n    }\n\n    const wallet = new Wallet(account.privateKey);\n    assertArgument(wallet.address === account.address, \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n    return wallet;\n  }\n  /**\r\n   *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\r\n   *  with %%password%%.\r\n   *\r\n   *  If %%progress%% is provided, it is called periodically during\r\n   *  decryption so that any UI can be updated.\r\n   */\n\n\n  static async fromEncryptedJson(json, password, progress) {\n    let account = null;\n\n    if (isKeystoreJson(json)) {\n      account = await decryptKeystoreJson(json, password, progress);\n    } else if (isCrowdsaleJson(json)) {\n      if (progress) {\n        progress(0);\n        await stall(0);\n      }\n\n      account = decryptCrowdsaleJson(json, password);\n\n      if (progress) {\n        progress(1);\n        await stall(0);\n      }\n    }\n\n    return Wallet.#fromAccount(account);\n  }\n  /**\r\n   *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\r\n   *\r\n   *  The [[fromEncryptedJson]] method is preferred, as this method\r\n   *  will lock up and freeze the UI during decryption, which may take\r\n   *  some time.\r\n   */\n\n\n  static fromEncryptedJsonSync(json, password) {\n    let account = null;\n\n    if (isKeystoreJson(json)) {\n      account = decryptKeystoreJsonSync(json, password);\n    } else if (isCrowdsaleJson(json)) {\n      account = decryptCrowdsaleJson(json, password);\n    } else {\n      assertArgument(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n    }\n\n    return Wallet.#fromAccount(account);\n  }\n  /**\r\n   *  Creates a new random [[HDNodeWallet]] using the avavilable\r\n   *  [cryptographic random source](randomBytes).\r\n   *\r\n   *  If there is no crytographic random source, this will throw.\r\n   */\n\n\n  static createRandom(provider) {\n    const wallet = HDNodeWallet.createRandom();\n\n    if (provider) {\n      return wallet.connect(provider);\n    }\n\n    return wallet;\n  }\n  /**\r\n   *  Creates a [[HDNodeWallet]] for %%phrase%%.\r\n   */\n\n\n  static fromPhrase(phrase, provider) {\n    const wallet = HDNodeWallet.fromPhrase(phrase);\n\n    if (provider) {\n      return wallet.connect(provider);\n    }\n\n    return wallet;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["SigningKey","assertArgument","BaseWallet","HDNodeWallet","decryptCrowdsaleJson","isCrowdsaleJson","decryptKeystoreJson","decryptKeystoreJsonSync","encryptKeystoreJson","encryptKeystoreJsonSync","isKeystoreJson","Mnemonic","stall","duration","Promise","resolve","setTimeout","Wallet","constructor","key","provider","signingKey","connect","encrypt","password","progressCallback","account","address","privateKey","encryptSync","mnemonic","locale","fromEntropy","entropy","wallet","fromMnemonic","path","console","log","fromEncryptedJson","json","progress","fromEncryptedJsonSync","createRandom","fromPhrase","phrase"],"sourceRoot":"","sources":["../../src.ts/wallet/wallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}