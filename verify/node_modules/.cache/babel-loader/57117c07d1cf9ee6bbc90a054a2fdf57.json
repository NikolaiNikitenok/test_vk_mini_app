{"ast":null,"code":"/**\r\n *  Explain HD Wallets..\r\n *\r\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\r\n */\nimport { computeHmac, randomBytes, ripemd160, SigningKey, sha256 } from \"../crypto/index.js\";\nimport { VoidSigner } from \"../providers/index.js\";\nimport { computeAddress } from \"../transaction/index.js\";\nimport { concat, dataSlice, decodeBase58, defineProperties, encodeBase58, getBytes, hexlify, isBytesLike, getNumber, toBeArray, toBigInt, toBeHex, assertPrivate, assert, assertArgument } from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\nimport { encryptKeystoreJson, encryptKeystoreJsonSync } from \"./json-keystore.js\";\n/**\r\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\r\n */\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\"; // \"Bitcoin seed\"\n\nconst MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);\nconst HardenedBit = 0x80000000;\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst Nibbles = \"0123456789abcdef\";\n\nfunction zpad(value, length) {\n  let result = \"\";\n\n  while (value) {\n    result = Nibbles[value % 16] + result;\n    value = Math.trunc(value / 16);\n  }\n\n  while (result.length < length * 2) {\n    result = \"0\" + result;\n  }\n\n  return \"0x\" + result;\n}\n\nfunction encodeBase58Check(_value) {\n  const value = getBytes(_value);\n  const check = dataSlice(sha256(sha256(value)), 0, 4);\n  const bytes = concat([value, check]);\n  return encodeBase58(bytes);\n}\n\nconst _guard = {};\n\nfunction ser_I(index, chainCode, publicKey, privateKey) {\n  const data = new Uint8Array(37);\n\n  if (index & HardenedBit) {\n    assert(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"deriveChild\"\n    }); // Data = 0x00 || ser_256(k_par)\n\n    data.set(getBytes(privateKey), 1);\n  } else {\n    // Data = ser_p(point(k_par))\n    data.set(getBytes(publicKey));\n  } // Data += ser_32(i)\n\n\n  for (let i = 24; i >= 0; i -= 8) {\n    data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n  }\n\n  const I = getBytes(computeHmac(\"sha512\", chainCode, data));\n  return {\n    IL: I.slice(0, 32),\n    IR: I.slice(32)\n  };\n}\n\nfunction derivePath(node, path) {\n  const components = path.split(\"/\");\n  assertArgument(components.length > 0 && (components[0] === \"m\" || node.depth > 0), \"invalid path\", \"path\", path);\n\n  if (components[0] === \"m\") {\n    components.shift();\n  }\n\n  let result = node;\n\n  for (let i = 0; i < components.length; i++) {\n    const component = components[i];\n\n    if (component.match(/^[0-9]+'$/)) {\n      const index = parseInt(component.substring(0, component.length - 1));\n      assertArgument(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n      result = result.deriveChild(HardenedBit + index);\n    } else if (component.match(/^[0-9]+$/)) {\n      const index = parseInt(component);\n      assertArgument(index < HardenedBit, \"invalid path index\", `path[${i}]`, component);\n      result = result.deriveChild(index);\n    } else {\n      assertArgument(false, \"invalid path component\", `path[${i}]`, component);\n    }\n  }\n\n  return result;\n}\n/**\r\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\r\n *  from an HD Node using the [[link-bip-32]] stantard.\r\n *\r\n *  An HD Node forms a hierarchal structure with each HD Node having a\r\n *  private key and the ability to derive child HD Nodes, defined by\r\n *  a path indicating the index of each child.\r\n */\n\n\nexport class HDNodeWallet extends BaseWallet {\n  /**\r\n   *  The compressed public key.\r\n   */\n  publicKey;\n  /**\r\n   *  The fingerprint.\r\n   *\r\n   *  A fingerprint allows quick qay to detect parent and child nodes,\r\n   *  but developers should be prepared to deal with collisions as it\r\n   *  is only 4 bytes.\r\n   */\n\n  fingerprint;\n  /**\r\n   *  The parent fingerprint.\r\n   */\n\n  parentFingerprint;\n  /**\r\n   *  The mnemonic used to create this HD Node, if available.\r\n   *\r\n   *  Sources such as extended keys do not encode the mnemonic, in\r\n   *  which case this will be ``null``.\r\n   */\n\n  mnemonic;\n  /**\r\n   *  The chaincode, which is effectively a public key used\r\n   *  to derive children.\r\n   */\n\n  chainCode;\n  /**\r\n   *  The derivation path of this wallet.\r\n   *\r\n   *  Since extended keys do not provider full path details, this\r\n   *  may be ``null``, if instantiated from a source that does not\r\n   *  enocde it.\r\n   */\n\n  path;\n  /**\r\n   *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\r\n   *  the node is hardened.\r\n   */\n\n  index;\n  /**\r\n   *  The depth of this wallet, which is the number of components\r\n   *  in its path.\r\n   */\n\n  depth;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {\n    super(signingKey, provider);\n    assertPrivate(guard, _guard, \"HDNodeWallet\");\n    defineProperties(this, {\n      publicKey: signingKey.compressedPublicKey\n    });\n    const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);\n    defineProperties(this, {\n      parentFingerprint,\n      fingerprint,\n      chainCode,\n      path,\n      index,\n      depth\n    });\n    defineProperties(this, {\n      mnemonic\n    });\n  }\n\n  connect(provider) {\n    return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n  }\n\n  #account() {\n    const account = {\n      address: this.address,\n      privateKey: this.privateKey\n    };\n    const m = this.mnemonic;\n\n    if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n      account.mnemonic = {\n        path: this.path,\n        locale: \"en\",\n        entropy: m.entropy\n      };\n    }\n\n    return account;\n  }\n  /**\r\n   *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\r\n   *  %%password%%.\r\n   *\r\n   *  If %%progressCallback%% is specified, it will receive periodic\r\n   *  updates as the encryption process progreses.\r\n   */\n\n\n  async encrypt(password, progressCallback) {\n    return await encryptKeystoreJson(this.#account(), password, {\n      progressCallback\n    });\n  }\n  /**\r\n   *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\r\n   *  %%password%%.\r\n   *\r\n   *  It is preferred to use the [async version](encrypt) instead,\r\n   *  which allows a [[ProgressCallback]] to keep the user informed.\r\n   *\r\n   *  This method will block the event loop (freezing all UI) until\r\n   *  it is complete, which may be a non-trivial duration.\r\n   */\n\n\n  encryptSync(password) {\n    return encryptKeystoreJsonSync(this.#account(), password);\n  }\n  /**\r\n   *  The extended key.\r\n   *\r\n   *  This key will begin with the prefix ``xpriv`` and can be used to\r\n   *  reconstruct this HD Node to derive its children.\r\n   */\n\n\n  get extendedKey() {\n    // We only support the mainnet values for now, but if anyone needs\n    // testnet values, let me know. I believe current sentiment is that\n    // we should always use mainnet, and use BIP-44 to derive the network\n    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n    //   - Testnet: public=0x043587CF, private=0x04358394\n    assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"extendedKey\"\n    });\n    return encodeBase58Check(concat([\"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, concat([\"0x00\", this.privateKey])]));\n  }\n  /**\r\n   *  Returns true if this wallet has a path, providing a Type Guard\r\n   *  that the path is non-null.\r\n   */\n\n\n  hasPath() {\n    return this.path != null;\n  }\n  /**\r\n   *  Returns a neutered HD Node, which removes the private details\r\n   *  of an HD Node.\r\n   *\r\n   *  A neutered node has no private key, but can be used to derive\r\n   *  child addresses and other public data about the HD Node.\r\n   */\n\n\n  neuter() {\n    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);\n  }\n  /**\r\n   *  Return the child for %%index%%.\r\n   */\n\n\n  deriveChild(_index) {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index); // Base path\n\n    let path = this.path;\n\n    if (path) {\n      path += \"/\" + (index & ~HardenedBit);\n\n      if (index & HardenedBit) {\n        path += \"'\";\n      }\n    }\n\n    const {\n      IR,\n      IL\n    } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n    const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));\n    return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);\n  }\n  /**\r\n   *  Return the HDNode for %%path%% from this node.\r\n   */\n\n\n  derivePath(path) {\n    return derivePath(this, path);\n  }\n\n  static #fromSeed(_seed, mnemonic) {\n    assertArgument(isBytesLike(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n    const seed = getBytes(_seed, \"seed\");\n    assertArgument(seed.length >= 16 && seed.length <= 64, \"invalid seed\", \"seed\", \"[REDACTED]\");\n    const I = getBytes(computeHmac(\"sha512\", MasterSecret, seed));\n    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));\n    return new HDNodeWallet(_guard, signingKey, \"0x00000000\", hexlify(I.slice(32)), \"m\", 0, 0, mnemonic, null);\n  }\n  /**\r\n   *  Creates a new HD Node from %%extendedKey%%.\r\n   *\r\n   *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\r\n   *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\r\n   *  or full HD Node ([[HDNodeWallet) respectively.\r\n   */\n\n\n  static fromExtendedKey(extendedKey) {\n    const bytes = toBeArray(decodeBase58(extendedKey)); // @TODO: redact\n\n    assertArgument(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n    const depth = bytes[4];\n    const parentFingerprint = hexlify(bytes.slice(5, 9));\n    const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n    const chainCode = hexlify(bytes.slice(13, 45));\n    const key = bytes.slice(45, 78);\n\n    switch (hexlify(bytes.slice(0, 4))) {\n      // Public Key\n      case \"0x0488b21e\":\n      case \"0x043587cf\":\n        {\n          const publicKey = hexlify(key);\n          return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);\n        }\n      // Private Key\n\n      case \"0x0488ade4\":\n      case \"0x04358394 \":\n        if (key[0] !== 0) {\n          break;\n        }\n\n        return new HDNodeWallet(_guard, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);\n    }\n\n    assertArgument(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n  }\n  /**\r\n   *  Creates a new random HDNode.\r\n   */\n\n\n  static createRandom(password, path, wordlist) {\n    if (password == null) {\n      password = \"\";\n    }\n\n    if (path == null) {\n      path = defaultPath;\n    }\n\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n\n    const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist);\n    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n  }\n  /**\r\n   *  Create am HD Node from %%mnemonic%%.\r\n   */\n\n\n  static fromMnemonic(mnemonic, path) {\n    if (!path) {\n      path = defaultPath;\n    }\n\n    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n  }\n  /**\r\n   *  Creates an HD Node from a mnemonic %%phrase%%.\r\n   */\n\n\n  static fromPhrase(phrase, password, path, wordlist) {\n    if (password == null) {\n      password = \"\";\n    }\n\n    if (path == null) {\n      path = defaultPath;\n    }\n\n    if (wordlist == null) {\n      wordlist = LangEn.wordlist();\n    }\n\n    const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);\n    return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n  }\n  /**\r\n   *  Creates an HD Node from a %%seed%%.\r\n   */\n\n\n  static fromSeed(seed) {\n    return HDNodeWallet.#fromSeed(seed, null);\n  }\n\n}\n/**\r\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\r\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\r\n *\r\n *  The can be created by using an extended ``xpub`` key to\r\n *  [[HDNodeWallet_fromExtendedKey]] or by\r\n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\r\n */\n\nexport class HDNodeVoidWallet extends VoidSigner {\n  /**\r\n   *  The compressed public key.\r\n   */\n  publicKey;\n  /**\r\n   *  The fingerprint.\r\n   *\r\n   *  A fingerprint allows quick qay to detect parent and child nodes,\r\n   *  but developers should be prepared to deal with collisions as it\r\n   *  is only 4 bytes.\r\n   */\n\n  fingerprint;\n  /**\r\n   *  The parent node fingerprint.\r\n   */\n\n  parentFingerprint;\n  /**\r\n   *  The chaincode, which is effectively a public key used\r\n   *  to derive children.\r\n   */\n\n  chainCode;\n  /**\r\n   *  The derivation path of this wallet.\r\n   *\r\n   *  Since extended keys do not provider full path details, this\r\n   *  may be ``null``, if instantiated from a source that does not\r\n   *  enocde it.\r\n   */\n\n  path;\n  /**\r\n   *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\r\n   *  the node is hardened.\r\n   */\n\n  index;\n  /**\r\n   *  The depth of this wallet, which is the number of components\r\n   *  in its path.\r\n   */\n\n  depth;\n  /**\r\n   *  @private\r\n   */\n\n  constructor(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {\n    super(address, provider);\n    assertPrivate(guard, _guard, \"HDNodeVoidWallet\");\n    defineProperties(this, {\n      publicKey\n    });\n    const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);\n    defineProperties(this, {\n      publicKey,\n      fingerprint,\n      parentFingerprint,\n      chainCode,\n      path,\n      index,\n      depth\n    });\n  }\n\n  connect(provider) {\n    return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n  }\n  /**\r\n   *  The extended key.\r\n   *\r\n   *  This key will begin with the prefix ``xpub`` and can be used to\r\n   *  reconstruct this neutered key to derive its children addresses.\r\n   */\n\n\n  get extendedKey() {\n    // We only support the mainnet values for now, but if anyone needs\n    // testnet values, let me know. I believe current sentiment is that\n    // we should always use mainnet, and use BIP-44 to derive the network\n    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n    //   - Testnet: public=0x043587CF, private=0x04358394\n    assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"extendedKey\"\n    });\n    return encodeBase58Check(concat([\"0x0488B21E\", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));\n  }\n  /**\r\n   *  Returns true if this wallet has a path, providing a Type Guard\r\n   *  that the path is non-null.\r\n   */\n\n\n  hasPath() {\n    return this.path != null;\n  }\n  /**\r\n   *  Return the child for %%index%%.\r\n   */\n\n\n  deriveChild(_index) {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index); // Base path\n\n    let path = this.path;\n\n    if (path) {\n      path += \"/\" + (index & ~HardenedBit);\n\n      if (index & HardenedBit) {\n        path += \"'\";\n      }\n    }\n\n    const {\n      IR,\n      IL\n    } = ser_I(index, this.chainCode, this.publicKey, null);\n    const Ki = SigningKey.addPoints(IL, this.publicKey, true);\n    const address = computeAddress(Ki);\n    return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);\n  }\n  /**\r\n   *  Return the signer for %%path%% from this node.\r\n   */\n\n\n  derivePath(path) {\n    return derivePath(this, path);\n  }\n\n}\n/*\r\nexport class HDNodeWalletManager {\r\n    #root: HDNodeWallet;\r\n\r\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\r\n        if (password == null) { password = \"\"; }\r\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\r\n        if (locale == null) { locale = LangEn.wordlist(); }\r\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\r\n    }\r\n\r\n    getSigner(index?: number): HDNodeWallet {\r\n        return this.#root.deriveChild((index == null) ? 0: index);\r\n    }\r\n}\r\n*/\n\n/**\r\n *  Returns the [[link-bip-32]] path for the acount at %%index%%.\r\n *\r\n *  This is the pattern used by wallets like Ledger.\r\n *\r\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\r\n *  some software.\r\n */\n\nexport function getAccountPath(_index) {\n  const index = getNumber(_index, \"index\");\n  assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n  return `m/44'/60'/${index}'/0/0`;\n}\n/**\r\n *  Returns the path using an alternative pattern for deriving accounts,\r\n *  at %%index%%.\r\n *\r\n *  This derivation path uses the //index// component rather than the\r\n *  //account// component to derive sequential accounts.\r\n *\r\n *  This is the pattern used by wallets like MetaMask.\r\n */\n\nexport function getIndexedAccountPath(_index) {\n  const index = getNumber(_index, \"index\");\n  assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n  return `m/44'/60'/0'/0/${index}`;\n}","map":{"version":3,"mappings":"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","names":["computeHmac","randomBytes","ripemd160","SigningKey","sha256","VoidSigner","computeAddress","concat","dataSlice","decodeBase58","defineProperties","encodeBase58","getBytes","hexlify","isBytesLike","getNumber","toBeArray","toBigInt","toBeHex","assertPrivate","assert","assertArgument","LangEn","BaseWallet","Mnemonic","encryptKeystoreJson","encryptKeystoreJsonSync","defaultPath","MasterSecret","Uint8Array","HardenedBit","N","BigInt","Nibbles","zpad","value","length","result","Math","trunc","encodeBase58Check","_value","check","bytes","_guard","ser_I","index","chainCode","publicKey","privateKey","data","operation","set","i","I","IL","slice","IR","derivePath","node","path","components","split","depth","shift","component","match","parseInt","substring","deriveChild","HDNodeWallet","fingerprint","parentFingerprint","mnemonic","constructor","guard","signingKey","provider","compressedPublicKey","connect","account","address","m","wordlist","locale","password","entropy","encrypt","progressCallback","encryptSync","extendedKey","hasPath","neuter","HDNodeVoidWallet","_index","ki","_seed","seed","fromExtendedKey","key","createRandom","fromEntropy","computeSeed","fromMnemonic","fromPhrase","phrase","fromSeed","Ki","addPoints","getAccountPath","getIndexedAccountPath"],"sourceRoot":"","sources":["../../src.ts/wallet/hdwallet.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}