{"ast":null,"code":"/**\n *  About Interface\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nimport { keccak256 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, getBytesCopy, hexlify, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex, assert } from \"../utils/index.js\";\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType } from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\nexport { checkResultErrors, Result };\nexport class LogDescription {\n  fragment;\n  name;\n  signature;\n  topic;\n  args;\n\n  constructor(fragment, topic, args) {\n    const name = fragment.name,\n          signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      signature,\n      topic,\n      args\n    });\n  }\n\n}\nexport class TransactionDescription {\n  fragment;\n  name;\n  args;\n  signature;\n  selector;\n  value;\n\n  constructor(fragment, selector, args, value) {\n    const name = fragment.name,\n          signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector,\n      value\n    });\n  }\n\n}\nexport class ErrorDescription {\n  fragment;\n  name;\n  args;\n  signature;\n  selector;\n\n  constructor(fragment, selector, args) {\n    const name = fragment.name,\n          signature = fragment.format();\n    defineProperties(this, {\n      fragment,\n      name,\n      args,\n      signature,\n      selector\n    });\n  }\n\n}\nexport class Indexed {\n  hash;\n  _isIndexed;\n\n  static isIndexed(value) {\n    return !!(value && value._isIndexed);\n  }\n\n  constructor(hash) {\n    defineProperties(this, {\n      hash,\n      _isIndexed: true\n    });\n  }\n\n} // https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\n\nconst PanicReasons = {\n  \"0\": \"generic panic\",\n  \"1\": \"assert(false)\",\n  \"17\": \"arithmetic overflow\",\n  \"18\": \"division or modulo by zero\",\n  \"33\": \"enum overflow\",\n  \"34\": \"invalid encoded storage byte array accessed\",\n  \"49\": \"out-of-bounds array access; popping on an empty array\",\n  \"50\": \"out-of-bounds access of an array or bytesN\",\n  \"65\": \"out of memory\",\n  \"81\": \"uninitialized function\"\n};\nconst BuiltinErrors = {\n  \"0x08c379a0\": {\n    signature: \"Error(string)\",\n    name: \"Error\",\n    inputs: [\"string\"],\n    reason: message => {\n      return `reverted with reason string ${JSON.stringify(message)}`;\n    }\n  },\n  \"0x4e487b71\": {\n    signature: \"Panic(uint256)\",\n    name: \"Panic\",\n    inputs: [\"uint256\"],\n    reason: code => {\n      let reason = \"unknown panic code\";\n\n      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n        reason = PanicReasons[code.toString()];\n      }\n\n      return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n    }\n  }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\n\nexport class Interface {\n  /**\n   *  All the Contract ABI members (i.e. methods, events, errors, etc).\n   */\n  fragments;\n  /**\n   *  The Contract constructor.\n   */\n\n  deploy;\n  /**\n   *  The Fallback method, if any.\n   */\n\n  fallback;\n  /**\n   *  If receiving ether is supported.\n   */\n\n  receive;\n  #errors;\n  #events;\n  #functions; //    #structs: Map<string, StructFragment>;\n\n  #abiCoder;\n  /**\n   *  Create a new Interface for the %%fragments%%.\n   */\n\n  constructor(fragments) {\n    let abi = [];\n\n    if (typeof fragments === \"string\") {\n      abi = JSON.parse(fragments);\n    } else {\n      abi = fragments;\n    }\n\n    this.#functions = new Map();\n    this.#errors = new Map();\n    this.#events = new Map(); //        this.#structs = new Map();\n\n    const frags = [];\n\n    for (const a of abi) {\n      try {\n        frags.push(Fragment.from(a));\n      } catch (error) {\n        console.log(\"EE\", error);\n      }\n    }\n\n    defineProperties(this, {\n      fragments: Object.freeze(frags)\n    });\n    let fallback = null;\n    let receive = false;\n    this.#abiCoder = this.getAbiCoder(); // Add all fragments by their signature\n\n    this.fragments.forEach((fragment, index) => {\n      let bucket;\n\n      switch (fragment.type) {\n        case \"constructor\":\n          if (this.deploy) {\n            console.log(\"duplicate definition - constructor\");\n            return;\n          } //checkNames(fragment, \"input\", fragment.inputs);\n\n\n          defineProperties(this, {\n            deploy: fragment\n          });\n          return;\n\n        case \"fallback\":\n          if (fragment.inputs.length === 0) {\n            receive = true;\n          } else {\n            assertArgument(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n            fallback = fragment;\n            receive = fallback.payable;\n          }\n\n          return;\n\n        case \"function\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n          bucket = this.#functions;\n          break;\n\n        case \"event\":\n          //checkNames(fragment, \"input\", fragment.inputs);\n          bucket = this.#events;\n          break;\n\n        case \"error\":\n          bucket = this.#errors;\n          break;\n\n        default:\n          return;\n      } // Two identical entries; ignore it\n\n\n      const signature = fragment.format();\n\n      if (bucket.has(signature)) {\n        return;\n      }\n\n      bucket.set(signature, fragment);\n    }); // If we do not have a constructor add a default\n\n    if (!this.deploy) {\n      defineProperties(this, {\n        deploy: ConstructorFragment.from(\"constructor()\")\n      });\n    }\n\n    defineProperties(this, {\n      fallback,\n      receive\n    });\n  }\n  /**\n   *  Returns the entire Human-Readable ABI, as an array of\n   *  signatures, optionally as %%minimal%% strings, which\n   *  removes parameter names and unneceesary spaces.\n   */\n\n\n  format(minimal) {\n    const format = minimal ? \"minimal\" : \"full\";\n    const abi = this.fragments.map(f => f.format(format));\n    return abi;\n  }\n  /**\n   *  Return the JSON-encoded ABI. This is the format Solidiy\n   *  returns.\n   */\n\n\n  formatJson() {\n    const abi = this.fragments.map(f => f.format(\"json\")); // We need to re-bundle the JSON fragments a bit\n\n    return JSON.stringify(abi.map(j => JSON.parse(j)));\n  }\n  /**\n   *  The ABI coder that will be used to encode and decode binary\n   *  data.\n   */\n\n\n  getAbiCoder() {\n    return AbiCoder.defaultAbiCoder();\n  } // Find a function definition by any means necessary (unless it is ambiguous)\n\n\n  #getFunction(key, values, forceUnique) {\n    // Selector\n    if (isHexString(key)) {\n      const selector = key.toLowerCase();\n\n      for (const fragment of this.#functions.values()) {\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n\n      return null;\n    } // It is a bare name, look up the function (will return null if ambiguous)\n\n\n    if (key.indexOf(\"(\") === -1) {\n      const matching = [];\n\n      for (const [name, fragment] of this.#functions) {\n        if (name.split(\"(\"\n        /* fix:) */\n        )[0] === key) {\n          matching.push(fragment);\n        }\n      }\n\n      if (values) {\n        const lastValue = values.length > 0 ? values[values.length - 1] : null;\n        let valueLength = values.length;\n        let allowOptions = true;\n\n        if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n          allowOptions = false;\n          valueLength--;\n        } // Remove all matches that don't have a compatible length. The args\n        // may contain an overrides, so the match may have n or n - 1 parameters\n\n\n        for (let i = matching.length - 1; i >= 0; i--) {\n          const inputs = matching[i].inputs.length;\n\n          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n            matching.splice(i, 1);\n          }\n        } // Remove all matches that don't match the Typed signature\n\n\n        for (let i = matching.length - 1; i >= 0; i--) {\n          const inputs = matching[i].inputs;\n\n          for (let j = 0; j < values.length; j++) {\n            // Not a typed value\n            if (!Typed.isTyped(values[j])) {\n              continue;\n            } // We are past the inputs\n\n\n            if (j >= inputs.length) {\n              if (values[j].type === \"overrides\") {\n                continue;\n              }\n\n              matching.splice(i, 1);\n              break;\n            } // Make sure the value type matches the input type\n\n\n            if (values[j].type !== inputs[j].baseType) {\n              matching.splice(i, 1);\n              break;\n            }\n          }\n        }\n      } // We found a single matching signature with an overrides, but the\n      // last value is something that cannot possibly be an options\n\n\n      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n        const lastArg = values[values.length - 1];\n\n        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== \"object\") {\n          matching.splice(0, 1);\n        }\n      }\n\n      if (matching.length === 0) {\n        return null;\n      }\n\n      if (matching.length > 1 && forceUnique) {\n        const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n      }\n\n      return matching[0];\n    } // Normalize the signature and lookup the function\n\n\n    const result = this.#functions.get(FunctionFragment.from(key).format());\n\n    if (result) {\n      return result;\n    }\n\n    return null;\n  }\n  /**\n   *  Get the function name for %%key%%, which may be a function selector,\n   *  function name or function signature that belongs to the ABI.\n   */\n\n\n  getFunctionName(key) {\n    const fragment = this.#getFunction(key, null, false);\n    assertArgument(fragment, \"no matching function\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n   *  selector, function name or function signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple functions match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single function in\n   *  the ABI, this will throw.\n   */\n\n\n  getFunction(key, values) {\n    return this.#getFunction(key, values || null, true);\n  }\n  /**\n   *  Iterate over all functions, calling %%callback%%, sorted by their name.\n   */\n\n\n  forEachFunction(callback) {\n    const names = Array.from(this.#functions.keys());\n    names.sort((a, b) => a.localeCompare(b));\n\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(this.#functions.get(name), i);\n    }\n  } // Find an event definition by any means necessary (unless it is ambiguous)\n\n\n  #getEvent(key, values, forceUnique) {\n    // EventTopic\n    if (isHexString(key)) {\n      const eventTopic = key.toLowerCase();\n\n      for (const fragment of this.#events.values()) {\n        if (eventTopic === fragment.topicHash) {\n          return fragment;\n        }\n      }\n\n      return null;\n    } // It is a bare name, look up the function (will return null if ambiguous)\n\n\n    if (key.indexOf(\"(\") === -1) {\n      const matching = [];\n\n      for (const [name, fragment] of this.#events) {\n        if (name.split(\"(\"\n        /* fix:) */\n        )[0] === key) {\n          matching.push(fragment);\n        }\n      }\n\n      if (values) {\n        // Remove all matches that don't have a compatible length.\n        for (let i = matching.length - 1; i >= 0; i--) {\n          if (matching[i].inputs.length < values.length) {\n            matching.splice(i, 1);\n          }\n        } // Remove all matches that don't match the Typed signature\n\n\n        for (let i = matching.length - 1; i >= 0; i--) {\n          const inputs = matching[i].inputs;\n\n          for (let j = 0; j < values.length; j++) {\n            // Not a typed value\n            if (!Typed.isTyped(values[j])) {\n              continue;\n            } // Make sure the value type matches the input type\n\n\n            if (values[j].type !== inputs[j].baseType) {\n              matching.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      if (matching.length === 0) {\n        return null;\n      }\n\n      if (matching.length > 1 && forceUnique) {\n        const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n      }\n\n      return matching[0];\n    } // Normalize the signature and lookup the function\n\n\n    const result = this.#events.get(EventFragment.from(key).format());\n\n    if (result) {\n      return result;\n    }\n\n    return null;\n  }\n  /**\n   *  Get the event name for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   */\n\n\n  getEventName(key) {\n    const fragment = this.#getEvent(key, null, false);\n    assertArgument(fragment, \"no matching event\", \"key\", key);\n    return fragment.name;\n  }\n  /**\n   *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n   *  event name or event signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple events match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single event in\n   *  the ABI, this will throw.\n   */\n\n\n  getEvent(key, values) {\n    return this.#getEvent(key, values || null, true);\n  }\n  /**\n   *  Iterate over all events, calling %%callback%%, sorted by their name.\n   */\n\n\n  forEachEvent(callback) {\n    const names = Array.from(this.#events.keys());\n    names.sort((a, b) => a.localeCompare(b));\n\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(this.#events.get(name), i);\n    }\n  }\n  /**\n   *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n   *  selector, error name or error signature that belongs to the ABI.\n   *\n   *  If %%values%% is provided, it will use the Typed API to handle\n   *  ambiguous cases where multiple errors match by name.\n   *\n   *  If the %%key%% and %%values%% do not refine to a single error in\n   *  the ABI, this will throw.\n   */\n\n\n  getError(key, values) {\n    if (isHexString(key)) {\n      const selector = key.toLowerCase();\n\n      if (BuiltinErrors[selector]) {\n        return ErrorFragment.from(BuiltinErrors[selector].signature);\n      }\n\n      for (const fragment of this.#errors.values()) {\n        if (selector === fragment.selector) {\n          return fragment;\n        }\n      }\n\n      return null;\n    } // It is a bare name, look up the function (will return null if ambiguous)\n\n\n    if (key.indexOf(\"(\") === -1) {\n      const matching = [];\n\n      for (const [name, fragment] of this.#errors) {\n        if (name.split(\"(\"\n        /* fix:) */\n        )[0] === key) {\n          matching.push(fragment);\n        }\n      }\n\n      if (matching.length === 0) {\n        if (key === \"Error\") {\n          return ErrorFragment.from(\"error Error(string)\");\n        }\n\n        if (key === \"Panic\") {\n          return ErrorFragment.from(\"error Panic(uint256)\");\n        }\n\n        return null;\n      } else if (matching.length > 1) {\n        const matchStr = matching.map(m => JSON.stringify(m.format())).join(\", \");\n        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n      }\n\n      return matching[0];\n    } // Normalize the signature and lookup the function\n\n\n    key = ErrorFragment.from(key).format();\n\n    if (key === \"Error(string)\") {\n      return ErrorFragment.from(\"error Error(string)\");\n    }\n\n    if (key === \"Panic(uint256)\") {\n      return ErrorFragment.from(\"error Panic(uint256)\");\n    }\n\n    const result = this.#errors.get(key);\n\n    if (result) {\n      return result;\n    }\n\n    return null;\n  }\n  /**\n   *  Iterate over all errors, calling %%callback%%, sorted by their name.\n   */\n\n\n  forEachError(callback) {\n    const names = Array.from(this.#errors.keys());\n    names.sort((a, b) => a.localeCompare(b));\n\n    for (let i = 0; i < names.length; i++) {\n      const name = names[i];\n      callback(this.#errors.get(name), i);\n    }\n  } // Get the 4-byte selector used by Solidity to identify a function\n\n  /*\n  getSelector(fragment: ErrorFragment | FunctionFragment): string {\n  if (typeof(fragment) === \"string\") {\n      const matches: Array<Fragment> = [ ];\n       try { matches.push(this.getFunction(fragment)); } catch (error) { }\n      try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n       if (matches.length === 0) {\n          logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n      } else if (matches.length > 1) {\n          logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n      }\n       fragment = matches[0];\n  }\n   return dataSlice(id(fragment.format()), 0, 4);\n  }\n  */\n  // Get the 32-byte topic hash used by Solidity to identify an event\n\n  /*\n  getEventTopic(fragment: EventFragment): string {\n      //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n      return id(fragment.format());\n  }\n  */\n\n\n  _decodeParams(params, data) {\n    return this.#abiCoder.decode(params, data);\n  }\n\n  _encodeParams(params, values) {\n    return this.#abiCoder.encode(params, values);\n  }\n  /**\n   *  Encodes a ``tx.data`` object for deploying the Contract with\n   *  the %%values%% as the constructor arguments.\n   */\n\n\n  encodeDeploy(values) {\n    return this._encodeParams(this.deploy.inputs, values || []);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified error (see [[getError]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n\n\n  decodeErrorResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      assertArgument(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n\n    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n    return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n  }\n  /**\n   *  Encodes the transaction revert data for a call result that\n   *  reverted from the the Contract with the sepcified %%error%%\n   *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n\n\n  encodeErrorResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getError(fragment);\n      assertArgument(f, \"unknown error\", \"fragment\", fragment);\n      fragment = f;\n    }\n\n    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the %%data%% from a transaction ``tx.data`` for\n   *  the function specified (see [[getFunction]] for valid values\n   *  for %%fragment%%).\n   *\n   *  Most developers should prefer the [[parseTransaction]] method\n   *  instead, which will automatically detect the fragment.\n   */\n\n\n  decodeFunctionData(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n\n    assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n    return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n  }\n  /**\n   *  Encodes the ``tx.data`` for a transaction that calls the function\n   *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n   *  the %%values%%.\n   */\n\n\n  encodeFunctionData(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n\n    return concat([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);\n  }\n  /**\n   *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values for\n   *  %%key%%).\n   *\n   *  Most developers should prefer the [[parseResult]] method instead,\n   *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n   *  corresponding error.\n   */\n\n\n  decodeFunctionResult(fragment, data) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n\n    let message = \"invalid length for result data\";\n    const bytes = getBytesCopy(data);\n\n    if (bytes.length % 32 === 0) {\n      try {\n        return this.#abiCoder.decode(fragment.outputs, bytes);\n      } catch (error) {\n        message = \"could not decode result data\";\n      }\n    } // Call returned data with no error, but the data is junk\n\n\n    assert(false, message, \"BAD_DATA\", {\n      value: hexlify(bytes),\n      info: {\n        method: fragment.name,\n        signature: fragment.format()\n      }\n    });\n  }\n\n  makeError(_data, tx) {\n    const data = getBytes(_data, \"data\");\n    const error = AbiCoder.getBuiltinCallException(\"call\", tx, data); // Not a built-in error; try finding a custom error\n\n    if (!error.message.match(/could not decode/)) {\n      const selector = hexlify(data.slice(0, 4));\n      error.message = \"execution reverted (unknown custom error)\";\n      const ef = this.getError(selector);\n\n      if (ef) {\n        try {\n          error.revert = {\n            name: ef.name,\n            signature: ef.format(),\n            args: this.#abiCoder.decode(ef.inputs, data.slice(4))\n          };\n          error.reason = error.revert.signature;\n          error.message = `execution reverted: ${error.reason}`;\n        } catch (e) {\n          error.message = `execution reverted (coult not decode custom error)`;\n        }\n      }\n    } // Add the invocation, if available\n\n\n    const parsed = this.parseTransaction(tx);\n\n    if (parsed) {\n      error.invocation = {\n        method: parsed.name,\n        signature: parsed.signature,\n        args: parsed.args\n      };\n    }\n\n    return error;\n  }\n  /**\n   *  Encodes the result data (e.g. from an ``eth_call``) for the\n   *  specified function (see [[getFunction]] for valid values\n   *  for %%fragment%%) with %%values%%.\n   *\n   *  This is generally not used by most developers, unless trying to mock\n   *  a result from a Contract.\n   */\n\n\n  encodeFunctionResult(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getFunction(fragment);\n      assertArgument(f, \"unknown function\", \"fragment\", fragment);\n      fragment = f;\n    }\n\n    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));\n  }\n  /*\n      spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n          const promises: Array<Promise<>> = [ ];\n          const process = function(type: ParamType, value: any): any {\n              if (type.baseType === \"array\") {\n                  return descend(type.child\n              }\n              if (type. === \"address\") {\n              }\n          };\n  \n          const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n              if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n              \n          };\n  \n          const result: Array<any> = [ ];\n          values.forEach((value, index) => {\n              if (value == null) {\n                  topics.push(null);\n              } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                  logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n              } else if (Array.isArray(value)) {\n                  topics.push(value.map((value) => encodeTopic(param, value)));\n              } else {\n                  topics.push(encodeTopic(param, value));\n              }\n          });\n      }\n  */\n  // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n\n\n  encodeFilterTopics(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n\n    assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", {\n      count: values.length,\n      expectedCount: fragment.inputs.length\n    });\n    const topics = [];\n\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    } // @TODO: Use the coders for this; to properly support tuples, etc.\n\n\n    const encodeTopic = (param, value) => {\n      if (param.type === \"string\") {\n        return id(value);\n      } else if (param.type === \"bytes\") {\n        return keccak256(hexlify(value));\n      }\n\n      if (param.type === \"bool\" && typeof value === \"boolean\") {\n        value = value ? \"0x01\" : \"0x00\";\n      }\n\n      if (param.type.match(/^u?int/)) {\n        value = toBeHex(value);\n      } // Check addresses are valid\n\n\n      if (param.type === \"address\") {\n        this.#abiCoder.encode([\"address\"], [value]);\n      }\n\n      return zeroPadValue(hexlify(value), 32); //@TOOD should probably be return toHex(value, 32)\n    };\n\n    values.forEach((value, index) => {\n      const param = fragment.inputs[index];\n\n      if (!param.indexed) {\n        assertArgument(value == null, \"cannot filter non-indexed parameters; must be null\", \"contract.\" + param.name, value);\n        return;\n      }\n\n      if (value == null) {\n        topics.push(null);\n      } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n        assertArgument(false, \"filtering with tuples or arrays not supported\", \"contract.\" + param.name, value);\n      } else if (Array.isArray(value)) {\n        topics.push(value.map(value => encodeTopic(param, value)));\n      } else {\n        topics.push(encodeTopic(param, value));\n      }\n    }); // Trim off trailing nulls\n\n    while (topics.length && topics[topics.length - 1] === null) {\n      topics.pop();\n    }\n\n    return topics;\n  }\n\n  encodeEventLog(fragment, values) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n\n    const topics = [];\n    const dataTypes = [];\n    const dataValues = [];\n\n    if (!fragment.anonymous) {\n      topics.push(fragment.topicHash);\n    }\n\n    assertArgument(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n    fragment.inputs.forEach((param, index) => {\n      const value = values[index];\n\n      if (param.indexed) {\n        if (param.type === \"string\") {\n          topics.push(id(value));\n        } else if (param.type === \"bytes\") {\n          topics.push(keccak256(value));\n        } else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n          // @TODO\n          throw new Error(\"not implemented\");\n        } else {\n          topics.push(this.#abiCoder.encode([param.type], [value]));\n        }\n      } else {\n        dataTypes.push(param);\n        dataValues.push(value);\n      }\n    });\n    return {\n      data: this.#abiCoder.encode(dataTypes, dataValues),\n      topics: topics\n    };\n  } // Decode a filter for the event and the search criteria\n\n\n  decodeEventLog(fragment, data, topics) {\n    if (typeof fragment === \"string\") {\n      const f = this.getEvent(fragment);\n      assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n      fragment = f;\n    }\n\n    if (topics != null && !fragment.anonymous) {\n      const eventTopic = fragment.topicHash;\n      assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n      topics = topics.slice(1);\n    }\n\n    const indexed = [];\n    const nonIndexed = [];\n    const dynamic = [];\n    fragment.inputs.forEach((param, index) => {\n      if (param.indexed) {\n        if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n          indexed.push(ParamType.from({\n            type: \"bytes32\",\n            name: param.name\n          }));\n          dynamic.push(true);\n        } else {\n          indexed.push(param);\n          dynamic.push(false);\n        }\n      } else {\n        nonIndexed.push(param);\n        dynamic.push(false);\n      }\n    });\n    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;\n    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true); //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n\n    const values = [];\n    const keys = [];\n    let nonIndexedIndex = 0,\n        indexedIndex = 0;\n    fragment.inputs.forEach((param, index) => {\n      let value = null;\n\n      if (param.indexed) {\n        if (resultIndexed == null) {\n          value = new Indexed(null);\n        } else if (dynamic[index]) {\n          value = new Indexed(resultIndexed[indexedIndex++]);\n        } else {\n          try {\n            value = resultIndexed[indexedIndex++];\n          } catch (error) {\n            value = error;\n          }\n        }\n      } else {\n        try {\n          value = resultNonIndexed[nonIndexedIndex++];\n        } catch (error) {\n          value = error;\n        }\n      }\n\n      values.push(value);\n      keys.push(param.name || null);\n    });\n    return Result.fromItems(values, keys);\n  }\n  /**\n   *  Parses a transaction, finding the matching function and extracts\n   *  the parameter values along with other useful function details.\n   *\n   *  If the matching function cannot be found, return null.\n   */\n\n\n  parseTransaction(tx) {\n    const data = getBytes(tx.data, \"tx.data\");\n    const value = getBigInt(tx.value != null ? tx.value : 0, \"tx.value\");\n    const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n\n    if (!fragment) {\n      return null;\n    }\n\n    const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n    return new TransactionDescription(fragment, fragment.selector, args, value);\n  }\n\n  parseCallResult(data) {\n    throw new Error(\"@TODO\");\n  }\n  /**\n   *  Parses a receipt log, finding the matching event and extracts\n   *  the parameter values along with other useful event details.\n   *\n   *  If the matching event cannot be found, returns null.\n   */\n\n\n  parseLog(log) {\n    const fragment = this.getEvent(log.topics[0]);\n\n    if (!fragment || fragment.anonymous) {\n      return null;\n    } // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n    //        Probably not, because just because it is the only event in the ABI does\n    //        not mean we have the full ABI; maybe just a fragment?\n\n\n    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n  }\n  /**\n   *  Parses a revert data, finding the matching error and extracts\n   *  the parameter values along with other useful error details.\n   *\n   *  If the matching event cannot be found, returns null.\n   */\n\n\n  parseError(data) {\n    const hexData = hexlify(data);\n    const fragment = this.getError(dataSlice(hexData, 0, 4));\n\n    if (!fragment) {\n      return null;\n    }\n\n    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n    return new ErrorDescription(fragment, fragment.selector, args);\n  }\n  /**\n   *  Creates a new [[Interface]] from the ABI %%value%%.\n   *\n   *  The %%value%% may be provided as an existing [[Interface]] object,\n   *  a JSON-encoded ABI or any Human-Readable ABI format.\n   */\n\n\n  static from(value) {\n    // Already an Interface, which is immutable\n    if (value instanceof Interface) {\n      return value;\n    } // JSON\n\n\n    if (typeof value === \"string\") {\n      return new Interface(JSON.parse(value));\n    } // Maybe an interface from an older version, or from a symlinked copy\n\n\n    if (typeof value.format === \"function\") {\n      return new Interface(value.format(\"json\"));\n    } // Array of fragments\n\n\n    return new Interface(value);\n  }\n\n}","map":{"version":3,"mappings":"AAAA;;;;;AAMA,SAASA,SAAT,QAA0B,oBAA1B;AACA,SAASC,EAAT,QAAmB,kBAAnB;AACA,SACIC,MADJ,EACYC,SADZ,EACuBC,SADvB,EACkCC,QADlC,EAC4CC,YAD5C,EAEIC,OAFJ,EAEaC,YAFb,EAE2BC,WAF3B,EAEwCC,gBAFxC,EAE0DC,cAF1D,EAE0EC,OAF1E,EAGIC,MAHJ,QAIO,mBAJP;AAMA,SAASC,QAAT,QAAyB,gBAAzB;AACA,SAASC,iBAAT,EAA4BC,MAA5B,QAA0C,4BAA1C;AACA,SACIC,mBADJ,EACyBC,aADzB,EACwCC,aADxC,EAEIC,QAFJ,EAEcC,gBAFd,EAEgCC,SAFhC,QAGO,gBAHP;AAIA,SAASC,KAAT,QAAsB,YAAtB;AAOA,SAASR,iBAAT,EAA4BC,MAA5B;AAEA,OAAM,MAAOQ,cAAP,CAAqB;AACdC,UAAQ;AACRC,MAAI;AACJC,WAAS;AACTC,OAAK;AACLC,MAAI;;AAEbC,cAAYL,QAAZ,EAAqCG,KAArC,EAAoDC,IAApD,EAAgE;AAC5D,UAAMH,IAAI,GAAGD,QAAQ,CAACC,IAAtB;AAAA,UAA4BC,SAAS,GAAGF,QAAQ,CAACM,MAAT,EAAxC;AACArB,oBAAgB,CAAiB,IAAjB,EAAuB;AACnCe,cADmC;AACzBC,UADyB;AACnBC,eADmB;AACRC,WADQ;AACDC;AADC,KAAvB,CAAhB;AAGH;;AAZsB;AAe3B,OAAM,MAAOG,sBAAP,CAA6B;AACtBP,UAAQ;AACRC,MAAI;AACJG,MAAI;AACJF,WAAS;AACTM,UAAQ;AACRC,OAAK;;AAEdJ,cAAYL,QAAZ,EAAwCQ,QAAxC,EAA0DJ,IAA1D,EAAwEK,KAAxE,EAAqF;AACjF,UAAMR,IAAI,GAAGD,QAAQ,CAACC,IAAtB;AAAA,UAA4BC,SAAS,GAAGF,QAAQ,CAACM,MAAT,EAAxC;AACArB,oBAAgB,CAAyB,IAAzB,EAA+B;AAC3Ce,cAD2C;AACjCC,UADiC;AAC3BG,UAD2B;AACrBF,eADqB;AACVM,cADU;AACAC;AADA,KAA/B,CAAhB;AAGH;;AAb8B;AAgBnC,OAAM,MAAOC,gBAAP,CAAuB;AAChBV,UAAQ;AACRC,MAAI;AACJG,MAAI;AACJF,WAAS;AACTM,UAAQ;;AAEjBH,cAAYL,QAAZ,EAAqCQ,QAArC,EAAuDJ,IAAvD,EAAmE;AAC/D,UAAMH,IAAI,GAAGD,QAAQ,CAACC,IAAtB;AAAA,UAA4BC,SAAS,GAAGF,QAAQ,CAACM,MAAT,EAAxC;AACArB,oBAAgB,CAAmB,IAAnB,EAAyB;AACrCe,cADqC;AAC3BC,UAD2B;AACrBG,UADqB;AACfF,eADe;AACJM;AADI,KAAzB,CAAhB;AAGH;;AAZwB;AAe7B,OAAM,MAAOG,OAAP,CAAc;AACPC,MAAI;AACJC,YAAU;;AAEH,SAATC,SAAS,CAACL,KAAD,EAAW;AACvB,WAAO,CAAC,EAAEA,KAAK,IAAIA,KAAK,CAACI,UAAjB,CAAR;AACH;;AAEDR,cAAYO,IAAZ,EAA+B;AAC3B3B,oBAAgB,CAAU,IAAV,EAAgB;AAAE2B,UAAF;AAAQC,gBAAU,EAAE;AAApB,KAAhB,CAAhB;AACH;;AAVe,C,CAoBpB;;AACA,MAAME,YAAY,GAA2B;AACzC,OAAK,eADoC;AAEzC,OAAK,eAFoC;AAGzC,QAAM,qBAHmC;AAIzC,QAAM,4BAJmC;AAKzC,QAAM,eALmC;AAMzC,QAAM,6CANmC;AAOzC,QAAM,uDAPmC;AAQzC,QAAM,4CARmC;AASzC,QAAM,eATmC;AAUzC,QAAM;AAVmC,CAA7C;AAaA,MAAMC,aAAa,GAA8B;AAC7C,gBAAc;AACVd,aAAS,EAAE,eADD;AAEVD,QAAI,EAAE,OAFI;AAGVgB,UAAM,EAAE,CAAE,QAAF,CAHE;AAIVC,UAAM,EAAGC,OAAD,IAAoB;AACxB,aAAO,+BAAgCC,IAAI,CAACC,SAAL,CAAeF,OAAf,CAAwB,EAA/D;AACH;AANS,GAD+B;AAS7C,gBAAc;AACVjB,aAAS,EAAE,gBADD;AAEVD,QAAI,EAAE,OAFI;AAGVgB,UAAM,EAAE,CAAE,SAAF,CAHE;AAIVC,UAAM,EAAGI,IAAD,IAAiB;AACrB,UAAIJ,MAAM,GAAG,oBAAb;;AACA,UAAII,IAAI,IAAI,CAAR,IAAaA,IAAI,IAAI,IAArB,IAA6BP,YAAY,CAACO,IAAI,CAACC,QAAL,EAAD,CAA7C,EAAgE;AAC5DL,cAAM,GAAGH,YAAY,CAACO,IAAI,CAACC,QAAL,EAAD,CAArB;AACH;;AACD,aAAO,8BAA+BD,IAAI,CAACC,QAAL,CAAc,EAAd,CAAkB,KAAML,MAAO,GAArE;AACH;AAVS;AAT+B,CAAjD;AAiDA;;;;;;;;;;;AAUA,OAAM,MAAOM,SAAP,CAAgB;AAElB;;;AAGSC,WAAS;AAElB;;;;AAGSC,QAAM;AAEf;;;;AAGSC,UAAQ;AAEjB;;;;AAGSC,SAAO;AAEhB;AACA;AACA,aAxBkB,CAyBtB;;AAEI;AAEA;;;;AAGAvB,cAAYoB,SAAZ,EAAmC;AAC/B,QAAII,GAAG,GAAoD,EAA3D;;AACA,QAAI,OAAOJ,SAAP,KAAsB,QAA1B,EAAoC;AAChCI,SAAG,GAAGT,IAAI,CAACU,KAAL,CAAWL,SAAX,CAAN;AACH,KAFD,MAEO;AACHI,SAAG,GAAGJ,SAAN;AACH;;AAED,SAAK,UAAL,GAAkB,IAAIM,GAAJ,EAAlB;AACA,SAAK,OAAL,GAAe,IAAIA,GAAJ,EAAf;AACA,SAAK,OAAL,GAAe,IAAIA,GAAJ,EAAf,CAV+B,CAWvC;;AAGQ,UAAMC,KAAK,GAAoB,EAA/B;;AACA,SAAK,MAAMC,CAAX,IAAgBJ,GAAhB,EAAqB;AACjB,UAAI;AACAG,aAAK,CAACE,IAAN,CAAWvC,QAAQ,CAACwC,IAAT,CAAcF,CAAd,CAAX;AACH,OAFD,CAEE,OAAOG,KAAP,EAAc;AACZC,eAAO,CAACC,GAAR,CAAY,IAAZ,EAAkBF,KAAlB;AACH;AACJ;;AAEDnD,oBAAgB,CAAY,IAAZ,EAAkB;AAC9BwC,eAAS,EAAEc,MAAM,CAACC,MAAP,CAAcR,KAAd;AADmB,KAAlB,CAAhB;AAIA,QAAIL,QAAQ,GAA4B,IAAxC;AACA,QAAIC,OAAO,GAAG,KAAd;AAEA,SAAK,SAAL,GAAiB,KAAKa,WAAL,EAAjB,CA9B+B,CAgC/B;;AACA,SAAKhB,SAAL,CAAeiB,OAAf,CAAuB,CAAC1C,QAAD,EAAW2C,KAAX,KAAoB;AACvC,UAAIC,MAAJ;;AACA,cAAQ5C,QAAQ,CAAC6C,IAAjB;AACI,aAAK,aAAL;AACI,cAAI,KAAKnB,MAAT,EAAiB;AACbW,mBAAO,CAACC,GAAR,CAAY,oCAAZ;AACA;AACH,WAJL,CAKI;;;AACArD,0BAAgB,CAAY,IAAZ,EAAkB;AAAEyC,kBAAM,EAAuB1B;AAA/B,WAAlB,CAAhB;AACA;;AAEJ,aAAK,UAAL;AACI,cAAIA,QAAQ,CAACiB,MAAT,CAAgB6B,MAAhB,KAA2B,CAA/B,EAAkC;AAC9BlB,mBAAO,GAAG,IAAV;AACH,WAFD,MAEO;AACH1C,0BAAc,CAAC,CAACyC,QAAD,IAAgC3B,QAAS,CAAC+C,OAAV,KAAsBpB,QAAQ,CAACoB,OAAhE,EACV,gCADU,EACwB,aAAcJ,KAAM,GAD5C,EACiD3C,QADjD,CAAd;AAEA2B,oBAAQ,GAAqB3B,QAA7B;AACA4B,mBAAO,GAAGD,QAAQ,CAACoB,OAAnB;AACH;;AACD;;AAEJ,aAAK,UAAL;AACI;AACA;AACAH,gBAAM,GAAG,KAAK,UAAd;AACA;;AAEJ,aAAK,OAAL;AACI;AACAA,gBAAM,GAAG,KAAK,OAAd;AACA;;AAEJ,aAAK,OAAL;AACIA,gBAAM,GAAG,KAAK,OAAd;AACA;;AAEJ;AACI;AArCR,OAFuC,CA0CvC;;;AACA,YAAM1C,SAAS,GAAGF,QAAQ,CAACM,MAAT,EAAlB;;AACA,UAAIsC,MAAM,CAACI,GAAP,CAAW9C,SAAX,CAAJ,EAA2B;AAAE;AAAS;;AAEtC0C,YAAM,CAACK,GAAP,CAAW/C,SAAX,EAAsBF,QAAtB;AACH,KA/CD,EAjC+B,CAkF/B;;AACA,QAAI,CAAC,KAAK0B,MAAV,EAAkB;AACdzC,sBAAgB,CAAY,IAAZ,EAAkB;AAC9ByC,cAAM,EAAElC,mBAAmB,CAAC2C,IAApB,CAAyB,eAAzB;AADsB,OAAlB,CAAhB;AAGH;;AAEDlD,oBAAgB,CAAY,IAAZ,EAAkB;AAAE0C,cAAF;AAAYC;AAAZ,KAAlB,CAAhB;AACH;AAED;;;;;;;AAKAtB,QAAM,CAAC4C,OAAD,EAAkB;AACpB,UAAM5C,MAAM,GAAI4C,OAAO,GAAG,SAAH,GAAc,MAArC;AACA,UAAMrB,GAAG,GAAG,KAAKJ,SAAL,CAAe0B,GAAf,CAAoBC,CAAD,IAAOA,CAAC,CAAC9C,MAAF,CAASA,MAAT,CAA1B,CAAZ;AACA,WAAOuB,GAAP;AACH;AAED;;;;;;AAIAwB,YAAU;AACN,UAAMxB,GAAG,GAAG,KAAKJ,SAAL,CAAe0B,GAAf,CAAoBC,CAAD,IAAOA,CAAC,CAAC9C,MAAF,CAAS,MAAT,CAA1B,CAAZ,CADM,CAGN;;AACA,WAAOc,IAAI,CAACC,SAAL,CAAeQ,GAAG,CAACsB,GAAJ,CAASG,CAAD,IAAOlC,IAAI,CAACU,KAAL,CAAWwB,CAAX,CAAf,CAAf,CAAP;AACH;AAED;;;;;;AAIAb,aAAW;AACP,WAAOpD,QAAQ,CAACkE,eAAT,EAAP;AACH,GAxJiB,CA0JlB;;;AACA,cAAY,CAACC,GAAD,EAAcC,MAAd,EAAiDC,WAAjD,EAAqE;AAE7E;AACA,QAAI1E,WAAW,CAACwE,GAAD,CAAf,EAAsB;AAClB,YAAMhD,QAAQ,GAAGgD,GAAG,CAACG,WAAJ,EAAjB;;AACA,WAAK,MAAM3D,QAAX,IAAuB,KAAK,UAAL,CAAgByD,MAAhB,EAAvB,EAAiD;AAC7C,YAAIjD,QAAQ,KAAKR,QAAQ,CAACQ,QAA1B,EAAoC;AAAE,iBAAOR,QAAP;AAAkB;AAC3D;;AACD,aAAO,IAAP;AACH,KAT4E,CAW7E;;;AACA,QAAIwD,GAAG,CAACI,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CAA1B,EAA6B;AACzB,YAAMC,QAAQ,GAA4B,EAA1C;;AACA,WAAK,MAAM,CAAE5D,IAAF,EAAQD,QAAR,CAAX,IAAiC,KAAK,UAAtC,EAAkD;AAC9C,YAAIC,IAAI,CAAC6D,KAAL,CAAW;AAAG;AAAd,UAA2B,CAA3B,MAAkCN,GAAtC,EAA2C;AAAEK,kBAAQ,CAAC3B,IAAT,CAAclC,QAAd;AAA0B;AAC1E;;AAED,UAAIyD,MAAJ,EAAY;AACR,cAAMM,SAAS,GAAIN,MAAM,CAACX,MAAP,GAAgB,CAAjB,GAAsBW,MAAM,CAACA,MAAM,CAACX,MAAP,GAAgB,CAAjB,CAA5B,GAAiD,IAAnE;AAEA,YAAIkB,WAAW,GAAGP,MAAM,CAACX,MAAzB;AACA,YAAImB,YAAY,GAAG,IAAnB;;AACA,YAAInE,KAAK,CAACoE,OAAN,CAAcH,SAAd,KAA4BA,SAAS,CAAClB,IAAV,KAAmB,WAAnD,EAAgE;AAC5DoB,sBAAY,GAAG,KAAf;AACAD,qBAAW;AACd,SARO,CAUR;AACA;;;AACA,aAAK,IAAIG,CAAC,GAAGN,QAAQ,CAACf,MAAT,GAAkB,CAA/B,EAAkCqB,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC3C,gBAAMlD,MAAM,GAAG4C,QAAQ,CAACM,CAAD,CAAR,CAAYlD,MAAZ,CAAmB6B,MAAlC;;AACA,cAAI7B,MAAM,KAAK+C,WAAX,KAA2B,CAACC,YAAD,IAAiBhD,MAAM,KAAK+C,WAAW,GAAG,CAArE,CAAJ,EAA6E;AACzEH,oBAAQ,CAACO,MAAT,CAAgBD,CAAhB,EAAmB,CAAnB;AACH;AACJ,SAjBO,CAmBR;;;AACA,aAAK,IAAIA,CAAC,GAAGN,QAAQ,CAACf,MAAT,GAAkB,CAA/B,EAAkCqB,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC3C,gBAAMlD,MAAM,GAAG4C,QAAQ,CAACM,CAAD,CAAR,CAAYlD,MAA3B;;AACA,eAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,MAAM,CAACX,MAA3B,EAAmCQ,CAAC,EAApC,EAAwC;AACpC;AACA,gBAAI,CAACxD,KAAK,CAACoE,OAAN,CAAcT,MAAM,CAACH,CAAD,CAApB,CAAL,EAA+B;AAAE;AAAW,aAFR,CAIpC;;;AACA,gBAAIA,CAAC,IAAIrC,MAAM,CAAC6B,MAAhB,EAAwB;AACpB,kBAAIW,MAAM,CAACH,CAAD,CAAN,CAAUT,IAAV,KAAmB,WAAvB,EAAoC;AAAE;AAAW;;AACjDgB,sBAAQ,CAACO,MAAT,CAAgBD,CAAhB,EAAmB,CAAnB;AACA;AACH,aATmC,CAWpC;;;AACA,gBAAIV,MAAM,CAACH,CAAD,CAAN,CAAUT,IAAV,KAAmB5B,MAAM,CAACqC,CAAD,CAAN,CAAUe,QAAjC,EAA2C;AACvCR,sBAAQ,CAACO,MAAT,CAAgBD,CAAhB,EAAmB,CAAnB;AACA;AACH;AACJ;AACJ;AACJ,OA9CwB,CAgDzB;AACA;;;AACA,UAAIN,QAAQ,CAACf,MAAT,KAAoB,CAApB,IAAyBW,MAAzB,IAAmCA,MAAM,CAACX,MAAP,KAAkBe,QAAQ,CAAC,CAAD,CAAR,CAAY5C,MAAZ,CAAmB6B,MAA5E,EAAoF;AAChF,cAAMwB,OAAO,GAAGb,MAAM,CAACA,MAAM,CAACX,MAAP,GAAgB,CAAjB,CAAtB;;AACA,YAAIwB,OAAO,IAAI,IAAX,IAAmBC,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAnB,IAA6C,OAAOA,OAAP,KAAoB,QAArE,EAA+E;AAC3ET,kBAAQ,CAACO,MAAT,CAAgB,CAAhB,EAAmB,CAAnB;AACH;AACJ;;AAED,UAAIP,QAAQ,CAACf,MAAT,KAAoB,CAAxB,EAA2B;AAAE,eAAO,IAAP;AAAc;;AAE3C,UAAIe,QAAQ,CAACf,MAAT,GAAkB,CAAlB,IAAuBY,WAA3B,EAAwC;AACpC,cAAMe,QAAQ,GAAGZ,QAAQ,CAACV,GAAT,CAAcuB,CAAD,IAAOtD,IAAI,CAACC,SAAL,CAAeqD,CAAC,CAACpE,MAAF,EAAf,CAApB,EAAgDqE,IAAhD,CAAqD,IAArD,CAAjB;AACAzF,sBAAc,CAAC,KAAD,EAAQ,gDAAiDuF,QAAS,GAAlE,EAAuE,KAAvE,EAA8EjB,GAA9E,CAAd;AACH;;AAED,aAAOK,QAAQ,CAAC,CAAD,CAAf;AACH,KA7E4E,CA+E7E;;;AACA,UAAMe,MAAM,GAAG,KAAK,UAAL,CAAgBC,GAAhB,CAAoBjF,gBAAgB,CAACuC,IAAjB,CAAsBqB,GAAtB,EAA2BlD,MAA3B,EAApB,CAAf;;AACA,QAAIsE,MAAJ,EAAY;AAAE,aAAOA,MAAP;AAAgB;;AAE9B,WAAO,IAAP;AACH;AAED;;;;;;AAIAE,iBAAe,CAACtB,GAAD,EAAY;AACvB,UAAMxD,QAAQ,GAAG,KAAK,YAAL,CAAkBwD,GAAlB,EAAuB,IAAvB,EAA6B,KAA7B,CAAjB;AACAtE,kBAAc,CAACc,QAAD,EAAW,sBAAX,EAAmC,KAAnC,EAA0CwD,GAA1C,CAAd;AACA,WAAOxD,QAAQ,CAACC,IAAhB;AACH;AAED;;;;;;;;;;;;AAUA8E,aAAW,CAACvB,GAAD,EAAcC,MAAd,EAAyC;AAChD,WAAO,KAAK,YAAL,CAAkBD,GAAlB,EAAuBC,MAAM,IAAI,IAAjC,EAAuC,IAAvC,CAAP;AACH;AAED;;;;;AAGAuB,iBAAe,CAACC,QAAD,EAA0D;AACrE,UAAMC,KAAK,GAAGX,KAAK,CAACpC,IAAN,CAAW,KAAK,UAAL,CAAgBgD,IAAhB,EAAX,CAAd;AACAD,SAAK,CAACE,IAAN,CAAW,CAACnD,CAAD,EAAIoD,CAAJ,KAAUpD,CAAC,CAACqD,aAAF,CAAgBD,CAAhB,CAArB;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,KAAK,CAACpC,MAA1B,EAAkCqB,CAAC,EAAnC,EAAuC;AACnC,YAAMlE,IAAI,GAAGiF,KAAK,CAACf,CAAD,CAAlB;AACAc,cAAQ,CAAoB,KAAK,UAAL,CAAgBJ,GAAhB,CAAoB5E,IAApB,CAApB,EAAgDkE,CAAhD,CAAR;AACH;AACJ,GAnRiB,CAsRlB;;;AACA,WAAS,CAACX,GAAD,EAAcC,MAAd,EAAwDC,WAAxD,EAA4E;AAEjF;AACA,QAAI1E,WAAW,CAACwE,GAAD,CAAf,EAAsB;AAClB,YAAM+B,UAAU,GAAG/B,GAAG,CAACG,WAAJ,EAAnB;;AACA,WAAK,MAAM3D,QAAX,IAAuB,KAAK,OAAL,CAAayD,MAAb,EAAvB,EAA8C;AAC1C,YAAI8B,UAAU,KAAKvF,QAAQ,CAACwF,SAA5B,EAAuC;AAAE,iBAAOxF,QAAP;AAAkB;AAC9D;;AACD,aAAO,IAAP;AACH,KATgF,CAWjF;;;AACA,QAAIwD,GAAG,CAACI,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CAA1B,EAA6B;AACzB,YAAMC,QAAQ,GAAG,EAAjB;;AACA,WAAK,MAAM,CAAE5D,IAAF,EAAQD,QAAR,CAAX,IAAiC,KAAK,OAAtC,EAA+C;AAC3C,YAAIC,IAAI,CAAC6D,KAAL,CAAW;AAAG;AAAd,UAA2B,CAA3B,MAAkCN,GAAtC,EAA2C;AAAEK,kBAAQ,CAAC3B,IAAT,CAAclC,QAAd;AAA0B;AAC1E;;AAED,UAAIyD,MAAJ,EAAY;AACR;AACA,aAAK,IAAIU,CAAC,GAAGN,QAAQ,CAACf,MAAT,GAAkB,CAA/B,EAAkCqB,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC3C,cAAIN,QAAQ,CAACM,CAAD,CAAR,CAAYlD,MAAZ,CAAmB6B,MAAnB,GAA4BW,MAAM,CAACX,MAAvC,EAA+C;AAC3Ce,oBAAQ,CAACO,MAAT,CAAgBD,CAAhB,EAAmB,CAAnB;AACH;AACJ,SANO,CAQR;;;AACA,aAAK,IAAIA,CAAC,GAAGN,QAAQ,CAACf,MAAT,GAAkB,CAA/B,EAAkCqB,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+C;AAC3C,gBAAMlD,MAAM,GAAG4C,QAAQ,CAACM,CAAD,CAAR,CAAYlD,MAA3B;;AACA,eAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,MAAM,CAACX,MAA3B,EAAmCQ,CAAC,EAApC,EAAwC;AACpC;AACA,gBAAI,CAACxD,KAAK,CAACoE,OAAN,CAAcT,MAAM,CAACH,CAAD,CAApB,CAAL,EAA+B;AAAE;AAAW,aAFR,CAIpC;;;AACA,gBAAIG,MAAM,CAACH,CAAD,CAAN,CAAUT,IAAV,KAAmB5B,MAAM,CAACqC,CAAD,CAAN,CAAUe,QAAjC,EAA2C;AACvCR,sBAAQ,CAACO,MAAT,CAAgBD,CAAhB,EAAmB,CAAnB;AACA;AACH;AACJ;AACJ;AACJ;;AAED,UAAIN,QAAQ,CAACf,MAAT,KAAoB,CAAxB,EAA2B;AAAE,eAAO,IAAP;AAAc;;AAE3C,UAAIe,QAAQ,CAACf,MAAT,GAAkB,CAAlB,IAAuBY,WAA3B,EAAwC;AACpC,cAAMe,QAAQ,GAAGZ,QAAQ,CAACV,GAAT,CAAcuB,CAAD,IAAOtD,IAAI,CAACC,SAAL,CAAeqD,CAAC,CAACpE,MAAF,EAAf,CAApB,EAAgDqE,IAAhD,CAAqD,IAArD,CAAjB;AACAzF,sBAAc,CAAC,KAAD,EAAQ,6CAA8CuF,QAAS,GAA/D,EAAoE,KAApE,EAA2EjB,GAA3E,CAAd;AACH;;AAED,aAAOK,QAAQ,CAAC,CAAD,CAAf;AACH,KAlDgF,CAoDjF;;;AACA,UAAMe,MAAM,GAAG,KAAK,OAAL,CAAaC,GAAb,CAAiBnF,aAAa,CAACyC,IAAd,CAAmBqB,GAAnB,EAAwBlD,MAAxB,EAAjB,CAAf;;AACA,QAAIsE,MAAJ,EAAY;AAAE,aAAOA,MAAP;AAAgB;;AAE9B,WAAO,IAAP;AACH;AAED;;;;;;AAIAa,cAAY,CAACjC,GAAD,EAAY;AACpB,UAAMxD,QAAQ,GAAG,KAAK,SAAL,CAAewD,GAAf,EAAoB,IAApB,EAA0B,KAA1B,CAAjB;AACAtE,kBAAc,CAACc,QAAD,EAAW,mBAAX,EAAgC,KAAhC,EAAuCwD,GAAvC,CAAd;AAEA,WAAOxD,QAAQ,CAACC,IAAhB;AACH;AAED;;;;;;;;;;;;AAUAyF,UAAQ,CAAClC,GAAD,EAAcC,MAAd,EAAyC;AAC7C,WAAO,KAAK,SAAL,CAAeD,GAAf,EAAoBC,MAAM,IAAI,IAA9B,EAAoC,IAApC,CAAP;AACH;AAED;;;;;AAGAkC,cAAY,CAACV,QAAD,EAAuD;AAC/D,UAAMC,KAAK,GAAGX,KAAK,CAACpC,IAAN,CAAW,KAAK,OAAL,CAAagD,IAAb,EAAX,CAAd;AACAD,SAAK,CAACE,IAAN,CAAW,CAACnD,CAAD,EAAIoD,CAAJ,KAAUpD,CAAC,CAACqD,aAAF,CAAgBD,CAAhB,CAArB;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,KAAK,CAACpC,MAA1B,EAAkCqB,CAAC,EAAnC,EAAuC;AACnC,YAAMlE,IAAI,GAAGiF,KAAK,CAACf,CAAD,CAAlB;AACAc,cAAQ,CAAiB,KAAK,OAAL,CAAaJ,GAAb,CAAiB5E,IAAjB,CAAjB,EAA0CkE,CAA1C,CAAR;AACH;AACJ;AAED;;;;;;;;;;;;AAUAyB,UAAQ,CAACpC,GAAD,EAAcC,MAAd,EAAyC;AAC7C,QAAIzE,WAAW,CAACwE,GAAD,CAAf,EAAsB;AAClB,YAAMhD,QAAQ,GAAGgD,GAAG,CAACG,WAAJ,EAAjB;;AAEA,UAAI3C,aAAa,CAACR,QAAD,CAAjB,EAA6B;AACzB,eAAOf,aAAa,CAAC0C,IAAd,CAAmBnB,aAAa,CAACR,QAAD,CAAb,CAAwBN,SAA3C,CAAP;AACH;;AAED,WAAK,MAAMF,QAAX,IAAuB,KAAK,OAAL,CAAayD,MAAb,EAAvB,EAA8C;AAC1C,YAAIjD,QAAQ,KAAKR,QAAQ,CAACQ,QAA1B,EAAoC;AAAE,iBAAOR,QAAP;AAAkB;AAC3D;;AAED,aAAO,IAAP;AACH,KAb4C,CAe7C;;;AACA,QAAIwD,GAAG,CAACI,OAAJ,CAAY,GAAZ,MAAqB,CAAC,CAA1B,EAA6B;AACzB,YAAMC,QAAQ,GAAG,EAAjB;;AACA,WAAK,MAAM,CAAE5D,IAAF,EAAQD,QAAR,CAAX,IAAiC,KAAK,OAAtC,EAA+C;AAC3C,YAAIC,IAAI,CAAC6D,KAAL,CAAW;AAAG;AAAd,UAA2B,CAA3B,MAAkCN,GAAtC,EAA2C;AAAEK,kBAAQ,CAAC3B,IAAT,CAAclC,QAAd;AAA0B;AAC1E;;AAED,UAAI6D,QAAQ,CAACf,MAAT,KAAoB,CAAxB,EAA2B;AACvB,YAAIU,GAAG,KAAK,OAAZ,EAAqB;AAAE,iBAAO/D,aAAa,CAAC0C,IAAd,CAAmB,qBAAnB,CAAP;AAAmD;;AAC1E,YAAIqB,GAAG,KAAK,OAAZ,EAAqB;AAAE,iBAAO/D,aAAa,CAAC0C,IAAd,CAAmB,sBAAnB,CAAP;AAAoD;;AAC3E,eAAO,IAAP;AACH,OAJD,MAIO,IAAI0B,QAAQ,CAACf,MAAT,GAAkB,CAAtB,EAAyB;AAC5B,cAAM2B,QAAQ,GAAGZ,QAAQ,CAACV,GAAT,CAAcuB,CAAD,IAAOtD,IAAI,CAACC,SAAL,CAAeqD,CAAC,CAACpE,MAAF,EAAf,CAApB,EAAgDqE,IAAhD,CAAqD,IAArD,CAAjB;AACAzF,sBAAc,CAAC,KAAD,EAAQ,qCAAsCuF,QAAS,GAAvD,EAA4D,MAA5D,EAAoEjB,GAApE,CAAd;AACH;;AAED,aAAOK,QAAQ,CAAC,CAAD,CAAf;AACH,KAhC4C,CAkC7C;;;AACAL,OAAG,GAAG/D,aAAa,CAAC0C,IAAd,CAAmBqB,GAAnB,EAAwBlD,MAAxB,EAAN;;AACA,QAAIkD,GAAG,KAAK,eAAZ,EAA6B;AAAE,aAAO/D,aAAa,CAAC0C,IAAd,CAAmB,qBAAnB,CAAP;AAAmD;;AAClF,QAAIqB,GAAG,KAAK,gBAAZ,EAA8B;AAAE,aAAO/D,aAAa,CAAC0C,IAAd,CAAmB,sBAAnB,CAAP;AAAoD;;AAEpF,UAAMyC,MAAM,GAAG,KAAK,OAAL,CAAaC,GAAb,CAAiBrB,GAAjB,CAAf;;AACA,QAAIoB,MAAJ,EAAY;AAAE,aAAOA,MAAP;AAAgB;;AAE9B,WAAO,IAAP;AACH;AAED;;;;;AAGAiB,cAAY,CAACZ,QAAD,EAAuD;AAC/D,UAAMC,KAAK,GAAGX,KAAK,CAACpC,IAAN,CAAW,KAAK,OAAL,CAAagD,IAAb,EAAX,CAAd;AACAD,SAAK,CAACE,IAAN,CAAW,CAACnD,CAAD,EAAIoD,CAAJ,KAAUpD,CAAC,CAACqD,aAAF,CAAgBD,CAAhB,CAArB;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,KAAK,CAACpC,MAA1B,EAAkCqB,CAAC,EAAnC,EAAuC;AACnC,YAAMlE,IAAI,GAAGiF,KAAK,CAACf,CAAD,CAAlB;AACAc,cAAQ,CAAiB,KAAK,OAAL,CAAaJ,GAAb,CAAiB5E,IAAjB,CAAjB,EAA0CkE,CAA1C,CAAR;AACH;AACJ,GAxbiB,CA0blB;;AACI;;;;;;;;;;;;;;;;AAqBJ;;AACA;;;;;;;;AAQA2B,eAAa,CAACC,MAAD,EAAmCC,IAAnC,EAAkD;AAC3D,WAAO,KAAK,SAAL,CAAeC,MAAf,CAAsBF,MAAtB,EAA8BC,IAA9B,CAAP;AACH;;AAEDE,eAAa,CAACH,MAAD,EAAmCtC,MAAnC,EAA6D;AACtE,WAAO,KAAK,SAAL,CAAe0C,MAAf,CAAsBJ,MAAtB,EAA8BtC,MAA9B,CAAP;AACH;AAED;;;;;;AAIA2C,cAAY,CAAC3C,MAAD,EAA4B;AACpC,WAAO,KAAKyC,aAAL,CAAmB,KAAKxE,MAAL,CAAYT,MAA/B,EAAuCwC,MAAM,IAAI,EAAjD,CAAP;AACH;AAED;;;;;;;;;;;AASA4C,mBAAiB,CAACrG,QAAD,EAAmCgG,IAAnC,EAAkD;AAC/D,QAAI,OAAOhG,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAKwC,QAAL,CAAc5F,QAAd,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,eAAJ,EAAqB,UAArB,EAAiCpD,QAAjC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAEDlE,kBAAc,CAACR,SAAS,CAACsH,IAAD,EAAO,CAAP,EAAU,CAAV,CAAT,KAA0BhG,QAAQ,CAACQ,QAApC,EACV,uCAAwCR,QAAQ,CAACC,IAAK,GAD5C,EACiD,MADjD,EACyD+F,IADzD,CAAd;AAGA,WAAO,KAAKF,aAAL,CAAmB9F,QAAQ,CAACiB,MAA5B,EAAoCvC,SAAS,CAACsH,IAAD,EAAO,CAAP,CAA7C,CAAP;AACH;AAED;;;;;;;;;;AAQAM,mBAAiB,CAACtG,QAAD,EAAmCyD,MAAnC,EAA8D;AAC3E,QAAI,OAAOzD,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAKwC,QAAL,CAAc5F,QAAd,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,eAAJ,EAAqB,UAArB,EAAiCpD,QAAjC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAED,WAAO3E,MAAM,CAAC,CACVuB,QAAQ,CAACQ,QADC,EAEV,KAAK0F,aAAL,CAAmBlG,QAAQ,CAACiB,MAA5B,EAAoCwC,MAAM,IAAI,EAA9C,CAFU,CAAD,CAAb;AAIH;AAED;;;;;;;;;;AAQA8C,oBAAkB,CAACvG,QAAD,EAAsCgG,IAAtC,EAAqD;AACnE,QAAI,OAAOhG,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAK2B,WAAL,CAAiB/E,QAAjB,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,kBAAJ,EAAwB,UAAxB,EAAoCpD,QAApC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAEDlE,kBAAc,CAACR,SAAS,CAACsH,IAAD,EAAO,CAAP,EAAU,CAAV,CAAT,KAA0BhG,QAAQ,CAACQ,QAApC,EACV,0CAA2CR,QAAQ,CAACC,IAAK,GAD/C,EACoD,MADpD,EAC4D+F,IAD5D,CAAd;AAGA,WAAO,KAAKF,aAAL,CAAmB9F,QAAQ,CAACiB,MAA5B,EAAoCvC,SAAS,CAACsH,IAAD,EAAO,CAAP,CAA7C,CAAP;AACH;AAED;;;;;;;AAKAQ,oBAAkB,CAACxG,QAAD,EAAsCyD,MAAtC,EAAiE;AAC/E,QAAI,OAAOzD,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAK2B,WAAL,CAAiB/E,QAAjB,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,kBAAJ,EAAwB,UAAxB,EAAoCpD,QAApC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAED,WAAO3E,MAAM,CAAC,CACVuB,QAAQ,CAACQ,QADC,EAEV,KAAK0F,aAAL,CAAmBlG,QAAQ,CAACiB,MAA5B,EAAoCwC,MAAM,IAAI,EAA9C,CAFU,CAAD,CAAb;AAIH;AAED;;;;;;;;;;;AASAgD,sBAAoB,CAACzG,QAAD,EAAsCgG,IAAtC,EAAqD;AACrE,QAAI,OAAOhG,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAK2B,WAAL,CAAiB/E,QAAjB,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,kBAAJ,EAAwB,UAAxB,EAAoCpD,QAApC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAED,QAAIjC,OAAO,GAAG,gCAAd;AAEA,UAAMuF,KAAK,GAAG7H,YAAY,CAACmH,IAAD,CAA1B;;AACA,QAAKU,KAAK,CAAC5D,MAAN,GAAe,EAAhB,KAAwB,CAA5B,EAA+B;AAC3B,UAAI;AACA,eAAO,KAAK,SAAL,CAAemD,MAAf,CAAsBjG,QAAQ,CAAC2G,OAA/B,EAAwCD,KAAxC,CAAP;AACH,OAFD,CAEE,OAAOtE,KAAP,EAAc;AACZjB,eAAO,GAAG,8BAAV;AACH;AACJ,KAhBoE,CAkBrE;;;AACA/B,UAAM,CAAC,KAAD,EAAQ+B,OAAR,EAAiB,UAAjB,EAA6B;AAC/BV,WAAK,EAAE3B,OAAO,CAAC4H,KAAD,CADiB;AAE/BE,UAAI,EAAE;AAAEC,cAAM,EAAE7G,QAAQ,CAACC,IAAnB;AAAyBC,iBAAS,EAAEF,QAAQ,CAACM,MAAT;AAApC;AAFyB,KAA7B,CAAN;AAIH;;AAEDwG,WAAS,CAACC,KAAD,EAAmBC,EAAnB,EAA+C;AACpD,UAAMhB,IAAI,GAAGpH,QAAQ,CAACmI,KAAD,EAAQ,MAAR,CAArB;AAEA,UAAM3E,KAAK,GAAG/C,QAAQ,CAAC4H,uBAAT,CAAiC,MAAjC,EAAyCD,EAAzC,EAA6ChB,IAA7C,CAAd,CAHoD,CAKpD;;AACA,QAAI,CAAC5D,KAAK,CAACjB,OAAN,CAAc+F,KAAd,CAAoB,kBAApB,CAAL,EAA8C;AAC1C,YAAM1G,QAAQ,GAAG1B,OAAO,CAACkH,IAAI,CAACmB,KAAL,CAAW,CAAX,EAAc,CAAd,CAAD,CAAxB;AAEA/E,WAAK,CAACjB,OAAN,GAAgB,2CAAhB;AACA,YAAMiG,EAAE,GAAG,KAAKxB,QAAL,CAAcpF,QAAd,CAAX;;AACA,UAAI4G,EAAJ,EAAQ;AACJ,YAAI;AACAhF,eAAK,CAACiF,MAAN,GAAe;AACXpH,gBAAI,EAAEmH,EAAE,CAACnH,IADE;AAEXC,qBAAS,EAAEkH,EAAE,CAAC9G,MAAH,EAFA;AAGXF,gBAAI,EAAE,KAAK,SAAL,CAAe6F,MAAf,CAAsBmB,EAAE,CAACnG,MAAzB,EAAiC+E,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAjC;AAHK,WAAf;AAKA/E,eAAK,CAAClB,MAAN,GAAekB,KAAK,CAACiF,MAAN,CAAanH,SAA5B;AACAkC,eAAK,CAACjB,OAAN,GAAgB,uBAAwBiB,KAAK,CAAClB,MAAO,EAArD;AACF,SARF,CAQG,OAAOoG,CAAP,EAAU;AACTlF,eAAK,CAACjB,OAAN,GAAgB,oDAAhB;AACH;AACJ;AACJ,KAxBmD,CA0BpD;;;AACA,UAAMoG,MAAM,GAAG,KAAKC,gBAAL,CAAsBR,EAAtB,CAAf;;AACA,QAAIO,MAAJ,EAAY;AACRnF,WAAK,CAACqF,UAAN,GAAmB;AACfZ,cAAM,EAAEU,MAAM,CAACtH,IADA;AAEfC,iBAAS,EAAEqH,MAAM,CAACrH,SAFH;AAGfE,YAAI,EAAEmH,MAAM,CAACnH;AAHE,OAAnB;AAKH;;AAED,WAAOgC,KAAP;AACH;AAED;;;;;;;;;;AAQAsF,sBAAoB,CAAC1H,QAAD,EAAsCyD,MAAtC,EAAiE;AACjF,QAAI,OAAOzD,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAK2B,WAAL,CAAiB/E,QAAjB,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,kBAAJ,EAAwB,UAAxB,EAAoCpD,QAApC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AACD,WAAOtE,OAAO,CAAC,KAAK,SAAL,CAAeqH,MAAf,CAAsBnG,QAAQ,CAAC2G,OAA/B,EAAwClD,MAAM,IAAI,EAAlD,CAAD,CAAd;AACH;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BI;;;AACAkE,oBAAkB,CAAC3H,QAAD,EAAmCyD,MAAnC,EAA6D;AAC3E,QAAI,OAAOzD,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAKsC,QAAL,CAAc1F,QAAd,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,eAAJ,EAAqB,eAArB,EAAsCpD,QAAtC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAEDhE,UAAM,CAACqE,MAAM,CAACX,MAAP,IAAiB9C,QAAQ,CAACiB,MAAT,CAAgB6B,MAAlC,EAA0C,0BAA2B9C,QAAQ,CAACM,MAAT,EAAkB,EAAvF,EACF,qBADE,EACqB;AAAEsH,WAAK,EAAEnE,MAAM,CAACX,MAAhB;AAAwB+E,mBAAa,EAAE7H,QAAQ,CAACiB,MAAT,CAAgB6B;AAAvD,KADrB,CAAN;AAGA,UAAMgF,MAAM,GAAyC,EAArD;;AACA,QAAI,CAAC9H,QAAQ,CAAC+H,SAAd,EAAyB;AAAED,YAAM,CAAC5F,IAAP,CAAYlC,QAAQ,CAACwF,SAArB;AAAkC,KAXc,CAa3E;;;AACA,UAAMwC,WAAW,GAAG,CAACC,KAAD,EAAmBxH,KAAnB,KAAyC;AACzD,UAAIwH,KAAK,CAACpF,IAAN,KAAe,QAAnB,EAA6B;AACxB,eAAOrE,EAAE,CAACiC,KAAD,CAAT;AACJ,OAFD,MAEO,IAAIwH,KAAK,CAACpF,IAAN,KAAe,OAAnB,EAA4B;AAC9B,eAAOtE,SAAS,CAACO,OAAO,CAAC2B,KAAD,CAAR,CAAhB;AACJ;;AAED,UAAIwH,KAAK,CAACpF,IAAN,KAAe,MAAf,IAAyB,OAAOpC,KAAP,KAAkB,SAA/C,EAA0D;AACtDA,aAAK,GAAIA,KAAK,GAAG,MAAH,GAAW,MAAzB;AACH;;AAED,UAAIwH,KAAK,CAACpF,IAAN,CAAWqE,KAAX,CAAiB,QAAjB,CAAJ,EAAgC;AAC5BzG,aAAK,GAAGtB,OAAO,CAACsB,KAAD,CAAf;AACH,OAbwD,CAezD;;;AACA,UAAIwH,KAAK,CAACpF,IAAN,KAAe,SAAnB,EAA8B;AAAE,aAAK,SAAL,CAAesD,MAAf,CAAuB,CAAE,SAAF,CAAvB,EAAsC,CAAE1F,KAAF,CAAtC;AAAmD;;AACnF,aAAO1B,YAAY,CAACD,OAAO,CAAC2B,KAAD,CAAR,EAAiB,EAAjB,CAAnB,CAjByD,CAkBzD;AACH,KAnBD;;AAqBAgD,UAAM,CAACf,OAAP,CAAe,CAACjC,KAAD,EAAQkC,KAAR,KAAiB;AAE5B,YAAMsF,KAAK,GAAmBjI,QAAS,CAACiB,MAAV,CAAiB0B,KAAjB,CAA9B;;AAEA,UAAI,CAACsF,KAAK,CAACC,OAAX,EAAoB;AAChBhJ,sBAAc,CAACuB,KAAK,IAAI,IAAV,EACV,oDADU,EAC6C,cAAcwH,KAAK,CAAChI,IADjE,EACwEQ,KADxE,CAAd;AAEA;AACH;;AAED,UAAIA,KAAK,IAAI,IAAb,EAAmB;AACfqH,cAAM,CAAC5F,IAAP,CAAY,IAAZ;AACH,OAFD,MAEO,IAAI+F,KAAK,CAAC5D,QAAN,KAAmB,OAAnB,IAA8B4D,KAAK,CAAC5D,QAAN,KAAmB,OAArD,EAA8D;AACjEnF,sBAAc,CAAC,KAAD,EAAQ,+CAAR,EAA0D,cAAc+I,KAAK,CAAChI,IAA9E,EAAqFQ,KAArF,CAAd;AACH,OAFM,MAEA,IAAI8D,KAAK,CAACC,OAAN,CAAc/D,KAAd,CAAJ,EAA0B;AAC7BqH,cAAM,CAAC5F,IAAP,CAAYzB,KAAK,CAAC0C,GAAN,CAAW1C,KAAD,IAAWuH,WAAW,CAACC,KAAD,EAAQxH,KAAR,CAAhC,CAAZ;AACH,OAFM,MAEA;AACHqH,cAAM,CAAC5F,IAAP,CAAY8F,WAAW,CAACC,KAAD,EAAQxH,KAAR,CAAvB;AACH;AACJ,KAnBD,EAnC2E,CAwD3E;;AACA,WAAOqH,MAAM,CAAChF,MAAP,IAAiBgF,MAAM,CAACA,MAAM,CAAChF,MAAP,GAAgB,CAAjB,CAAN,KAA8B,IAAtD,EAA4D;AACxDgF,YAAM,CAACK,GAAP;AACH;;AAED,WAAOL,MAAP;AACH;;AAEDM,gBAAc,CAACpI,QAAD,EAAmCyD,MAAnC,EAA6D;AACvE,QAAI,OAAOzD,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAKsC,QAAL,CAAc1F,QAAd,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,eAAJ,EAAqB,eAArB,EAAsCpD,QAAtC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAED,UAAM0E,MAAM,GAAkB,EAA9B;AAEA,UAAMO,SAAS,GAAqB,EAApC;AACA,UAAMC,UAAU,GAAkB,EAAlC;;AAEA,QAAI,CAACtI,QAAQ,CAAC+H,SAAd,EAAyB;AACrBD,YAAM,CAAC5F,IAAP,CAAYlC,QAAQ,CAACwF,SAArB;AACH;;AAEDtG,kBAAc,CAACuE,MAAM,CAACX,MAAP,KAAkB9C,QAAQ,CAACiB,MAAT,CAAgB6B,MAAnC,EACV,iCADU,EACyB,QADzB,EACmCW,MADnC,CAAd;AAGAzD,YAAQ,CAACiB,MAAT,CAAgByB,OAAhB,CAAwB,CAACuF,KAAD,EAAQtF,KAAR,KAAiB;AACrC,YAAMlC,KAAK,GAAGgD,MAAM,CAACd,KAAD,CAApB;;AACA,UAAIsF,KAAK,CAACC,OAAV,EAAmB;AACf,YAAID,KAAK,CAACpF,IAAN,KAAe,QAAnB,EAA6B;AACzBiF,gBAAM,CAAC5F,IAAP,CAAY1D,EAAE,CAACiC,KAAD,CAAd;AACH,SAFD,MAEO,IAAIwH,KAAK,CAACpF,IAAN,KAAe,OAAnB,EAA4B;AAC/BiF,gBAAM,CAAC5F,IAAP,CAAY3D,SAAS,CAACkC,KAAD,CAArB;AACH,SAFM,MAEA,IAAIwH,KAAK,CAAC5D,QAAN,KAAmB,OAAnB,IAA8B4D,KAAK,CAAC5D,QAAN,KAAmB,OAArD,EAA8D;AACjE;AACA,gBAAM,IAAIkE,KAAJ,CAAU,iBAAV,CAAN;AACH,SAHM,MAGA;AACHT,gBAAM,CAAC5F,IAAP,CAAY,KAAK,SAAL,CAAeiE,MAAf,CAAsB,CAAE8B,KAAK,CAACpF,IAAR,CAAtB,EAAsC,CAAEpC,KAAF,CAAtC,CAAZ;AACH;AACJ,OAXD,MAWO;AACH4H,iBAAS,CAACnG,IAAV,CAAe+F,KAAf;AACAK,kBAAU,CAACpG,IAAX,CAAgBzB,KAAhB;AACH;AACJ,KAjBD;AAmBA,WAAO;AACHuF,UAAI,EAAE,KAAK,SAAL,CAAeG,MAAf,CAAsBkC,SAAtB,EAAkCC,UAAlC,CADH;AAEHR,YAAM,EAAEA;AAFL,KAAP;AAIH,GA7xBiB,CA+xBlB;;;AACAU,gBAAc,CAACxI,QAAD,EAAmCgG,IAAnC,EAAoD8B,MAApD,EAAkF;AAC5F,QAAI,OAAO9H,QAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAMoD,CAAC,GAAG,KAAKsC,QAAL,CAAc1F,QAAd,CAAV;AACAd,oBAAc,CAACkE,CAAD,EAAI,eAAJ,EAAqB,eAArB,EAAsCpD,QAAtC,CAAd;AACAA,cAAQ,GAAGoD,CAAX;AACH;;AAED,QAAI0E,MAAM,IAAI,IAAV,IAAkB,CAAC9H,QAAQ,CAAC+H,SAAhC,EAA2C;AACvC,YAAMxC,UAAU,GAAGvF,QAAQ,CAACwF,SAA5B;AACAtG,oBAAc,CAACF,WAAW,CAAC8I,MAAM,CAAC,CAAD,CAAP,EAAY,EAAZ,CAAX,IAA8BA,MAAM,CAAC,CAAD,CAAN,CAAUnE,WAAV,OAA4B4B,UAA3D,EACV,yBADU,EACiB,WADjB,EAC8BuC,MAAM,CAAC,CAAD,CADpC,CAAd;AAEAA,YAAM,GAAGA,MAAM,CAACX,KAAP,CAAa,CAAb,CAAT;AACH;;AAED,UAAMe,OAAO,GAAqB,EAAlC;AACA,UAAMO,UAAU,GAAqB,EAArC;AACA,UAAMC,OAAO,GAAmB,EAAhC;AAEA1I,YAAQ,CAACiB,MAAT,CAAgByB,OAAhB,CAAwB,CAACuF,KAAD,EAAQtF,KAAR,KAAiB;AACrC,UAAIsF,KAAK,CAACC,OAAV,EAAmB;AACf,YAAID,KAAK,CAACpF,IAAN,KAAe,QAAf,IAA2BoF,KAAK,CAACpF,IAAN,KAAe,OAA1C,IAAqDoF,KAAK,CAAC5D,QAAN,KAAmB,OAAxE,IAAmF4D,KAAK,CAAC5D,QAAN,KAAmB,OAA1G,EAAmH;AAC/G6D,iBAAO,CAAChG,IAAR,CAAarC,SAAS,CAACsC,IAAV,CAAe;AAAEU,gBAAI,EAAE,SAAR;AAAmB5C,gBAAI,EAAEgI,KAAK,CAAChI;AAA/B,WAAf,CAAb;AACAyI,iBAAO,CAACxG,IAAR,CAAa,IAAb;AACH,SAHD,MAGO;AACHgG,iBAAO,CAAChG,IAAR,CAAa+F,KAAb;AACAS,iBAAO,CAACxG,IAAR,CAAa,KAAb;AACH;AACJ,OARD,MAQO;AACHuG,kBAAU,CAACvG,IAAX,CAAgB+F,KAAhB;AACAS,eAAO,CAACxG,IAAR,CAAa,KAAb;AACH;AACJ,KAbD;AAeA,UAAMyG,aAAa,GAAIb,MAAM,IAAI,IAAX,GAAmB,KAAK,SAAL,CAAe7B,MAAf,CAAsBiC,OAAtB,EAA+BzJ,MAAM,CAACqJ,MAAD,CAArC,CAAnB,GAAmE,IAAzF;AACA,UAAMc,gBAAgB,GAAG,KAAK,SAAL,CAAe3C,MAAf,CAAsBwC,UAAtB,EAAkCzC,IAAlC,EAAwC,IAAxC,CAAzB,CAlC4F,CAoC5F;;AACA,UAAMvC,MAAM,GAAe,EAA3B;AACA,UAAM0B,IAAI,GAAyB,EAAnC;AACA,QAAI0D,eAAe,GAAG,CAAtB;AAAA,QAAyBC,YAAY,GAAG,CAAxC;AACA9I,YAAQ,CAACiB,MAAT,CAAgByB,OAAhB,CAAwB,CAACuF,KAAD,EAAQtF,KAAR,KAAiB;AACrC,UAAIlC,KAAK,GAAG,IAAZ;;AACA,UAAIwH,KAAK,CAACC,OAAV,EAAmB;AACf,YAAIS,aAAa,IAAI,IAArB,EAA2B;AACvBlI,eAAK,GAAG,IAAIE,OAAJ,CAAY,IAAZ,CAAR;AAEH,SAHD,MAGO,IAAI+H,OAAO,CAAC/F,KAAD,CAAX,EAAoB;AACvBlC,eAAK,GAAG,IAAIE,OAAJ,CAAYgI,aAAa,CAACG,YAAY,EAAb,CAAzB,CAAR;AAEH,SAHM,MAGA;AACH,cAAI;AACArI,iBAAK,GAAGkI,aAAa,CAACG,YAAY,EAAb,CAArB;AACH,WAFD,CAEE,OAAO1G,KAAP,EAAc;AACZ3B,iBAAK,GAAG2B,KAAR;AACH;AACJ;AACJ,OAdD,MAcO;AACH,YAAI;AACA3B,eAAK,GAAGmI,gBAAgB,CAACC,eAAe,EAAhB,CAAxB;AACH,SAFD,CAEE,OAAOzG,KAAP,EAAc;AACZ3B,eAAK,GAAG2B,KAAR;AACH;AACJ;;AAEDqB,YAAM,CAACvB,IAAP,CAAYzB,KAAZ;AACA0E,UAAI,CAACjD,IAAL,CAAU+F,KAAK,CAAChI,IAAN,IAAc,IAAxB;AACH,KA1BD;AA4BA,WAAOV,MAAM,CAACwJ,SAAP,CAAiBtF,MAAjB,EAAyB0B,IAAzB,CAAP;AACH;AAED;;;;;;;;AAMAqC,kBAAgB,CAACR,EAAD,EAA2C;AACvD,UAAMhB,IAAI,GAAGpH,QAAQ,CAACoI,EAAE,CAAChB,IAAJ,EAAU,SAAV,CAArB;AACA,UAAMvF,KAAK,GAAG9B,SAAS,CAAEqI,EAAE,CAACvG,KAAH,IAAY,IAAb,GAAqBuG,EAAE,CAACvG,KAAxB,GAA+B,CAAhC,EAAmC,UAAnC,CAAvB;AAEA,UAAMT,QAAQ,GAAG,KAAK+E,WAAL,CAAiBjG,OAAO,CAACkH,IAAI,CAACmB,KAAL,CAAW,CAAX,EAAc,CAAd,CAAD,CAAxB,CAAjB;;AAEA,QAAI,CAACnH,QAAL,EAAe;AAAE,aAAO,IAAP;AAAc;;AAE/B,UAAMI,IAAI,GAAG,KAAK,SAAL,CAAe6F,MAAf,CAAsBjG,QAAQ,CAACiB,MAA/B,EAAuC+E,IAAI,CAACmB,KAAL,CAAW,CAAX,CAAvC,CAAb;AACA,WAAO,IAAI5G,sBAAJ,CAA2BP,QAA3B,EAAqCA,QAAQ,CAACQ,QAA9C,EAAwDJ,IAAxD,EAA8DK,KAA9D,CAAP;AACH;;AAEDuI,iBAAe,CAAChD,IAAD,EAAgB;AAC3B,UAAM,IAAIuC,KAAJ,CAAU,OAAV,CAAN;AACH;AAED;;;;;;;;AAMAU,UAAQ,CAAC3G,GAAD,EAA4C;AAChD,UAAMtC,QAAQ,GAAG,KAAK0F,QAAL,CAAcpD,GAAG,CAACwF,MAAJ,CAAW,CAAX,CAAd,CAAjB;;AAEA,QAAI,CAAC9H,QAAD,IAAaA,QAAQ,CAAC+H,SAA1B,EAAqC;AAAE,aAAO,IAAP;AAAc,KAHL,CAKhD;AACA;AACA;;;AAGD,WAAO,IAAIhI,cAAJ,CAAmBC,QAAnB,EAA6BA,QAAQ,CAACwF,SAAtC,EAAiD,KAAKgD,cAAL,CAAoBxI,QAApB,EAA8BsC,GAAG,CAAC0D,IAAlC,EAAwC1D,GAAG,CAACwF,MAA5C,CAAjD,CAAP;AACF;AAED;;;;;;;;AAMAoB,YAAU,CAAClD,IAAD,EAAgB;AACtB,UAAMmD,OAAO,GAAGrK,OAAO,CAACkH,IAAD,CAAvB;AAEA,UAAMhG,QAAQ,GAAG,KAAK4F,QAAL,CAAclH,SAAS,CAACyK,OAAD,EAAU,CAAV,EAAa,CAAb,CAAvB,CAAjB;;AAEA,QAAI,CAACnJ,QAAL,EAAe;AAAE,aAAO,IAAP;AAAc;;AAE/B,UAAMI,IAAI,GAAG,KAAK,SAAL,CAAe6F,MAAf,CAAsBjG,QAAQ,CAACiB,MAA/B,EAAuCvC,SAAS,CAACyK,OAAD,EAAU,CAAV,CAAhD,CAAb;AACA,WAAO,IAAIzI,gBAAJ,CAAqBV,QAArB,EAA+BA,QAAQ,CAACQ,QAAxC,EAAkDJ,IAAlD,CAAP;AACH;AAED;;;;;;;;AAMW,SAAJ+B,IAAI,CAAC1B,KAAD,EAAgC;AACvC;AACA,QAAIA,KAAK,YAAYe,SAArB,EAAgC;AAAE,aAAOf,KAAP;AAAe,KAFV,CAIvC;;;AACA,QAAI,OAAOA,KAAP,KAAkB,QAAtB,EAAgC;AAAE,aAAO,IAAIe,SAAJ,CAAcJ,IAAI,CAACU,KAAL,CAAWrB,KAAX,CAAd,CAAP;AAA0C,KALrC,CAOvC;;;AACA,QAAI,OAAaA,KAAM,CAACH,MAApB,KAAgC,UAApC,EAAgD;AAC5C,aAAO,IAAIkB,SAAJ,CAAoBf,KAAM,CAACH,MAAP,CAAc,MAAd,CAApB,CAAP;AACH,KAVsC,CAYvC;;;AACA,WAAO,IAAIkB,SAAJ,CAAcf,KAAd,CAAP;AACH;;AAr7BiB","names":["keccak256","id","concat","dataSlice","getBigInt","getBytes","getBytesCopy","hexlify","zeroPadValue","isHexString","defineProperties","assertArgument","toBeHex","assert","AbiCoder","checkResultErrors","Result","ConstructorFragment","ErrorFragment","EventFragment","Fragment","FunctionFragment","ParamType","Typed","LogDescription","fragment","name","signature","topic","args","constructor","format","TransactionDescription","selector","value","ErrorDescription","Indexed","hash","_isIndexed","isIndexed","PanicReasons","BuiltinErrors","inputs","reason","message","JSON","stringify","code","toString","Interface","fragments","deploy","fallback","receive","abi","parse","Map","frags","a","push","from","error","console","log","Object","freeze","getAbiCoder","forEach","index","bucket","type","length","payable","has","set","minimal","map","f","formatJson","j","defaultAbiCoder","key","values","forceUnique","toLowerCase","indexOf","matching","split","lastValue","valueLength","allowOptions","isTyped","i","splice","baseType","lastArg","Array","isArray","matchStr","m","join","result","get","getFunctionName","getFunction","forEachFunction","callback","names","keys","sort","b","localeCompare","eventTopic","topicHash","getEventName","getEvent","forEachEvent","getError","forEachError","_decodeParams","params","data","decode","_encodeParams","encode","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","encodeFunctionData","decodeFunctionResult","bytes","outputs","info","method","makeError","_data","tx","getBuiltinCallException","match","slice","ef","revert","e","parsed","parseTransaction","invocation","encodeFunctionResult","encodeFilterTopics","count","expectedCount","topics","anonymous","encodeTopic","param","indexed","pop","encodeEventLog","dataTypes","dataValues","Error","decodeEventLog","nonIndexed","dynamic","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","fromItems","parseCallResult","parseLog","parseError","hexData"],"sourceRoot":"","sources":["../../src.ts/abi/interface.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}