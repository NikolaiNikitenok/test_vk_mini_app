{"ast":null,"code":"/**\n *  Add details about signing here.\n *\n *  @_subsection: api/crypto:Signing  [about-signing]\n */\nimport * as secp256k1 from \"@noble/secp256k1\";\nimport { concat, dataLength, getBytes, getBytesCopy, hexlify, toBeHex, assertArgument } from \"../utils/index.js\";\nimport { computeHmac } from \"./hmac.js\";\nimport { Signature } from \"./signature.js\"; //const N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n// Make noble-secp256k1 sync\n\nsecp256k1.utils.hmacSha256Sync = function (key) {\n  for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    messages[_key - 1] = arguments[_key];\n  }\n\n  return getBytes(computeHmac(\"sha256\", key, concat(messages)));\n};\n/**\n *  A **SigningKey** provides high-level access to the elliptic curve\n *  cryptography (ECC) operations and key management.\n */\n\n\nexport class SigningKey {\n  #privateKey;\n  /**\n   *  Creates a new **SigningKey** for %%privateKey%%.\n   */\n\n  constructor(privateKey) {\n    assertArgument(dataLength(privateKey) === 32, \"invalid private key\", \"privateKey\", \"[REDACTED]\");\n    this.#privateKey = hexlify(privateKey);\n  }\n  /**\n   *  The private key.\n   */\n\n\n  get privateKey() {\n    return this.#privateKey;\n  }\n  /**\n   *  The uncompressed public key.\n   *\n   * This will always begin with the prefix ``0x04`` and be 132\n   * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).\n   */\n\n\n  get publicKey() {\n    return SigningKey.computePublicKey(this.#privateKey);\n  }\n  /**\n   *  The compressed public key.\n   *\n   *  This will always begin with either the prefix ``0x02`` or ``0x03``\n   *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal\n   *  nibbles)\n   */\n\n\n  get compressedPublicKey() {\n    return SigningKey.computePublicKey(this.#privateKey, true);\n  }\n  /**\n   *  Return the signature of the signed %%digest%%.\n   */\n\n\n  sign(digest) {\n    assertArgument(dataLength(digest) === 32, \"invalid digest length\", \"digest\", digest);\n    const [sigDer, recid] = secp256k1.signSync(getBytesCopy(digest), getBytesCopy(this.#privateKey), {\n      recovered: true,\n      canonical: true\n    });\n    const sig = secp256k1.Signature.fromHex(sigDer);\n    return Signature.from({\n      r: toBeHex(\"0x\" + sig.r.toString(16), 32),\n      s: toBeHex(\"0x\" + sig.s.toString(16), 32),\n      v: recid ? 0x1c : 0x1b\n    });\n  }\n  /**\n   *  Returns the [[link-wiki-ecdh]] shared secret between this\n   *  private key and the %%other%% key.\n   *\n   *  The %%other%% key may be any type of key, a raw public key,\n   *  a compressed/uncompressed pubic key or aprivate key.\n   *\n   *  Best practice is usually to use a cryptographic hash on the\n   *  returned value before using it as a symetric secret.\n   *\n   *  @example:\n   *    sign1 = new SigningKey(id(\"some-secret-1\"))\n   *    sign2 = new SigningKey(id(\"some-secret-2\"))\n   *\n   *    // Notice that privA.computeSharedSecret(pubB)...\n   *    sign1.computeSharedSecret(sign2.publicKey)\n   *    //_result:\n   *\n   *    // ...is equal to privB.computeSharedSecret(pubA).\n   *    sign2.computeSharedSecret(sign1.publicKey)\n   *    //_result:\n   */\n\n\n  computeSharedSecret(other) {\n    const pubKey = SigningKey.computePublicKey(other);\n    console.log(pubKey);\n    return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey)));\n  }\n  /**\n   *  Compute the public key for %%key%%, optionally %%compressed%%.\n   *\n   *  The %%key%% may be any type of key, a raw public key, a\n   *  compressed/uncompressed public key or private key.\n   *\n   *  @example:\n   *    sign = new SigningKey(id(\"some-secret\"));\n   *\n   *    // Compute the uncompressed public key for a private key\n   *    SigningKey.computePublicKey(sign.privateKey)\n   *    //_result:\n   *\n   *    // Compute the compressed public key for a private key\n   *    SigningKey.computePublicKey(sign.privateKey, true)\n   *    //_result:\n   *\n   *    // Compute the uncompressed public key\n   *    SigningKey.computePublicKey(sign.publicKey, false);\n   *    //_result:\n   *\n   *    // Compute the Compressed a public key\n   *    SigningKey.computePublicKey(sign.publicKey, true);\n   *    //_result:\n   */\n\n\n  static computePublicKey(key, compressed) {\n    let bytes = getBytes(key, \"key\"); // private key\n\n    if (bytes.length === 32) {\n      const pubKey = secp256k1.getPublicKey(bytes, !!compressed);\n      return hexlify(pubKey);\n    } // raw public key; use uncompressed key with 0x04 prefix\n\n\n    if (bytes.length === 64) {\n      const pub = new Uint8Array(65);\n      pub[0] = 0x04;\n      pub.set(bytes, 1);\n      bytes = pub;\n    }\n\n    const point = secp256k1.Point.fromHex(bytes);\n    return hexlify(point.toRawBytes(compressed));\n  }\n  /**\n   *  Returns the public key for the private key which produced the\n   *  %%signature%% for the given %%digest%%.\n   *\n   *  @example:\n   *    key = new SigningKey(id(\"some-secret\"))\n   *    digest = id(\"hello world\")\n   *    sig = key.sign(digest)\n   *\n   *    // Notice the signer public key...\n   *    key.publicKey\n   *    //_result:\n   *\n   *    // ...is equal to the recovered public key\n   *    SigningKey.recoverPublicKey(digest, sig)\n   *    //_result:\n   *\n   */\n\n\n  static recoverPublicKey(digest, signature) {\n    assertArgument(dataLength(digest) === 32, \"invalid digest length\", \"digest\", digest);\n    const sig = Signature.from(signature);\n    const der = secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s]))).toDERRawBytes();\n    const pubKey = secp256k1.recoverPublicKey(getBytesCopy(digest), der, sig.yParity);\n\n    if (pubKey != null) {\n      return hexlify(pubKey);\n    }\n\n    assertArgument(false, \"invalid signautre for digest\", \"signature\", signature);\n  }\n  /**\n   *  Returns the point resulting from adding the ellipic curve points\n   *  %%p0%% and %%p1%%.\n   *\n   *  This is not a common function most developers should require, but\n   *  can be useful for certain privacy-specific techniques.\n   *\n   *  For example, it is used by [[HDNodeWallet]] to compute child\n   *  addresses from parent public keys and chain codes.\n   */\n\n\n  static addPoints(p0, p1, compressed) {\n    const pub0 = secp256k1.Point.fromHex(SigningKey.computePublicKey(p0).substring(2));\n    const pub1 = secp256k1.Point.fromHex(SigningKey.computePublicKey(p1).substring(2));\n    return \"0x\" + pub0.add(pub1).toHex(!!compressed);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["secp256k1","concat","dataLength","getBytes","getBytesCopy","hexlify","toBeHex","assertArgument","computeHmac","Signature","utils","hmacSha256Sync","key","messages","SigningKey","constructor","privateKey","publicKey","computePublicKey","compressedPublicKey","sign","digest","sigDer","recid","signSync","recovered","canonical","sig","fromHex","from","r","toString","s","v","computeSharedSecret","other","pubKey","console","log","getSharedSecret","compressed","bytes","length","getPublicKey","pub","Uint8Array","set","point","Point","toRawBytes","recoverPublicKey","signature","der","fromCompact","toDERRawBytes","yParity","addPoints","p0","p1","pub0","substring","pub1","add","toHex"],"sourceRoot":"","sources":["../../src.ts/crypto/signing-key.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}