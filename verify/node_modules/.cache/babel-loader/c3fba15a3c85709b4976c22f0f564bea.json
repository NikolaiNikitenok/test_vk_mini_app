{"ast":null,"code":"//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport { concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toTwos, zeroPadValue, assertArgument } from \"../utils/index.js\";\nimport { id } from \"./id.js\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\n\nfunction hexPadRight(value) {\n  const bytes = getBytes(value);\n  const padOffset = bytes.length % 32;\n\n  if (padOffset) {\n    return concat([bytes, padding.slice(padOffset)]);\n  }\n\n  return hexlify(bytes);\n}\n\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\n\nfunction checkString(key) {\n  return function (value) {\n    assertArgument(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n    return value;\n  };\n}\n\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (value) {\n    return getBigInt(value, \"domain.chainId\");\n  },\n  verifyingContract: function (value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n\n    assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    const bytes = getBytes(value, \"domain.salt\");\n    assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n    return hexlify(bytes);\n  }\n};\n\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n      const boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);\n      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        const value = getBigInt(_value, \"value\");\n        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n        return toBeHex(toTwos(value, 256), 32);\n      };\n    }\n  } // bytesXX\n\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n\n    if (match) {\n      const width = parseInt(match[1]);\n      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        const bytes = getBytes(value);\n        assertArgument(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return zeroPadValue(getAddress(value), 32);\n      };\n\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n\n  return null;\n}\n\nfunction encodeType(name, fields) {\n  return `${name}(${fields.map(_ref => {\n    let {\n      name,\n      type\n    } = _ref;\n    return type + \" \" + name;\n  }).join(\",\")})`;\n}\n\nexport class TypedDataEncoder {\n  primaryType;\n  #types;\n\n  get types() {\n    return JSON.parse(this.#types);\n  }\n\n  #fullTypes;\n  #encoderCache;\n\n  constructor(types) {\n    this.#types = JSON.stringify(types);\n    this.#fullTypes = new Map();\n    this.#encoderCache = new Map(); // Link struct types to their direct child structs\n\n    const links = new Map(); // Link structs to structs which contain them as a child\n\n    const parents = new Map(); // Link all subtypes within a given struct\n\n    const subtypes = new Map();\n    Object.keys(types).forEach(type => {\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n\n    for (const name in types) {\n      const uniqueNames = new Set();\n\n      for (const field of types[name]) {\n        // Check each field has a unique name\n        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n        uniqueNames.add(field.name); // Get the base type (drop any array specifiers)\n\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types); // Is this a base encoding type?\n\n        const encoder = getBaseEncoder(baseType);\n\n        if (encoder) {\n          continue;\n        }\n\n        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types); // Add linkage\n\n        parents.get(baseType).push(name);\n        links.get(name).add(baseType);\n      }\n    } // Deduce the primary type\n\n\n    const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);\n    assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(\", \")}`, \"types\", types);\n    defineProperties(this, {\n      primaryType: primaryTypes[0]\n    }); // Check for circular type references\n\n    function checkCircular(type, found) {\n      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n      found.add(type);\n\n      for (const child of links.get(type)) {\n        if (!parents.has(child)) {\n          continue;\n        } // Recursively check children\n\n\n        checkCircular(child, found); // Mark all ancestors as having this decendant\n\n        for (const subtype of found) {\n          subtypes.get(subtype).add(child);\n        }\n      }\n\n      found.delete(type);\n    }\n\n    checkCircular(this.primaryType, new Set()); // Compute each fully describe type\n\n    for (const [name, set] of subtypes) {\n      const st = Array.from(set);\n      st.sort();\n      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\"));\n    }\n  }\n\n  getEncoder(type) {\n    let encoder = this.#encoderCache.get(type);\n\n    if (!encoder) {\n      encoder = this.#getEncoder(type);\n      this.#encoderCache.set(type, encoder);\n    }\n\n    return encoder;\n  }\n\n  #getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n\n      if (encoder) {\n        return encoder;\n      }\n    } // Array\n\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n    if (match) {\n      const subtype = match[1];\n      const subEncoder = this.getEncoder(subtype);\n      return value => {\n        assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n        let result = value.map(subEncoder);\n\n        if (this.#fullTypes.has(subtype)) {\n          result = result.map(keccak256);\n        }\n\n        return keccak256(concat(result));\n      };\n    } // Struct\n\n\n    const fields = this.types[type];\n\n    if (fields) {\n      const encodedType = id(this.#fullTypes.get(type));\n      return value => {\n        const values = fields.map(_ref2 => {\n          let {\n            name,\n            type\n          } = _ref2;\n          const result = this.getEncoder(type)(value[name]);\n\n          if (this.#fullTypes.has(type)) {\n            return keccak256(result);\n          }\n\n          return result;\n        });\n        values.unshift(encodedType);\n        return concat(values);\n      };\n    }\n\n    assertArgument(false, `unknown type: ${type}`, \"type\", type);\n  }\n\n  encodeType(name) {\n    const result = this.#fullTypes.get(name);\n    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n    return result;\n  }\n\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n\n  hashStruct(name, value) {\n    return keccak256(this.encodeData(name, value));\n  }\n\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n\n      if (encoder) {\n        return callback(type, value);\n      }\n    } // Array\n\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n    if (match) {\n      assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n      return value.map(v => this._visit(match[1], v, callback));\n    } // Struct\n\n\n    const fields = this.types[type];\n\n    if (fields) {\n      return fields.reduce((accum, _ref3) => {\n        let {\n          name,\n          type\n        } = _ref3;\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n\n    assertArgument(false, `unknown type: ${type}`, \"type\", type);\n  }\n\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n\n  static hashDomain(domain) {\n    const domainFields = [];\n\n    for (const name in domain) {\n      const type = domainFieldTypes[name];\n      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n      domainFields.push({\n        name,\n        type\n      });\n    }\n\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n\n  static encode(domain, types, value) {\n    return concat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n\n  static hash(domain, types, value) {\n    return keccak256(TypedDataEncoder.encode(domain, types, value));\n  } // Replaces all address types with ENS names with their looked up address\n\n\n  static async resolveNames(domain, types, value, resolveName) {\n    // Make a copy to isolate it from the object passed in\n    domain = Object.assign({}, domain); // Look up all ENS names\n\n    const ensCache = {}; // Do we need to look up the domain's verifyingContract?\n\n    if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n      ensCache[domain.verifyingContract] = \"0x\";\n    } // We are going to use the encoder to visit all the base values\n\n\n    const encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n\n    encoder.visit(value, (type, value) => {\n      if (type === \"address\" && !isHexString(value, 20)) {\n        ensCache[value] = \"0x\";\n      }\n\n      return value;\n    }); // Lookup each name\n\n    for (const name in ensCache) {\n      ensCache[name] = await resolveName(name);\n    } // Replace the domain verifyingContract if needed\n\n\n    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n      domain.verifyingContract = ensCache[domain.verifyingContract];\n    } // Replace all ENS names with their address\n\n\n    value = encoder.visit(value, (type, value) => {\n      if (type === \"address\" && ensCache[value]) {\n        return ensCache[value];\n      }\n\n      return value;\n    });\n    return {\n      domain,\n      value\n    };\n  }\n\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type\n\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n\n      if (value == null) {\n        return;\n      }\n\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = Object.assign({}, types);\n    assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    typesWithDomain.EIP712Domain = domainTypes; // Validate the data structures and types\n\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return hexlify(getBytes(value));\n        } // uint or int\n\n\n        if (type.match(/^u?int/)) {\n          return getBigInt(value).toString();\n        }\n\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n\n          case \"bool\":\n            return !!value;\n\n          case \"string\":\n            assertArgument(typeof value === \"string\", \"invalid string\", \"value\", value);\n            return value;\n        }\n\n        assertArgument(false, \"unsupported type\", \"type\", type);\n      })\n    };\n  }\n\n}","map":{"version":3,"mappings":"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","names":["getAddress","keccak256","concat","defineProperties","getBigInt","getBytes","hexlify","isHexString","mask","toBeHex","toTwos","zeroPadValue","assertArgument","id","padding","Uint8Array","fill","BN__1","BigInt","BN_0","BN_1","BN_MAX_UINT256","hexPadRight","value","bytes","padOffset","length","slice","hexTrue","hexFalse","domainFieldTypes","name","version","chainId","verifyingContract","salt","domainFieldNames","checkString","key","JSON","stringify","domainChecks","toLowerCase","error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","boundsLower","_value","encodeType","fields","map","join","TypedDataEncoder","primaryType","types","parse","constructor","Map","links","parents","subtypes","Object","keys","forEach","set","Set","uniqueNames","field","has","add","baseType","encoder","get","push","primaryTypes","Array","from","filter","n","t","checkCircular","found","child","subtype","delete","st","sort","getEncoder","subEncoder","result","encodedType","values","unshift","encodeData","hashStruct","encode","hash","_visit","callback","v","reduce","accum","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","resolveNames","resolveName","assign","ensCache","getPayload","domainValues","domainTypes","typesWithDomain","message","toString"],"sourceRoot":"","sources":["../../src.ts/hash/typed-data.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}